/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseCore/Sources/Private/FIRComponentContainer.h:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |#import <Foundation/Foundation.h>
   17|       |
   18|       |NS_ASSUME_NONNULL_BEGIN
   19|       |
   20|       |/// A type-safe macro to retrieve a component from a container. This should be used to retrieve
   21|       |/// components instead of using the container directly.
   22|       |#define FIR_COMPONENT(type, container) \
   23|      0|  [FIRComponentType<id<type>> instanceForProtocol:@protocol(type) inContainer:container]
   24|       |
   25|       |@class FIRApp;
   26|       |
   27|       |/// A container that holds different components that are registered via the
   28|       |/// `registerAsComponentRegistrant:` call. These classes should conform to `FIRComponentRegistrant`
   29|       |/// in order to properly register components for Core.
   30|       |NS_SWIFT_NAME(FirebaseComponentContainer)
   31|       |@interface FIRComponentContainer : NSObject
   32|       |
   33|       |/// A weak reference to the app that an instance of the container belongs to.
   34|       |@property(nonatomic, weak, readonly) FIRApp *app;
   35|       |
   36|       |/// Unavailable. Use the `container` property on `FIRApp`.
   37|       |- (instancetype)init NS_UNAVAILABLE;
   38|       |
   39|       |@end
   40|       |
   41|       |NS_ASSUME_NONNULL_END

/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/Errors/FIRInstallationsErrorUtil.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseInstallations/Source/Library/Errors/FIRInstallationsErrorUtil.h"
   18|       |
   19|       |#import "FirebaseInstallations/Source/Library/Errors/FIRInstallationsHTTPError.h"
   20|       |
   21|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   22|       |#import <FBLPromises/FBLPromises.h>
   23|       |#else
   24|       |#import "FBLPromises.h"
   25|       |#endif
   26|       |
   27|       |NSString *const kFirebaseInstallationsErrorDomain = @"com.firebase.installations";
   28|       |
   29|      0|void FIRInstallationsItemSetErrorToPointer(NSError *error, NSError **pointer) {
   30|      0|  if (pointer != NULL) {
   31|      0|    *pointer = error;
   32|      0|  }
   33|      0|}
   34|       |
   35|       |@implementation FIRInstallationsErrorUtil
   36|       |
   37|      0|+ (NSError *)keyedArchiverErrorWithException:(NSException *)exception {
   38|      0|  NSString *failureReason = [NSString
   39|      0|      stringWithFormat:@"NSKeyedArchiver exception with name: %@, reason: %@, userInfo: %@",
   40|      0|                       exception.name, exception.reason, exception.userInfo];
   41|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   42|      0|                            failureReason:failureReason
   43|      0|                          underlyingError:nil];
   44|      0|}
   45|       |
   46|      0|+ (NSError *)keyedArchiverErrorWithError:(NSError *)error {
   47|      0|  NSString *failureReason = [NSString stringWithFormat:@"NSKeyedArchiver error."];
   48|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   49|      0|                            failureReason:failureReason
   50|      0|                          underlyingError:error];
   51|      0|}
   52|       |
   53|      0|+ (NSError *)keychainErrorWithFunction:(NSString *)keychainFunction status:(OSStatus)status {
   54|      0|  NSString *failureReason = [NSString stringWithFormat:@"%@ (%li)", keychainFunction, (long)status];
   55|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeKeychain
   56|      0|                            failureReason:failureReason
   57|      0|                          underlyingError:nil];
   58|      0|}
   59|       |
   60|      0|+ (NSError *)installationItemNotFoundForAppID:(NSString *)appID appName:(NSString *)appName {
   61|      0|  NSString *failureReason =
   62|      0|      [NSString stringWithFormat:@"Installation for appID %@ appName %@ not found", appID, appName];
   63|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   64|      0|                            failureReason:failureReason
   65|      0|                          underlyingError:nil];
   66|      0|}
   67|       |
   68|      0|+ (NSError *)corruptedIIDTokenData {
   69|      0|  NSString *failureReason =
   70|      0|      @"IID token data stored in Keychain is corrupted or in an incompatible format.";
   71|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   72|      0|                            failureReason:failureReason
   73|      0|                          underlyingError:nil];
   74|      0|}
   75|       |
   76|       |+ (FIRInstallationsHTTPError *)APIErrorWithHTTPResponse:(NSHTTPURLResponse *)HTTPResponse
   77|      0|                                                   data:(nullable NSData *)data {
   78|      0|  return [[FIRInstallationsHTTPError alloc] initWithHTTPResponse:HTTPResponse data:data];
   79|      0|}
   80|       |
   81|      0|+ (BOOL)isAPIError:(NSError *)error withHTTPCode:(NSInteger)HTTPCode {
   82|      0|  if (![error isKindOfClass:[FIRInstallationsHTTPError class]]) {
   83|      0|    return NO;
   84|      0|  }
   85|       |
   86|      0|  return [(FIRInstallationsHTTPError *)error HTTPResponse].statusCode == HTTPCode;
   87|      0|}
   88|       |
   89|      0|+ (NSError *)JSONSerializationError:(NSError *)error {
   90|      0|  NSString *failureReason = [NSString stringWithFormat:@"Failed to serialize JSON data."];
   91|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   92|      0|                            failureReason:failureReason
   93|      0|                          underlyingError:nil];
   94|      0|}
   95|       |
   96|      0|+ (NSError *)FIDRegistrationErrorWithResponseMissingField:(NSString *)missingFieldName {
   97|      0|  NSString *failureReason = [NSString
   98|      0|      stringWithFormat:@"A required response field with name %@ is missing", missingFieldName];
   99|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
  100|      0|                            failureReason:failureReason
  101|      0|                          underlyingError:nil];
  102|      0|}
  103|       |
  104|      0|+ (NSError *)networkErrorWithError:(NSError *)error {
  105|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeServerUnreachable
  106|      0|                            failureReason:@"Network connection error."
  107|      0|                          underlyingError:error];
  108|      0|}
  109|       |
  110|      0|+ (NSError *)backoffIntervalWaitError {
  111|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeServerUnreachable
  112|      0|                            failureReason:@"Too many server requests."
  113|      0|                          underlyingError:nil];
  114|      0|}
  115|       |
  116|      0|+ (NSError *)publicDomainErrorWithError:(NSError *)error {
  117|      0|  if ([error.domain isEqualToString:kFirebaseInstallationsErrorDomain]) {
  118|      0|    return error;
  119|      0|  }
  120|       |
  121|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
  122|      0|                            failureReason:nil
  123|      0|                          underlyingError:error];
  124|      0|}
  125|       |
  126|       |+ (NSError *)installationsErrorWithCode:(FIRInstallationsErrorCode)code
  127|       |                          failureReason:(nullable NSString *)failureReason
  128|      0|                        underlyingError:(nullable NSError *)underlyingError {
  129|      0|  NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
  130|      0|  userInfo[NSUnderlyingErrorKey] = underlyingError;
  131|      0|  userInfo[NSLocalizedFailureReasonErrorKey] =
  132|      0|      failureReason
  133|      0|          ?: [NSString
  134|      0|                 stringWithFormat:@"Underlying error: %@", underlyingError.localizedDescription];
  135|       |
  136|      0|  return [NSError errorWithDomain:kFirebaseInstallationsErrorDomain code:code userInfo:userInfo];
  137|      0|}
  138|       |
  139|      0|+ (FBLPromise *)rejectedPromiseWithError:(NSError *)error {
  140|      0|  FBLPromise *rejectedPromise = [FBLPromise pendingPromise];
  141|      0|  [rejectedPromise reject:error];
  142|      0|  return rejectedPromise;
  143|      0|}
  144|       |
  145|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/Errors/FIRInstallationsHTTPError.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseInstallations/Source/Library/Errors/FIRInstallationsHTTPError.h"
   18|       |#import "FirebaseInstallations/Source/Library/Errors/FIRInstallationsErrorUtil.h"
   19|       |
   20|       |@implementation FIRInstallationsHTTPError
   21|       |
   22|       |- (instancetype)initWithHTTPResponse:(NSHTTPURLResponse *)HTTPResponse
   23|      0|                                data:(nullable NSData *)data {
   24|      0|  NSDictionary *userInfo = [FIRInstallationsHTTPError userInfoWithHTTPResponse:HTTPResponse
   25|      0|                                                                          data:data];
   26|      0|  self = [super
   27|      0|      initWithDomain:kFirebaseInstallationsErrorDomain
   28|      0|                code:[FIRInstallationsHTTPError errorCodeWithHTTPCode:HTTPResponse.statusCode]
   29|      0|            userInfo:userInfo];
   30|      0|  if (self) {
   31|      0|    _HTTPResponse = HTTPResponse;
   32|      0|    _data = data;
   33|      0|  }
   34|      0|  return self;
   35|      0|}
   36|       |
   37|      0|+ (FIRInstallationsErrorCode)errorCodeWithHTTPCode:(NSInteger)HTTPCode {
   38|      0|  return FIRInstallationsErrorCodeUnknown;
   39|      0|}
   40|       |
   41|       |+ (NSDictionary *)userInfoWithHTTPResponse:(NSHTTPURLResponse *)HTTPResponse
   42|      0|                                      data:(nullable NSData *)data {
   43|      0|  NSString *responseString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
   44|      0|  NSString *failureReason =
   45|      0|      [NSString stringWithFormat:@"The server responded with an error: \n - URL: %@ \n - HTTP "
   46|      0|                                 @"status code: %ld \n - Response body: %@",
   47|      0|                                 HTTPResponse.URL, (long)HTTPResponse.statusCode, responseString];
   48|      0|  return @{NSLocalizedFailureReasonErrorKey : failureReason};
   49|      0|}
   50|       |
   51|       |#pragma mark - NSCopying
   52|       |
   53|      0|- (id)copyWithZone:(NSZone *)zone {
   54|      0|  return [[FIRInstallationsHTTPError alloc] initWithHTTPResponse:self.HTTPResponse data:self.data];
   55|      0|}
   56|       |
   57|       |#pragma mark - NSSecureCoding
   58|       |
   59|      0|- (nullable instancetype)initWithCoder:(NSCoder *)coder {
   60|      0|  NSHTTPURLResponse *HTTPResponse = [coder decodeObjectOfClass:[NSHTTPURLResponse class]
   61|      0|                                                        forKey:@"HTTPResponse"];
   62|      0|  if (!HTTPResponse) {
   63|      0|    return nil;
   64|      0|  }
   65|      0|  NSData *data = [coder decodeObjectOfClass:[NSData class] forKey:@"data"];
   66|       |
   67|      0|  return [self initWithHTTPResponse:HTTPResponse data:data];
   68|      0|}
   69|       |
   70|      0|- (void)encodeWithCoder:(NSCoder *)coder {
   71|      0|  [coder encodeObject:self.HTTPResponse forKey:@"HTTPResponse"];
   72|      0|  [coder encodeObject:self.data forKey:@"data"];
   73|      0|}
   74|       |
   75|      0|+ (BOOL)supportsSecureCoding {
   76|      0|  return YES;
   77|      0|}
   78|       |
   79|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/FIRInstallations.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseInstallations/Source/Library/Public/FirebaseInstallations/FIRInstallations.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |#import "FirebaseCore/Sources/Private/FirebaseCoreInternal.h"
   26|       |
   27|       |#import "FirebaseInstallations/Source/Library/FIRInstallationsAuthTokenResultInternal.h"
   28|       |
   29|       |#import "FirebaseInstallations/Source/Library/Errors/FIRInstallationsErrorUtil.h"
   30|       |#import "FirebaseInstallations/Source/Library/FIRInstallationsItem.h"
   31|       |#import "FirebaseInstallations/Source/Library/FIRInstallationsLogger.h"
   32|       |#import "FirebaseInstallations/Source/Library/InstallationsIDController/FIRInstallationsIDController.h"
   33|       |#import "FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStoredAuthToken.h"
   34|       |
   35|       |NS_ASSUME_NONNULL_BEGIN
   36|       |
   37|       |static const NSUInteger kExpectedAPIKeyLength = 39;
   38|       |
   39|       |@protocol FIRInstallationsInstanceProvider <FIRLibrary>
   40|       |@end
   41|       |
   42|       |@interface FIRInstallations () <FIRInstallationsInstanceProvider>
   43|       |@property(nonatomic, readonly) FIROptions *appOptions;
   44|       |@property(nonatomic, readonly) NSString *appName;
   45|       |
   46|       |@property(nonatomic, readonly) FIRInstallationsIDController *installationsIDController;
   47|       |
   48|       |@end
   49|       |
   50|       |@implementation FIRInstallations
   51|       |
   52|       |#pragma mark - Firebase component
   53|       |
   54|      1|+ (void)load {
   55|      1|  [FIRApp registerInternalLibrary:(Class<FIRLibrary>)self withName:@"fire-install"];
   56|      1|}
   57|       |
   58|      0|+ (nonnull NSArray<FIRComponent *> *)componentsToRegister {
   59|      0|  FIRComponentCreationBlock creationBlock =
   60|      0|      ^id _Nullable(FIRComponentContainer *container, BOOL *isCacheable) {
   61|      0|    *isCacheable = YES;
   62|      0|    FIRInstallations *installations = [[FIRInstallations alloc] initWithApp:container.app];
   63|      0|    return installations;
   64|      0|  };
   65|       |
   66|      0|  FIRComponent *installationsProvider =
   67|      0|      [FIRComponent componentWithProtocol:@protocol(FIRInstallationsInstanceProvider)
   68|      0|                      instantiationTiming:FIRInstantiationTimingAlwaysEager
   69|      0|                             dependencies:@[]
   70|      0|                            creationBlock:creationBlock];
   71|      0|  return @[ installationsProvider ];
   72|      0|}
   73|       |
   74|      0|- (instancetype)initWithApp:(FIRApp *)app {
   75|      0|  return [self initWitAppOptions:app.options appName:app.name];
   76|      0|}
   77|       |
   78|      0|- (instancetype)initWitAppOptions:(FIROptions *)appOptions appName:(NSString *)appName {
   79|      0|  FIRInstallationsIDController *IDController =
   80|      0|      [[FIRInstallationsIDController alloc] initWithGoogleAppID:appOptions.googleAppID
   81|      0|                                                        appName:appName
   82|      0|                                                         APIKey:appOptions.APIKey
   83|      0|                                                      projectID:appOptions.projectID
   84|      0|                                                    GCMSenderID:appOptions.GCMSenderID
   85|      0|                                                    accessGroup:appOptions.appGroupID];
   86|       |
   87|       |  // `prefetchAuthToken` is disabled due to b/156746574.
   88|      0|  return [self initWithAppOptions:appOptions
   89|      0|                          appName:appName
   90|      0|        installationsIDController:IDController
   91|      0|                prefetchAuthToken:NO];
   92|      0|}
   93|       |
   94|       |/// The initializer is supposed to be used by tests to inject `installationsStore`.
   95|       |- (instancetype)initWithAppOptions:(FIROptions *)appOptions
   96|       |                           appName:(NSString *)appName
   97|       |         installationsIDController:(FIRInstallationsIDController *)installationsIDController
   98|      0|                 prefetchAuthToken:(BOOL)prefetchAuthToken {
   99|      0|  self = [super init];
  100|      0|  if (self) {
  101|      0|    [[self class] validateAppOptions:appOptions appName:appName];
  102|      0|    [[self class] assertCompatibleIIDVersion];
  103|       |
  104|      0|    _appOptions = [appOptions copy];
  105|      0|    _appName = [appName copy];
  106|      0|    _installationsIDController = installationsIDController;
  107|       |
  108|       |    // Pre-fetch auth token.
  109|      0|    if (prefetchAuthToken) {
  110|      0|      [self authTokenWithCompletion:^(FIRInstallationsAuthTokenResult *_Nullable tokenResult,
  111|      0|                                      NSError *_Nullable error){
  112|      0|      }];
  113|      0|    }
  114|      0|  }
  115|      0|  return self;
  116|      0|}
  117|       |
  118|      0|+ (void)validateAppOptions:(FIROptions *)appOptions appName:(NSString *)appName {
  119|      0|  NSMutableArray *missingFields = [NSMutableArray array];
  120|      0|  if (appName.length < 1) {
  121|      0|    [missingFields addObject:@"`FirebaseApp.name`"];
  122|      0|  }
  123|      0|  if (appOptions.APIKey.length < 1) {
  124|      0|    [missingFields addObject:@"`FirebaseOptions.APIKey`"];
  125|      0|  }
  126|      0|  if (appOptions.googleAppID.length < 1) {
  127|      0|    [missingFields addObject:@"`FirebaseOptions.googleAppID`"];
  128|      0|  }
  129|       |
  130|      0|  if (appOptions.projectID.length < 1) {
  131|      0|    [missingFields addObject:@"`FirebaseOptions.projectID`"];
  132|      0|  }
  133|       |
  134|      0|  if (missingFields.count > 0) {
  135|      0|    [NSException
  136|      0|         raise:kFirebaseInstallationsErrorDomain
  137|      0|        format:
  138|      0|            @"%@[%@] Could not configure Firebase Installations due to invalid FirebaseApp "
  139|      0|            @"options. The following parameters are nil or empty: %@. If you use "
  140|      0|            @"GoogleServices-Info.plist please download the most recent version from the Firebase "
  141|      0|            @"Console. If you configure Firebase in code, please make sure you specify all "
  142|      0|            @"required parameters.",
  143|      0|            kFIRLoggerInstallations, kFIRInstallationsMessageCodeInvalidFirebaseAppOptions,
  144|      0|            [missingFields componentsJoinedByString:@", "]];
  145|      0|  }
  146|       |
  147|      0|  [self validateAPIKey:appOptions.APIKey];
  148|      0|}
  149|       |
  150|      0|+ (void)validateAPIKey:(nullable NSString *)APIKey {
  151|      0|  NSMutableArray<NSString *> *validationIssues = [[NSMutableArray alloc] init];
  152|       |
  153|      0|  if (APIKey.length != kExpectedAPIKeyLength) {
  154|      0|    [validationIssues addObject:[NSString stringWithFormat:@"API Key length must be %lu characters",
  155|      0|                                                           (unsigned long)kExpectedAPIKeyLength]];
  156|      0|  }
  157|       |
  158|      0|  if (![[APIKey substringToIndex:1] isEqualToString:@"A"]) {
  159|      0|    [validationIssues addObject:@"API Key must start with `A`"];
  160|      0|  }
  161|       |
  162|      0|  NSMutableCharacterSet *allowedCharacters = [NSMutableCharacterSet alphanumericCharacterSet];
  163|      0|  [allowedCharacters
  164|      0|      formUnionWithCharacterSet:[NSCharacterSet characterSetWithCharactersInString:@"-_"]];
  165|       |
  166|      0|  NSCharacterSet *characters = [NSCharacterSet characterSetWithCharactersInString:APIKey];
  167|      0|  if (![allowedCharacters isSupersetOfSet:characters]) {
  168|      0|    [validationIssues addObject:@"API Key must contain only base64 url-safe characters characters"];
  169|      0|  }
  170|       |
  171|      0|  if (validationIssues.count > 0) {
  172|      0|    [NSException
  173|      0|         raise:kFirebaseInstallationsErrorDomain
  174|      0|        format:
  175|      0|            @"%@[%@] Could not configure Firebase Installations due to invalid FirebaseApp "
  176|      0|            @"options. `FirebaseOptions.APIKey` doesn't match the expected format: %@. If you use "
  177|      0|            @"GoogleServices-Info.plist please download the most recent version from the Firebase "
  178|      0|            @"Console. If you configure Firebase in code, please make sure you specify all "
  179|      0|            @"required parameters.",
  180|      0|            kFIRLoggerInstallations, kFIRInstallationsMessageCodeInvalidFirebaseAppOptions,
  181|      0|            [validationIssues componentsJoinedByString:@", "]];
  182|      0|  }
  183|      0|}
  184|       |
  185|       |#pragma mark - Public
  186|       |
  187|      0|+ (FIRInstallations *)installations {
  188|      0|  FIRApp *defaultApp = [FIRApp defaultApp];
  189|      0|  if (!defaultApp) {
  190|      0|    [NSException raise:kFirebaseInstallationsErrorDomain
  191|      0|                format:@"The default FirebaseApp instance must be configured before the default"
  192|      0|                       @"FirebaseApp instance can be initialized. One way to ensure this is to "
  193|      0|                       @"call `FirebaseApp.configure()` in the App  Delegate's "
  194|      0|                       @"`application(_:didFinishLaunchingWithOptions:)` "
  195|      0|                       @"(or the `@main` struct's initializer in SwiftUI)."];
  196|      0|  }
  197|       |
  198|      0|  return [self installationsWithApp:defaultApp];
  199|      0|}
  200|       |
  201|      0|+ (FIRInstallations *)installationsWithApp:(FIRApp *)app {
  202|      0|  id<FIRInstallationsInstanceProvider> installations =
  203|      0|      FIR_COMPONENT(FIRInstallationsInstanceProvider, app.container);
  204|      0|  return (FIRInstallations *)installations;
  205|      0|}
  206|       |
  207|      0|- (void)installationIDWithCompletion:(FIRInstallationsIDHandler)completion {
  208|      0|  [self.installationsIDController getInstallationItem]
  209|      0|      .then(^id(FIRInstallationsItem *installation) {
  210|      0|        completion(installation.firebaseInstallationID, nil);
  211|      0|        return nil;
  212|      0|      })
  213|      0|      .catch(^(NSError *error) {
  214|      0|        completion(nil, [FIRInstallationsErrorUtil publicDomainErrorWithError:error]);
  215|      0|      });
  216|      0|}
  217|       |
  218|      0|- (void)authTokenWithCompletion:(FIRInstallationsTokenHandler)completion {
  219|      0|  [self authTokenForcingRefresh:NO completion:completion];
  220|      0|}
  221|       |
  222|       |- (void)authTokenForcingRefresh:(BOOL)forceRefresh
  223|      0|                     completion:(FIRInstallationsTokenHandler)completion {
  224|      0|  [self.installationsIDController getAuthTokenForcingRefresh:forceRefresh]
  225|      0|      .then(^FIRInstallationsAuthTokenResult *(FIRInstallationsItem *installation) {
  226|      0|        FIRInstallationsAuthTokenResult *result = [[FIRInstallationsAuthTokenResult alloc]
  227|      0|             initWithToken:installation.authToken.token
  228|      0|            expirationDate:installation.authToken.expirationDate];
  229|      0|        return result;
  230|      0|      })
  231|      0|      .then(^id(FIRInstallationsAuthTokenResult *token) {
  232|      0|        completion(token, nil);
  233|      0|        return nil;
  234|      0|      })
  235|      0|      .catch(^void(NSError *error) {
  236|      0|        completion(nil, [FIRInstallationsErrorUtil publicDomainErrorWithError:error]);
  237|      0|      });
  238|      0|}
  239|       |
  240|      0|- (void)deleteWithCompletion:(void (^)(NSError *__nullable error))completion {
  241|      0|  [self.installationsIDController deleteInstallation]
  242|      0|      .then(^id(id result) {
  243|      0|        completion(nil);
  244|      0|        return nil;
  245|      0|      })
  246|      0|      .catch(^void(NSError *error) {
  247|      0|        completion([FIRInstallationsErrorUtil publicDomainErrorWithError:error]);
  248|      0|      });
  249|      0|}
  250|       |
  251|       |#pragma mark - IID version compatibility
  252|       |
  253|      0|+ (void)assertCompatibleIIDVersion {
  254|       |  // We use this flag to disable IID compatibility exception for unit tests.
  255|       |#ifdef FIR_INSTALLATIONS_ALLOWS_INCOMPATIBLE_IID_VERSION
  256|       |  return;
  257|       |#else
  258|      0|  if (![self isIIDVersionCompatible]) {
  259|      0|    [NSException
  260|      0|         raise:kFirebaseInstallationsErrorDomain
  261|      0|        format:@"Firebase Instance ID is not compatible with Firebase 8.x+. Please remove the "
  262|      0|               @"dependency from the app. See the documentation at "
  263|      0|               @"https://firebase.google.com/docs/cloud-messaging/ios/"
  264|      0|               @"client#fetching-the-current-registration-token."];
  265|      0|  }
  266|      0|#endif
  267|      0|}
  268|       |
  269|      0|+ (BOOL)isIIDVersionCompatible {
  270|      0|  Class IIDClass = NSClassFromString(@"FIRInstanceID");
  271|      0|  if (IIDClass == nil) {
  272|       |    // It is OK if there is no IID at all.
  273|      0|    return YES;
  274|      0|  }
  275|       |  // We expect a compatible version having the method `+[FIRInstanceID usesFIS]` defined.
  276|      0|  BOOL isCompatibleVersion = [IIDClass respondsToSelector:NSSelectorFromString(@"usesFIS")];
  277|      0|  return isCompatibleVersion;
  278|      0|}
  279|       |
  280|       |@end
  281|       |
  282|       |NS_ASSUME_NONNULL_END

/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/FIRInstallationsAuthTokenResult.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseInstallations/Source/Library/FIRInstallationsAuthTokenResultInternal.h"
   18|       |
   19|       |@implementation FIRInstallationsAuthTokenResult
   20|       |
   21|      0|- (instancetype)initWithToken:(NSString *)token expirationDate:(NSDate *)expirationDate {
   22|      0|  self = [super init];
   23|      0|  if (self) {
   24|      0|    _authToken = [token copy];
   25|      0|    _expirationDate = expirationDate;
   26|      0|  }
   27|      0|  return self;
   28|      0|}
   29|       |
   30|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/FIRInstallationsItem.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseInstallations/Source/Library/FIRInstallationsItem.h"
   18|       |
   19|       |#import "FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStoredAuthToken.h"
   20|       |#import "FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStoredItem.h"
   21|       |
   22|       |#import "FirebaseInstallations/Source/Library/Errors/FIRInstallationsErrorUtil.h"
   23|       |
   24|       |@implementation FIRInstallationsItem
   25|       |
   26|      0|- (instancetype)initWithAppID:(NSString *)appID firebaseAppName:(NSString *)firebaseAppName {
   27|      0|  self = [super init];
   28|      0|  if (self) {
   29|      0|    _appID = [appID copy];
   30|      0|    _firebaseAppName = [firebaseAppName copy];
   31|      0|  }
   32|      0|  return self;
   33|      0|}
   34|       |
   35|      0|- (nonnull id)copyWithZone:(nullable NSZone *)zone {
   36|      0|  FIRInstallationsItem *clone = [[FIRInstallationsItem alloc] initWithAppID:self.appID
   37|      0|                                                            firebaseAppName:self.firebaseAppName];
   38|      0|  clone.firebaseInstallationID = [self.firebaseInstallationID copy];
   39|      0|  clone.refreshToken = [self.refreshToken copy];
   40|      0|  clone.authToken = [self.authToken copy];
   41|      0|  clone.registrationStatus = self.registrationStatus;
   42|      0|  clone.IIDDefaultToken = [self.IIDDefaultToken copy];
   43|       |
   44|      0|  return clone;
   45|      0|}
   46|       |
   47|      0|- (void)updateWithStoredItem:(FIRInstallationsStoredItem *)item {
   48|      0|  self.firebaseInstallationID = item.firebaseInstallationID;
   49|      0|  self.refreshToken = item.refreshToken;
   50|      0|  self.authToken = item.authToken;
   51|      0|  self.registrationStatus = item.registrationStatus;
   52|      0|  self.IIDDefaultToken = item.IIDDefaultToken;
   53|      0|}
   54|       |
   55|      0|- (FIRInstallationsStoredItem *)storedItem {
   56|      0|  FIRInstallationsStoredItem *storedItem = [[FIRInstallationsStoredItem alloc] init];
   57|      0|  storedItem.firebaseInstallationID = self.firebaseInstallationID;
   58|      0|  storedItem.refreshToken = self.refreshToken;
   59|      0|  storedItem.authToken = self.authToken;
   60|      0|  storedItem.registrationStatus = self.registrationStatus;
   61|      0|  storedItem.IIDDefaultToken = self.IIDDefaultToken;
   62|      0|  return storedItem;
   63|      0|}
   64|       |
   65|      0|- (nonnull NSString *)identifier {
   66|      0|  return [[self class] identifierWithAppID:self.appID appName:self.firebaseAppName];
   67|      0|}
   68|       |
   69|      0|- (BOOL)isValid:(NSError *_Nullable *)outError {
   70|      0|  NSMutableArray<NSString *> *validationIssues = [NSMutableArray array];
   71|       |
   72|      0|  if (self.appID.length == 0) {
   73|      0|    [validationIssues addObject:@"`appID` must not be empty"];
   74|      0|  }
   75|       |
   76|      0|  if (self.firebaseAppName.length == 0) {
   77|      0|    [validationIssues addObject:@"`firebaseAppName` must not be empty"];
   78|      0|  }
   79|       |
   80|      0|  if (self.firebaseInstallationID.length == 0) {
   81|      0|    [validationIssues addObject:@"`firebaseInstallationID` must not be empty"];
   82|      0|  }
   83|       |
   84|      0|  switch (self.registrationStatus) {
   85|      0|    case FIRInstallationStatusUnknown:
   86|      0|      [validationIssues addObject:@"invalid `registrationStatus`"];
   87|      0|      break;
   88|       |
   89|      0|    case FIRInstallationStatusRegistered:
   90|      0|      if (self.refreshToken == 0) {
   91|      0|        [validationIssues addObject:@"registered installation must have non-empty `refreshToken`"];
   92|      0|      }
   93|       |
   94|      0|      if (self.authToken.token == 0) {
   95|      0|        [validationIssues
   96|      0|            addObject:@"registered installation must have non-empty `authToken.token`"];
   97|      0|      }
   98|       |
   99|      0|      if (self.authToken.expirationDate == nil) {
  100|      0|        [validationIssues
  101|      0|            addObject:@"registered installation must have non-empty `authToken.expirationDate`"];
  102|      0|      }
  103|       |
  104|      0|    case FIRInstallationStatusUnregistered:
  105|      0|      break;
  106|      0|  }
  107|       |
  108|      0|  BOOL isValid = validationIssues.count == 0;
  109|       |
  110|      0|  if (!isValid && outError) {
  111|      0|    NSString *failureReason =
  112|      0|        [NSString stringWithFormat:@"FIRInstallationsItem validation errors: %@",
  113|      0|                                   [validationIssues componentsJoinedByString:@", "]];
  114|      0|    *outError =
  115|      0|        [FIRInstallationsErrorUtil installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
  116|      0|                                                failureReason:failureReason
  117|      0|                                              underlyingError:nil];
  118|      0|  }
  119|       |
  120|      0|  return isValid;
  121|      0|}
  122|       |
  123|      0|+ (NSString *)identifierWithAppID:(NSString *)appID appName:(NSString *)appName {
  124|      0|  return [appID stringByAppendingString:appName];
  125|      0|}
  126|       |
  127|      0|+ (NSString *)generateFID {
  128|      0|  NSUUID *UUID = [NSUUID UUID];
  129|      0|  uuid_t UUIDBytes;
  130|      0|  [UUID getUUIDBytes:UUIDBytes];
  131|       |
  132|      0|  NSUInteger UUIDLength = sizeof(uuid_t);
  133|      0|  NSData *UUIDData = [NSData dataWithBytes:UUIDBytes length:UUIDLength];
  134|       |
  135|      0|  uint8_t UUIDLast4Bits = UUIDBytes[UUIDLength - 1] & 0b00001111;
  136|       |
  137|       |  // FID first 4 bits must be `0111`. The last 4 UUID bits will be cut later to form a proper FID.
  138|       |  // To keep 16 random bytes we copy these last 4 UUID to the FID 1st byte after `0111` prefix.
  139|      0|  uint8_t FIDPrefix = 0b01110000 | UUIDLast4Bits;
  140|      0|  NSMutableData *FIDData = [NSMutableData dataWithBytes:&FIDPrefix length:1];
  141|       |
  142|      0|  [FIDData appendData:UUIDData];
  143|      0|  NSString *FIDString = [self base64URLEncodedStringWithData:FIDData];
  144|       |
  145|       |  // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5 bytes.
  146|       |  // Our generated ID has 16 bytes UUID + 1 byte prefix which after encoding with base64 will become
  147|       |  // 23 characters plus 1 character for "=" padding.
  148|       |
  149|       |  // Remove the 23rd character that was added because of the extra 4 bits at the
  150|       |  // end of our 17 byte data and the '=' padding.
  151|      0|  return [FIDString substringWithRange:NSMakeRange(0, 22)];
  152|      0|}
  153|       |
  154|      0|+ (NSString *)base64URLEncodedStringWithData:(NSData *)data {
  155|      0|  NSString *string = [data base64EncodedStringWithOptions:0];
  156|      0|  string = [string stringByReplacingOccurrencesOfString:@"/" withString:@"_"];
  157|      0|  string = [string stringByReplacingOccurrencesOfString:@"+" withString:@"-"];
  158|      0|  return string;
  159|      0|}
  160|       |
  161|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/IIDMigration/FIRInstallationsIIDStore.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseInstallations/Source/Library/IIDMigration/FIRInstallationsIIDStore.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |#import <CommonCrypto/CommonDigest.h>
   26|       |#import "FirebaseInstallations/Source/Library/Errors/FIRInstallationsErrorUtil.h"
   27|       |
   28|       |static NSString *const kFIRInstallationsIIDKeyPairPublicTagPrefix =
   29|       |    @"com.google.iid.keypair.public-";
   30|       |static NSString *const kFIRInstallationsIIDKeyPairPrivateTagPrefix =
   31|       |    @"com.google.iid.keypair.private-";
   32|       |static NSString *const kFIRInstallationsIIDCreationTimePlistKey = @"|S|cre";
   33|       |
   34|       |@implementation FIRInstallationsIIDStore
   35|       |
   36|      0|- (FBLPromise<NSString *> *)existingIID {
   37|      0|  return [FBLPromise onQueue:dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
   38|      0|                          do:^id _Nullable {
   39|      0|                            if (![self hasPlistIIDFlag]) {
   40|      0|                              return nil;
   41|      0|                            }
   42|       |
   43|      0|                            NSData *IIDPublicKeyData = [self IIDPublicKeyData];
   44|      0|                            return [self IIDWithPublicKeyData:IIDPublicKeyData];
   45|      0|                          }]
   46|      0|      .validate(^BOOL(NSString *_Nullable IID) {
   47|      0|        return IID.length > 0;
   48|      0|      });
   49|      0|}
   50|       |
   51|      0|- (FBLPromise<NSNull *> *)deleteExistingIID {
   52|      0|  return [FBLPromise onQueue:dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
   53|      0|                          do:^id _Nullable {
   54|      0|                            NSError *error;
   55|      0|                            if (![self deleteIIDFlagFromPlist:&error]) {
   56|      0|                              return error;
   57|      0|                            }
   58|       |
   59|      0|                            if (![self deleteIID:&error]) {
   60|      0|                              return error;
   61|      0|                            }
   62|       |
   63|      0|                            return [NSNull null];
   64|      0|                          }];
   65|      0|}
   66|       |
   67|       |#pragma mark - IID decoding
   68|       |
   69|      0|- (NSString *)IIDWithPublicKeyData:(NSData *)publicKeyData {
   70|      0|  NSData *publicKeySHA1 = [self sha1WithData:publicKeyData];
   71|       |
   72|      0|  const uint8_t *bytes = publicKeySHA1.bytes;
   73|      0|  NSMutableData *identityData = [NSMutableData dataWithData:publicKeySHA1];
   74|       |
   75|      0|  uint8_t b0 = bytes[0];
   76|       |  // Take the first byte and make the initial four 7 by initially making the initial 4 bits 0
   77|       |  // and then adding 0x70 to it.
   78|      0|  b0 = 0x70 + (0xF & b0);
   79|       |  // failsafe should give you back b0 itself
   80|      0|  b0 = (b0 & 0xFF);
   81|      0|  [identityData replaceBytesInRange:NSMakeRange(0, 1) withBytes:&b0];
   82|      0|  NSData *data = [identityData subdataWithRange:NSMakeRange(0, 8 * sizeof(Byte))];
   83|      0|  return [self base64URLEncodedStringWithData:data];
   84|      0|}
   85|       |
   86|       |/** FirebaseInstallations SDK uses the SHA1 hash for backwards compatibility with the legacy
   87|       | * FirebaseInstanceID SDK. The SHA1 hash is used to access Instance IDs stored on the device and not
   88|       | * for any security-relevant process. This is a one-time step that allows migration of old client
   89|       | * identifiers. Cryptographic security is not needed here, so potential hash collisions are not a
   90|       | * problem.
   91|       | */
   92|      0|- (NSData *)sha1WithData:(NSData *)data {
   93|      0|  unsigned char output[CC_SHA1_DIGEST_LENGTH];
   94|      0|  unsigned int length = (unsigned int)[data length];
   95|       |
   96|      0|  CC_SHA1(data.bytes, length, output);
   97|      0|  return [NSData dataWithBytes:output length:CC_SHA1_DIGEST_LENGTH];
   98|      0|}
   99|       |
  100|      0|- (NSString *)base64URLEncodedStringWithData:(NSData *)data {
  101|      0|  NSString *string = [data base64EncodedStringWithOptions:0];
  102|      0|  string = [string stringByReplacingOccurrencesOfString:@"/" withString:@"_"];
  103|      0|  string = [string stringByReplacingOccurrencesOfString:@"+" withString:@"-"];
  104|      0|  string = [string stringByReplacingOccurrencesOfString:@"=" withString:@""];
  105|      0|  return string;
  106|      0|}
  107|       |
  108|       |#pragma mark - Keychain
  109|       |
  110|      0|- (NSData *)IIDPublicKeyData {
  111|      0|  NSString *tag = [self keychainKeyTagWithPrefix:kFIRInstallationsIIDKeyPairPublicTagPrefix];
  112|      0|  NSDictionary *query = [self keyPairQueryWithTag:tag returnData:YES];
  113|       |
  114|      0|  CFTypeRef keyRef = NULL;
  115|      0|  OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, (CFTypeRef *)&keyRef);
  116|       |
  117|      0|  if (status != noErr) {
  118|      0|    if (keyRef) {
  119|      0|      CFRelease(keyRef);
  120|      0|    }
  121|      0|    return nil;
  122|      0|  }
  123|       |
  124|      0|  return (__bridge NSData *)keyRef;
  125|      0|}
  126|       |
  127|      0|- (BOOL)deleteIID:(NSError **)outError {
  128|      0|  if (![self deleteKeychainKeyWithTagPrefix:kFIRInstallationsIIDKeyPairPublicTagPrefix
  129|      0|                                      error:outError]) {
  130|      0|    return NO;
  131|      0|  }
  132|       |
  133|      0|  if (![self deleteKeychainKeyWithTagPrefix:kFIRInstallationsIIDKeyPairPrivateTagPrefix
  134|      0|                                      error:outError]) {
  135|      0|    return NO;
  136|      0|  }
  137|       |
  138|      0|  return YES;
  139|      0|}
  140|       |
  141|      0|- (BOOL)deleteKeychainKeyWithTagPrefix:(NSString *)tagPrefix error:(NSError **)outError {
  142|      0|  NSString *keyTag = [self keychainKeyTagWithPrefix:kFIRInstallationsIIDKeyPairPublicTagPrefix];
  143|      0|  NSDictionary *keyQuery = [self keyPairQueryWithTag:keyTag returnData:NO];
  144|       |
  145|      0|  OSStatus status = SecItemDelete((__bridge CFDictionaryRef)keyQuery);
  146|       |
  147|       |  // When item is not found, it should NOT be considered as an error. The operation should
  148|       |  // continue.
  149|      0|  if (status != noErr && status != errSecItemNotFound) {
  150|      0|    FIRInstallationsItemSetErrorToPointer(
  151|      0|        [FIRInstallationsErrorUtil keychainErrorWithFunction:@"SecItemDelete" status:status],
  152|      0|        outError);
  153|      0|    return NO;
  154|      0|  }
  155|       |
  156|      0|  return YES;
  157|      0|}
  158|       |
  159|      0|- (NSDictionary *)keyPairQueryWithTag:(NSString *)tag returnData:(BOOL)shouldReturnData {
  160|      0|  NSMutableDictionary *query = [NSMutableDictionary dictionary];
  161|      0|  NSData *tagData = [tag dataUsingEncoding:NSUTF8StringEncoding];
  162|       |
  163|      0|  query[(__bridge id)kSecClass] = (__bridge id)kSecClassKey;
  164|      0|  query[(__bridge id)kSecAttrApplicationTag] = tagData;
  165|      0|  query[(__bridge id)kSecAttrKeyType] = (__bridge id)kSecAttrKeyTypeRSA;
  166|      0|  if (shouldReturnData) {
  167|      0|    query[(__bridge id)kSecReturnData] = @(YES);
  168|      0|  }
  169|       |
  170|       |#if TARGET_OS_OSX
  171|       |  if (self.keychainRef) {
  172|       |    query[(__bridge NSString *)kSecMatchSearchList] = @[ (__bridge id)(self.keychainRef) ];
  173|       |  }
  174|       |#endif  // TARGET_OSX
  175|       |
  176|      0|  return query;
  177|      0|}
  178|       |
  179|      0|- (NSString *)keychainKeyTagWithPrefix:(NSString *)prefix {
  180|      0|  NSString *mainAppBundleID = [[NSBundle mainBundle] bundleIdentifier];
  181|      0|  if (mainAppBundleID.length == 0) {
  182|      0|    return nil;
  183|      0|  }
  184|      0|  return [NSString stringWithFormat:@"%@%@", prefix, mainAppBundleID];
  185|      0|}
  186|       |
  187|      0|- (NSString *)mainbundleIdentifier {
  188|      0|  NSString *bundleIdentifier = [[NSBundle mainBundle] bundleIdentifier];
  189|      0|  if (!bundleIdentifier.length) {
  190|      0|    return nil;
  191|      0|  }
  192|      0|  return bundleIdentifier;
  193|      0|}
  194|       |
  195|       |#pragma mark - Plist
  196|       |
  197|      0|- (BOOL)deleteIIDFlagFromPlist:(NSError **)outError {
  198|      0|  NSString *path = [self plistPath];
  199|      0|  if (![[NSFileManager defaultManager] fileExistsAtPath:path]) {
  200|      0|    return YES;
  201|      0|  }
  202|       |
  203|      0|  NSMutableDictionary *plistContent = [[NSMutableDictionary alloc] initWithContentsOfFile:path];
  204|      0|  plistContent[kFIRInstallationsIIDCreationTimePlistKey] = nil;
  205|       |
  206|      0|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, *)) {
  207|      0|    return [plistContent writeToURL:[NSURL fileURLWithPath:path] error:outError];
  208|      0|  }
  209|       |
  210|      0|  return [plistContent writeToFile:path atomically:YES];
  211|      0|}
  212|       |
  213|      0|- (BOOL)hasPlistIIDFlag {
  214|      0|  NSString *path = [self plistPath];
  215|      0|  if (![[NSFileManager defaultManager] fileExistsAtPath:path]) {
  216|      0|    return NO;
  217|      0|  }
  218|       |
  219|      0|  NSDictionary *plistContent = [[NSDictionary alloc] initWithContentsOfFile:path];
  220|      0|  return plistContent[kFIRInstallationsIIDCreationTimePlistKey] != nil;
  221|      0|}
  222|       |
  223|      0|- (NSString *)plistPath {
  224|      0|  NSString *plistNameWithExtension = @"com.google.iid-keypair.plist";
  225|      0|  NSString *_subDirectoryName = @"Google/FirebaseInstanceID";
  226|       |
  227|      0|  NSArray *directoryPaths =
  228|      0|      NSSearchPathForDirectoriesInDomains([self supportedDirectory], NSUserDomainMask, YES);
  229|      0|  NSArray *components = @[ directoryPaths.lastObject, _subDirectoryName, plistNameWithExtension ];
  230|       |
  231|      0|  return [NSString pathWithComponents:components];
  232|      0|}
  233|       |
  234|      0|- (NSSearchPathDirectory)supportedDirectory {
  235|       |#if TARGET_OS_TV
  236|       |  return NSCachesDirectory;
  237|       |#else
  238|      0|  return NSApplicationSupportDirectory;
  239|      0|#endif
  240|      0|}
  241|       |
  242|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/IIDMigration/FIRInstallationsIIDTokenStore.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseInstallations/Source/Library/IIDMigration/FIRInstallationsIIDTokenStore.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |#import <GoogleUtilities/GULKeychainUtils.h>
   26|       |
   27|       |#import "FirebaseInstallations/Source/Library/Errors/FIRInstallationsErrorUtil.h"
   28|       |
   29|       |static NSString *const kFIRInstallationsIIDTokenKeychainId = @"com.google.iid-tokens";
   30|       |
   31|       |@interface FIRInstallationsIIDTokenInfo : NSObject <NSSecureCoding>
   32|       |@property(nonatomic, nullable, copy) NSString *token;
   33|       |@end
   34|       |
   35|       |@implementation FIRInstallationsIIDTokenInfo
   36|       |
   37|      0|+ (BOOL)supportsSecureCoding {
   38|      0|  return YES;
   39|      0|}
   40|       |
   41|      0|- (void)encodeWithCoder:(nonnull NSCoder *)coder {
   42|      0|}
   43|       |
   44|      0|- (nullable instancetype)initWithCoder:(nonnull NSCoder *)coder {
   45|      0|  self = [super init];
   46|      0|  if (self) {
   47|      0|    _token = [coder decodeObjectOfClass:[NSString class] forKey:@"token"];
   48|      0|  }
   49|      0|  return self;
   50|      0|}
   51|       |
   52|       |@end
   53|       |
   54|       |@interface FIRInstallationsIIDTokenStore ()
   55|       |@property(nonatomic, readonly) NSString *GCMSenderID;
   56|       |@end
   57|       |
   58|       |@implementation FIRInstallationsIIDTokenStore
   59|       |
   60|      0|- (instancetype)initWithGCMSenderID:(NSString *)GCMSenderID {
   61|      0|  self = [super init];
   62|      0|  if (self) {
   63|      0|    _GCMSenderID = GCMSenderID;
   64|      0|  }
   65|      0|  return self;
   66|      0|}
   67|       |
   68|      0|- (FBLPromise<NSString *> *)existingIIDDefaultToken {
   69|      0|  return [[FBLPromise onQueue:dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
   70|      0|                           do:^id _Nullable {
   71|      0|                             return [self IIDDefaultTokenData];
   72|      0|                           }] onQueue:dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
   73|      0|                                 then:^id _Nullable(NSData *_Nullable keychainData) {
   74|      0|                                   return [self IIDCheckinWithData:keychainData];
   75|      0|                                 }];
   76|      0|}
   77|       |
   78|      0|- (FBLPromise<NSString *> *)IIDCheckinWithData:(NSData *)data {
   79|      0|  FBLPromise<NSString *> *resultPromise = [FBLPromise pendingPromise];
   80|       |
   81|      0|  NSError *archiverError;
   82|      0|  NSKeyedUnarchiver *unarchiver;
   83|      0|  if (@available(iOS 11.0, tvOS 11.0, macOS 10.13, *)) {
   84|      0|    unarchiver = [[NSKeyedUnarchiver alloc] initForReadingFromData:data error:&archiverError];
   85|      0|  } else {
   86|      0|    @try {
   87|      0|#pragma clang diagnostic push
   88|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
   89|      0|      unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
   90|      0|#pragma clang diagnostic pop
   91|      0|    } @catch (NSException *exception) {
   92|      0|      archiverError = [FIRInstallationsErrorUtil keyedArchiverErrorWithException:exception];
   93|      0|    }
   94|      0|  }
   95|       |
   96|      0|  if (!unarchiver) {
   97|      0|    NSError *error = archiverError ?: [FIRInstallationsErrorUtil corruptedIIDTokenData];
   98|      0|    [resultPromise reject:error];
   99|      0|    return resultPromise;
  100|      0|  }
  101|       |
  102|      0|  [unarchiver setClass:[FIRInstallationsIIDTokenInfo class] forClassName:@"FIRInstanceIDTokenInfo"];
  103|      0|  FIRInstallationsIIDTokenInfo *IIDTokenInfo =
  104|      0|      [unarchiver decodeObjectOfClass:[FIRInstallationsIIDTokenInfo class]
  105|      0|                               forKey:NSKeyedArchiveRootObjectKey];
  106|       |
  107|      0|  if (IIDTokenInfo.token.length < 1) {
  108|      0|    [resultPromise reject:[FIRInstallationsErrorUtil corruptedIIDTokenData]];
  109|      0|    return resultPromise;
  110|      0|  }
  111|       |
  112|      0|  [resultPromise fulfill:IIDTokenInfo.token];
  113|       |
  114|      0|  return resultPromise;
  115|      0|}
  116|       |
  117|      0|- (FBLPromise<NSData *> *)IIDDefaultTokenData {
  118|      0|  FBLPromise<NSData *> *resultPromise = [FBLPromise pendingPromise];
  119|       |
  120|      0|  NSMutableDictionary *keychainQuery = [self IIDDefaultTokenDataKeychainQuery];
  121|      0|  NSError *error;
  122|      0|  NSData *data = [GULKeychainUtils getItemWithQuery:keychainQuery error:&error];
  123|       |
  124|      0|  if (data) {
  125|      0|    [resultPromise fulfill:data];
  126|      0|    return resultPromise;
  127|      0|  } else {
  128|      0|    NSError *outError = error ?: [FIRInstallationsErrorUtil corruptedIIDTokenData];
  129|      0|    [resultPromise reject:outError];
  130|      0|    return resultPromise;
  131|      0|  }
  132|      0|}
  133|       |
  134|      0|- (NSMutableDictionary *)IIDDefaultTokenDataKeychainQuery {
  135|      0|  NSDictionary *query = @{(__bridge id)kSecClass : (__bridge id)kSecClassGenericPassword};
  136|       |
  137|      0|  NSMutableDictionary *finalQuery = [NSMutableDictionary dictionaryWithDictionary:query];
  138|      0|  finalQuery[(__bridge NSString *)kSecAttrGeneric] = kFIRInstallationsIIDTokenKeychainId;
  139|       |
  140|      0|  NSString *account = [self IIDAppIdentifier];
  141|      0|  if ([account length]) {
  142|      0|    finalQuery[(__bridge NSString *)kSecAttrAccount] = account;
  143|      0|  }
  144|       |
  145|      0|  finalQuery[(__bridge NSString *)kSecAttrService] =
  146|      0|      [self serviceKeyForAuthorizedEntity:self.GCMSenderID scope:@"*"];
  147|      0|  return finalQuery;
  148|      0|}
  149|       |
  150|      0|- (NSString *)IIDAppIdentifier {
  151|      0|  return [[NSBundle mainBundle] bundleIdentifier] ?: @"";
  152|      0|}
  153|       |
  154|      0|- (NSString *)serviceKeyForAuthorizedEntity:(NSString *)authorizedEntity scope:(NSString *)scope {
  155|      0|  return [NSString stringWithFormat:@"%@:%@", authorizedEntity, scope];
  156|      0|}
  157|       |
  158|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsAPI/FIRInstallationsAPIService.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseInstallations/Source/Library/InstallationsAPI/FIRInstallationsAPIService.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |#import "FirebaseCore/Sources/Private/FirebaseCoreInternal.h"
   26|       |#import "FirebaseInstallations/Source/Library/Errors/FIRInstallationsErrorUtil.h"
   27|       |#import "FirebaseInstallations/Source/Library/Errors/FIRInstallationsHTTPError.h"
   28|       |#import "FirebaseInstallations/Source/Library/FIRInstallationsLogger.h"
   29|       |#import "FirebaseInstallations/Source/Library/InstallationsAPI/FIRInstallationsItem+RegisterInstallationAPI.h"
   30|       |
   31|       |NSString *const kFIRInstallationsAPIBaseURL = @"https://firebaseinstallations.googleapis.com";
   32|       |NSString *const kFIRInstallationsAPIKey = @"X-Goog-Api-Key";
   33|       |NSString *const kFIRInstallationsBundleId = @"X-Ios-Bundle-Identifier";
   34|       |NSString *const kFIRInstallationsIIDMigrationAuthHeader = @"x-goog-fis-ios-iid-migration-auth";
   35|       |NSString *const kFIRInstallationsHeartbeatKey = @"X-firebase-client-log-type";
   36|       |NSString *const kFIRInstallationsHeartbeatTag = @"fire-installations";
   37|       |NSString *const kFIRInstallationsUserAgentKey = @"X-firebase-client";
   38|       |
   39|       |NS_ASSUME_NONNULL_BEGIN
   40|       |
   41|       |@interface FIRInstallationsURLSessionResponse : NSObject
   42|       |@property(nonatomic) NSHTTPURLResponse *HTTPResponse;
   43|       |@property(nonatomic) NSData *data;
   44|       |
   45|       |- (instancetype)initWithResponse:(NSHTTPURLResponse *)response data:(nullable NSData *)data;
   46|       |@end
   47|       |
   48|       |@implementation FIRInstallationsURLSessionResponse
   49|       |
   50|      0|- (instancetype)initWithResponse:(NSHTTPURLResponse *)response data:(nullable NSData *)data {
   51|      0|  self = [super init];
   52|      0|  if (self) {
   53|      0|    _HTTPResponse = response;
   54|      0|    _data = data ?: [NSData data];
   55|      0|  }
   56|      0|  return self;
   57|      0|}
   58|       |
   59|       |@end
   60|       |
   61|       |@interface FIRInstallationsAPIService ()
   62|       |@property(nonatomic, readonly) NSURLSession *URLSession;
   63|       |@property(nonatomic, readonly) NSString *APIKey;
   64|       |@property(nonatomic, readonly) NSString *projectID;
   65|       |@end
   66|       |
   67|       |NS_ASSUME_NONNULL_END
   68|       |
   69|       |@implementation FIRInstallationsAPIService
   70|       |
   71|      0|- (instancetype)initWithAPIKey:(NSString *)APIKey projectID:(NSString *)projectID {
   72|      0|  NSURLSession *URLSession = [NSURLSession
   73|      0|      sessionWithConfiguration:[NSURLSessionConfiguration ephemeralSessionConfiguration]];
   74|      0|  return [self initWithURLSession:URLSession APIKey:APIKey projectID:projectID];
   75|      0|}
   76|       |
   77|       |/// The initializer for tests.
   78|       |- (instancetype)initWithURLSession:(NSURLSession *)URLSession
   79|       |                            APIKey:(NSString *)APIKey
   80|      0|                         projectID:(NSString *)projectID {
   81|      0|  self = [super init];
   82|      0|  if (self) {
   83|      0|    _URLSession = URLSession;
   84|      0|    _APIKey = [APIKey copy];
   85|      0|    _projectID = [projectID copy];
   86|      0|  }
   87|      0|  return self;
   88|      0|}
   89|       |
   90|       |#pragma mark - Public
   91|       |
   92|      0|- (FBLPromise<FIRInstallationsItem *> *)registerInstallation:(FIRInstallationsItem *)installation {
   93|      0|  return [self validateInstallation:installation]
   94|      0|      .then(^id _Nullable(FIRInstallationsItem *_Nullable validInstallation) {
   95|      0|        return [self registerRequestWithInstallation:validInstallation];
   96|      0|      })
   97|      0|      .then(^id _Nullable(NSURLRequest *_Nullable request) {
   98|      0|        return [self sendURLRequest:request];
   99|      0|      })
  100|      0|      .then(^id _Nullable(FIRInstallationsURLSessionResponse *response) {
  101|      0|        return [self registeredInstallationWithInstallation:installation serverResponse:response];
  102|      0|      });
  103|      0|}
  104|       |
  105|       |- (FBLPromise<FIRInstallationsItem *> *)refreshAuthTokenForInstallation:
  106|      0|    (FIRInstallationsItem *)installation {
  107|      0|  return [self authTokenRequestWithInstallation:installation]
  108|      0|      .then(^id _Nullable(NSURLRequest *_Nullable request) {
  109|      0|        return [self sendURLRequest:request];
  110|      0|      })
  111|      0|      .then(^FBLPromise<FIRInstallationsStoredAuthToken *> *(
  112|      0|          FIRInstallationsURLSessionResponse *response) {
  113|      0|        return [self authTokenWithServerResponse:response];
  114|      0|      })
  115|      0|      .then(^FIRInstallationsItem *(FIRInstallationsStoredAuthToken *authToken) {
  116|      0|        FIRInstallationsItem *updatedInstallation = [installation copy];
  117|      0|        updatedInstallation.authToken = authToken;
  118|      0|        return updatedInstallation;
  119|      0|      });
  120|      0|}
  121|       |
  122|      0|- (FBLPromise<FIRInstallationsItem *> *)deleteInstallation:(FIRInstallationsItem *)installation {
  123|      0|  return [self deleteInstallationRequestWithInstallation:installation]
  124|      0|      .then(^id _Nullable(NSURLRequest *_Nullable request) {
  125|      0|        return [self sendURLRequest:request];
  126|      0|      })
  127|      0|      .then(^id _Nullable(FIRInstallationsURLSessionResponse *_Nullable value) {
  128|       |        // Return the original installation on success.
  129|      0|        return installation;
  130|      0|      });
  131|      0|}
  132|       |
  133|       |#pragma mark - Register Installation
  134|       |
  135|       |- (FBLPromise<NSURLRequest *> *)registerRequestWithInstallation:
  136|      0|    (FIRInstallationsItem *)installation {
  137|      0|  NSString *URLString = [NSString stringWithFormat:@"%@/v1/projects/%@/installations/",
  138|      0|                                                   kFIRInstallationsAPIBaseURL, self.projectID];
  139|      0|  NSURL *URL = [NSURL URLWithString:URLString];
  140|       |
  141|      0|  NSDictionary *bodyDict = @{
  142|       |    // `firebaseInstallationID` is validated before but let's make sure it is not `nil` one more
  143|       |    // time to prevent a crash.
  144|      0|    @"fid" : installation.firebaseInstallationID ?: @"",
  145|      0|    @"authVersion" : @"FIS_v2",
  146|      0|    @"appId" : installation.appID,
  147|      0|    @"sdkVersion" : [self SDKVersion]
  148|      0|  };
  149|       |
  150|      0|  NSDictionary *headers;
  151|      0|  if (installation.IIDDefaultToken) {
  152|      0|    headers = @{kFIRInstallationsIIDMigrationAuthHeader : installation.IIDDefaultToken};
  153|      0|  }
  154|       |
  155|      0|  return [self requestWithURL:URL
  156|      0|                   HTTPMethod:@"POST"
  157|      0|                     bodyDict:bodyDict
  158|      0|                 refreshToken:nil
  159|      0|            additionalHeaders:headers];
  160|      0|}
  161|       |
  162|       |- (FBLPromise<FIRInstallationsItem *> *)
  163|       |    registeredInstallationWithInstallation:(FIRInstallationsItem *)installation
  164|      0|                            serverResponse:(FIRInstallationsURLSessionResponse *)response {
  165|      0|  return [FBLPromise do:^id {
  166|      0|    FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeParsingAPIResponse,
  167|      0|                @"Parsing server response for %@.", response.HTTPResponse.URL);
  168|      0|    NSError *error;
  169|      0|    FIRInstallationsItem *registeredInstallation =
  170|      0|        [installation registeredInstallationWithJSONData:response.data
  171|      0|                                                    date:[NSDate date]
  172|      0|                                                   error:&error];
  173|      0|    if (registeredInstallation == nil) {
  174|      0|      FIRLogDebug(kFIRLoggerInstallations,
  175|      0|                  kFIRInstallationsMessageCodeAPIResponseParsingInstallationFailed,
  176|      0|                  @"Failed to parse FIRInstallationsItem: %@.", error);
  177|      0|      return error;
  178|      0|    }
  179|       |
  180|      0|    FIRLogDebug(kFIRLoggerInstallations,
  181|      0|                kFIRInstallationsMessageCodeAPIResponseParsingInstallationSucceed,
  182|      0|                @"FIRInstallationsItem parsed successfully.");
  183|      0|    return registeredInstallation;
  184|      0|  }];
  185|      0|}
  186|       |
  187|       |#pragma mark - Auth token
  188|       |
  189|       |- (FBLPromise<NSURLRequest *> *)authTokenRequestWithInstallation:
  190|      0|    (FIRInstallationsItem *)installation {
  191|      0|  NSString *URLString =
  192|      0|      [NSString stringWithFormat:@"%@/v1/projects/%@/installations/%@/authTokens:generate",
  193|      0|                                 kFIRInstallationsAPIBaseURL, self.projectID,
  194|      0|                                 installation.firebaseInstallationID];
  195|      0|  NSURL *URL = [NSURL URLWithString:URLString];
  196|       |
  197|      0|  NSDictionary *bodyDict = @{@"installation" : @{@"sdkVersion" : [self SDKVersion]}};
  198|      0|  return [self requestWithURL:URL
  199|      0|                   HTTPMethod:@"POST"
  200|      0|                     bodyDict:bodyDict
  201|      0|                 refreshToken:installation.refreshToken];
  202|      0|}
  203|       |
  204|       |- (FBLPromise<FIRInstallationsStoredAuthToken *> *)authTokenWithServerResponse:
  205|      0|    (FIRInstallationsURLSessionResponse *)response {
  206|      0|  return [FBLPromise do:^id {
  207|      0|    FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeParsingAPIResponse,
  208|      0|                @"Parsing server response for %@.", response.HTTPResponse.URL);
  209|      0|    NSError *error;
  210|      0|    FIRInstallationsStoredAuthToken *token =
  211|      0|        [FIRInstallationsItem authTokenWithGenerateTokenAPIJSONData:response.data
  212|      0|                                                               date:[NSDate date]
  213|      0|                                                              error:&error];
  214|      0|    if (token == nil) {
  215|      0|      FIRLogDebug(kFIRLoggerInstallations,
  216|      0|                  kFIRInstallationsMessageCodeAPIResponseParsingAuthTokenFailed,
  217|      0|                  @"Failed to parse FIRInstallationsStoredAuthToken: %@.", error);
  218|      0|      return error;
  219|      0|    }
  220|       |
  221|      0|    FIRLogDebug(kFIRLoggerInstallations,
  222|      0|                kFIRInstallationsMessageCodeAPIResponseParsingAuthTokenSucceed,
  223|      0|                @"FIRInstallationsStoredAuthToken parsed successfully.");
  224|      0|    return token;
  225|      0|  }];
  226|      0|}
  227|       |
  228|       |#pragma mark - Delete Installation
  229|       |
  230|       |- (FBLPromise<NSURLRequest *> *)deleteInstallationRequestWithInstallation:
  231|      0|    (FIRInstallationsItem *)installation {
  232|      0|  NSString *URLString = [NSString stringWithFormat:@"%@/v1/projects/%@/installations/%@/",
  233|      0|                                                   kFIRInstallationsAPIBaseURL, self.projectID,
  234|      0|                                                   installation.firebaseInstallationID];
  235|      0|  NSURL *URL = [NSURL URLWithString:URLString];
  236|       |
  237|      0|  return [self requestWithURL:URL
  238|      0|                   HTTPMethod:@"DELETE"
  239|      0|                     bodyDict:@{}
  240|      0|                 refreshToken:installation.refreshToken];
  241|      0|}
  242|       |
  243|       |#pragma mark - URL Request
  244|       |- (FBLPromise<NSURLRequest *> *)requestWithURL:(NSURL *)requestURL
  245|       |                                    HTTPMethod:(NSString *)HTTPMethod
  246|       |                                      bodyDict:(NSDictionary *)bodyDict
  247|      0|                                  refreshToken:(nullable NSString *)refreshToken {
  248|      0|  return [self requestWithURL:requestURL
  249|      0|                   HTTPMethod:HTTPMethod
  250|      0|                     bodyDict:bodyDict
  251|      0|                 refreshToken:refreshToken
  252|      0|            additionalHeaders:nil];
  253|      0|}
  254|       |
  255|       |- (FBLPromise<NSURLRequest *> *)requestWithURL:(NSURL *)requestURL
  256|       |                                    HTTPMethod:(NSString *)HTTPMethod
  257|       |                                      bodyDict:(NSDictionary *)bodyDict
  258|       |                                  refreshToken:(nullable NSString *)refreshToken
  259|       |                             additionalHeaders:(nullable NSDictionary<NSString *, NSString *> *)
  260|      0|                                                   additionalHeaders {
  261|      0|  return [FBLPromise
  262|      0|      onQueue:dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
  263|      0|           do:^id _Nullable {
  264|      0|             __block NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:requestURL];
  265|      0|             request.HTTPMethod = HTTPMethod;
  266|      0|             NSString *bundleIdentifier = [[NSBundle mainBundle] bundleIdentifier];
  267|      0|             [request addValue:self.APIKey forHTTPHeaderField:kFIRInstallationsAPIKey];
  268|      0|             [request addValue:bundleIdentifier forHTTPHeaderField:kFIRInstallationsBundleId];
  269|      0|             [self setJSONHTTPBody:bodyDict forRequest:request];
  270|      0|             if (refreshToken) {
  271|      0|               NSString *authHeader = [NSString stringWithFormat:@"FIS_v2 %@", refreshToken];
  272|      0|               [request setValue:authHeader forHTTPHeaderField:@"Authorization"];
  273|      0|             }
  274|       |             // User agent Header.
  275|      0|             [request setValue:[FIRApp firebaseUserAgent]
  276|      0|                 forHTTPHeaderField:kFIRInstallationsUserAgentKey];
  277|       |             // Heartbeat Header.
  278|      0|             [request setValue:@([FIRHeartbeatInfo
  279|      0|                                     heartbeatCodeForTag:kFIRInstallationsHeartbeatTag])
  280|      0|                                   .stringValue
  281|      0|                 forHTTPHeaderField:kFIRInstallationsHeartbeatKey];
  282|      0|             [additionalHeaders
  283|      0|                 enumerateKeysAndObjectsUsingBlock:^(NSString *_Nonnull key, NSString *_Nonnull obj,
  284|      0|                                                     BOOL *_Nonnull stop) {
  285|      0|                   [request setValue:obj forHTTPHeaderField:key];
  286|      0|                 }];
  287|       |
  288|      0|             return [request copy];
  289|      0|           }];
  290|      0|}
  291|       |
  292|      0|- (FBLPromise<FIRInstallationsURLSessionResponse *> *)URLRequestPromise:(NSURLRequest *)request {
  293|      0|  return [[FBLPromise async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) {
  294|      0|    FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeSendAPIRequest,
  295|      0|                @"Sending request: %@, body:%@, headers: %@.", request,
  296|      0|                [[NSString alloc] initWithData:request.HTTPBody encoding:NSUTF8StringEncoding],
  297|      0|                request.allHTTPHeaderFields);
  298|      0|    [[self.URLSession
  299|      0|        dataTaskWithRequest:request
  300|      0|          completionHandler:^(NSData *_Nullable data, NSURLResponse *_Nullable response,
  301|      0|                              NSError *_Nullable error) {
  302|      0|            if (error) {
  303|      0|              FIRLogDebug(kFIRLoggerInstallations,
  304|      0|                          kFIRInstallationsMessageCodeAPIRequestNetworkError,
  305|      0|                          @"Request failed: %@, error: %@.", request, error);
  306|      0|              reject(error);
  307|      0|            } else {
  308|      0|              FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeAPIRequestResponse,
  309|      0|                          @"Request response received: %@, error: %@, body: %@.", request, error,
  310|      0|                          [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);
  311|      0|              fulfill([[FIRInstallationsURLSessionResponse alloc]
  312|      0|                  initWithResponse:(NSHTTPURLResponse *)response
  313|      0|                              data:data]);
  314|      0|            }
  315|      0|          }] resume];
  316|      0|  }] then:^id _Nullable(FIRInstallationsURLSessionResponse *response) {
  317|      0|    return [self validateHTTPResponseStatusCode:response];
  318|      0|  }];
  319|      0|}
  320|       |
  321|       |- (FBLPromise<FIRInstallationsURLSessionResponse *> *)validateHTTPResponseStatusCode:
  322|      0|    (FIRInstallationsURLSessionResponse *)response {
  323|      0|  NSInteger statusCode = response.HTTPResponse.statusCode;
  324|      0|  return [FBLPromise do:^id _Nullable {
  325|      0|    if (statusCode < 200 || statusCode >= 300) {
  326|      0|      FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeUnexpectedAPIRequestResponse,
  327|      0|                  @"Unexpected API response: %@, body: %@.", response.HTTPResponse,
  328|      0|                  [[NSString alloc] initWithData:response.data encoding:NSUTF8StringEncoding]);
  329|      0|      return [FIRInstallationsErrorUtil APIErrorWithHTTPResponse:response.HTTPResponse
  330|      0|                                                            data:response.data];
  331|      0|    }
  332|      0|    return response;
  333|      0|  }];
  334|      0|}
  335|       |
  336|      0|- (FBLPromise<FIRInstallationsURLSessionResponse *> *)sendURLRequest:(NSURLRequest *)request {
  337|      0|  return [FBLPromise attempts:1
  338|      0|      delay:1
  339|      0|      condition:^BOOL(NSInteger remainingAttempts, NSError *_Nonnull error) {
  340|      0|        return [FIRInstallationsErrorUtil isAPIError:error
  341|      0|                                        withHTTPCode:FIRInstallationsHTTPCodesServerInternalError];
  342|      0|      }
  343|      0|      retry:^id _Nullable {
  344|      0|        return [self URLRequestPromise:request];
  345|      0|      }];
  346|      0|}
  347|       |
  348|      0|- (NSString *)SDKVersion {
  349|      0|  return [NSString stringWithFormat:@"i:%@", FIRFirebaseVersion()];
  350|      0|}
  351|       |
  352|       |#pragma mark - Validation
  353|       |
  354|      0|- (FBLPromise<FIRInstallationsItem *> *)validateInstallation:(FIRInstallationsItem *)installation {
  355|      0|  FBLPromise<FIRInstallationsItem *> *result = [FBLPromise pendingPromise];
  356|       |
  357|      0|  NSError *validationError;
  358|      0|  if ([installation isValid:&validationError]) {
  359|      0|    [result fulfill:installation];
  360|      0|  } else {
  361|      0|    [result reject:validationError];
  362|      0|  }
  363|      0|  return result;
  364|      0|}
  365|       |
  366|       |#pragma mark - JSON
  367|       |
  368|       |- (void)setJSONHTTPBody:(NSDictionary<NSString *, id> *)body
  369|      0|             forRequest:(NSMutableURLRequest *)request {
  370|      0|  [request setValue:@"application/json" forHTTPHeaderField:@"Content-Type"];
  371|       |
  372|      0|  NSError *error;
  373|      0|  NSData *JSONData = [NSJSONSerialization dataWithJSONObject:body options:0 error:&error];
  374|      0|  if (JSONData == nil) {
  375|       |    // TODO: Log or return an error.
  376|      0|  }
  377|      0|  request.HTTPBody = JSONData;
  378|      0|}
  379|       |
  380|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsAPI/FIRInstallationsItem+RegisterInstallationAPI.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseInstallations/Source/Library/InstallationsAPI/FIRInstallationsItem+RegisterInstallationAPI.h"
   18|       |
   19|       |#import "FirebaseInstallations/Source/Library/Errors/FIRInstallationsErrorUtil.h"
   20|       |#import "FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStoredAuthToken.h"
   21|       |
   22|       |@implementation FIRInstallationsItem (RegisterInstallationAPI)
   23|       |
   24|       |- (nullable FIRInstallationsItem *)
   25|       |    registeredInstallationWithJSONData:(NSData *)data
   26|       |                                  date:(NSDate *)date
   27|      0|                                 error:(NSError *__autoreleasing _Nullable *_Nullable)outError {
   28|      0|  NSDictionary *responseJSON = [FIRInstallationsItem dictionaryFromJSONData:data error:outError];
   29|      0|  if (!responseJSON) {
   30|      0|    return nil;
   31|      0|  }
   32|       |
   33|      0|  NSString *refreshToken = [FIRInstallationsItem validStringOrNilForKey:@"refreshToken"
   34|      0|                                                               fromDict:responseJSON];
   35|      0|  if (refreshToken == nil) {
   36|      0|    FIRInstallationsItemSetErrorToPointer(
   37|      0|        [FIRInstallationsErrorUtil FIDRegistrationErrorWithResponseMissingField:@"refreshToken"],
   38|      0|        outError);
   39|      0|    return nil;
   40|      0|  }
   41|       |
   42|      0|  NSDictionary *authTokenDict = responseJSON[@"authToken"];
   43|      0|  if (![authTokenDict isKindOfClass:[NSDictionary class]]) {
   44|      0|    FIRInstallationsItemSetErrorToPointer(
   45|      0|        [FIRInstallationsErrorUtil FIDRegistrationErrorWithResponseMissingField:@"authToken"],
   46|      0|        outError);
   47|      0|    return nil;
   48|      0|  }
   49|       |
   50|      0|  FIRInstallationsStoredAuthToken *authToken =
   51|      0|      [FIRInstallationsItem authTokenWithJSONDict:authTokenDict date:date error:outError];
   52|      0|  if (authToken == nil) {
   53|      0|    return nil;
   54|      0|  }
   55|       |
   56|      0|  FIRInstallationsItem *installation =
   57|      0|      [[FIRInstallationsItem alloc] initWithAppID:self.appID firebaseAppName:self.firebaseAppName];
   58|      0|  NSString *installationID = [FIRInstallationsItem validStringOrNilForKey:@"fid"
   59|      0|                                                                 fromDict:responseJSON];
   60|      0|  installation.firebaseInstallationID = installationID ?: self.firebaseInstallationID;
   61|      0|  installation.refreshToken = refreshToken;
   62|      0|  installation.authToken = authToken;
   63|      0|  installation.registrationStatus = FIRInstallationStatusRegistered;
   64|       |
   65|      0|  return installation;
   66|      0|}
   67|       |
   68|       |#pragma mark - Auth token
   69|       |
   70|       |+ (nullable FIRInstallationsStoredAuthToken *)authTokenWithGenerateTokenAPIJSONData:(NSData *)data
   71|       |                                                                               date:(NSDate *)date
   72|       |                                                                              error:(NSError **)
   73|      0|                                                                                        outError {
   74|      0|  NSDictionary *dict = [self dictionaryFromJSONData:data error:outError];
   75|      0|  if (!dict) {
   76|      0|    return nil;
   77|      0|  }
   78|       |
   79|      0|  return [self authTokenWithJSONDict:dict date:date error:outError];
   80|      0|}
   81|       |
   82|       |+ (nullable FIRInstallationsStoredAuthToken *)authTokenWithJSONDict:
   83|       |                                                  (NSDictionary<NSString *, id> *)dict
   84|       |                                                               date:(NSDate *)date
   85|      0|                                                              error:(NSError **)outError {
   86|      0|  NSString *token = [self validStringOrNilForKey:@"token" fromDict:dict];
   87|      0|  if (token == nil) {
   88|      0|    FIRInstallationsItemSetErrorToPointer(
   89|      0|        [FIRInstallationsErrorUtil FIDRegistrationErrorWithResponseMissingField:@"authToken.token"],
   90|      0|        outError);
   91|      0|    return nil;
   92|      0|  }
   93|       |
   94|      0|  NSString *expiresInString = [self validStringOrNilForKey:@"expiresIn" fromDict:dict];
   95|      0|  if (expiresInString == nil) {
   96|      0|    FIRInstallationsItemSetErrorToPointer(
   97|      0|        [FIRInstallationsErrorUtil
   98|      0|            FIDRegistrationErrorWithResponseMissingField:@"authToken.expiresIn"],
   99|      0|        outError);
  100|      0|    return nil;
  101|      0|  }
  102|       |
  103|       |  // The response should contain the string in format like "604800s".
  104|       |  // The server should never response with anything else except seconds.
  105|       |  // Just drop the last character and parse a number from string.
  106|      0|  NSString *expiresInSeconds = [expiresInString substringToIndex:expiresInString.length - 1];
  107|      0|  NSTimeInterval expiresIn = [expiresInSeconds doubleValue];
  108|      0|  NSDate *expirationDate = [date dateByAddingTimeInterval:expiresIn];
  109|       |
  110|      0|  FIRInstallationsStoredAuthToken *authToken = [[FIRInstallationsStoredAuthToken alloc] init];
  111|      0|  authToken.status = FIRInstallationsAuthTokenStatusTokenReceived;
  112|      0|  authToken.token = token;
  113|      0|  authToken.expirationDate = expirationDate;
  114|       |
  115|      0|  return authToken;
  116|      0|}
  117|       |
  118|       |#pragma mark - JSON
  119|       |
  120|       |+ (nullable NSDictionary<NSString *, id> *)dictionaryFromJSONData:(NSData *)data
  121|      0|                                                            error:(NSError **)outError {
  122|      0|  NSError *error;
  123|      0|  NSDictionary *responseJSON = [NSJSONSerialization JSONObjectWithData:data options:0 error:&error];
  124|       |
  125|      0|  if (![responseJSON isKindOfClass:[NSDictionary class]]) {
  126|      0|    FIRInstallationsItemSetErrorToPointer([FIRInstallationsErrorUtil JSONSerializationError:error],
  127|      0|                                          outError);
  128|      0|    return nil;
  129|      0|  }
  130|       |
  131|      0|  return responseJSON;
  132|      0|}
  133|       |
  134|      0|+ (NSString *)validStringOrNilForKey:(NSString *)key fromDict:(NSDictionary *)dict {
  135|      0|  NSString *string = dict[key];
  136|      0|  if ([string isKindOfClass:[NSString class]] && string.length > 0) {
  137|      0|    return string;
  138|      0|  }
  139|      0|  return nil;
  140|      0|}
  141|       |
  142|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsIDController/FIRCurrentDateProvider.m:
    1|       |/*
    2|       | * Copyright 2020 Google LLC
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseInstallations/Source/Library/InstallationsIDController/FIRCurrentDateProvider.h"
   18|       |
   19|      0|FIRCurrentDateProvider FIRRealCurrentDateProvider(void) {
   20|      0|  return ^NSDate *(void) {
   21|      0|    return [NSDate date];
   22|      0|  };
   23|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsIDController/FIRInstallationsBackoffController.m:
    1|       |/*
    2|       | * Copyright 2020 Google LLC
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseInstallations/Source/Library/InstallationsIDController/FIRInstallationsBackoffController.h"
   18|       |
   19|       |static const NSTimeInterval k24Hours = 24 * 60 * 60;
   20|       |static const NSTimeInterval k30Minutes = 30 * 60;
   21|       |
   22|       |/** The class represents `FIRInstallationsBackoffController` sate required to calculate next allowed
   23|       | request time. The properties of the class are intentionally immutable because changing them
   24|       | separately leads to an inconsistent state. */
   25|       |@interface FIRInstallationsBackoffEventData : NSObject
   26|       |
   27|       |@property(nonatomic, readonly) FIRInstallationsBackoffEvent eventType;
   28|       |@property(nonatomic, readonly) NSDate *lastEventDate;
   29|       |@property(nonatomic, readonly) NSInteger eventCount;
   30|       |
   31|       |@property(nonatomic, readonly) NSTimeInterval backoffTimeInterval;
   32|       |
   33|       |@end
   34|       |
   35|       |@implementation FIRInstallationsBackoffEventData
   36|       |
   37|       |- (instancetype)initWithEvent:(FIRInstallationsBackoffEvent)eventType
   38|       |                lastEventDate:(NSDate *)lastEventDate
   39|      0|                   eventCount:(NSInteger)eventCount {
   40|      0|  self = [super init];
   41|      0|  if (self) {
   42|      0|    _eventType = eventType;
   43|      0|    _lastEventDate = lastEventDate;
   44|      0|    _eventCount = eventCount;
   45|       |
   46|      0|    _backoffTimeInterval = [[self class] backoffTimeIntervalWithEvent:eventType
   47|      0|                                                           eventCount:eventCount];
   48|      0|  }
   49|      0|  return self;
   50|      0|}
   51|       |
   52|       |+ (NSTimeInterval)backoffTimeIntervalWithEvent:(FIRInstallationsBackoffEvent)eventType
   53|      0|                                    eventCount:(NSInteger)eventCount {
   54|      0|  switch (eventType) {
   55|      0|    case FIRInstallationsBackoffEventSuccess:
   56|      0|      return 0;
   57|      0|      break;
   58|       |
   59|      0|    case FIRInstallationsBackoffEventRecoverableFailure:
   60|      0|      return [self recoverableErrorBackoffTimeForAttemptNumber:eventCount];
   61|      0|      break;
   62|       |
   63|      0|    case FIRInstallationsBackoffEventUnrecoverableFailure:
   64|      0|      return k24Hours;
   65|      0|      break;
   66|      0|  }
   67|      0|}
   68|       |
   69|      0|+ (NSTimeInterval)recoverableErrorBackoffTimeForAttemptNumber:(NSInteger)attemptNumber {
   70|      0|  NSTimeInterval exponentialInterval = pow(2, attemptNumber) + [self randomMilliseconds];
   71|      0|  return MIN(exponentialInterval, k30Minutes);
   72|      0|}
   73|       |
   74|      0|+ (NSTimeInterval)randomMilliseconds {
   75|      0|  int32_t random_millis = ABS(arc4random() % 1000);
   76|      0|  return (double)random_millis * 0.001;
   77|      0|}
   78|       |
   79|       |@end
   80|       |
   81|       |@interface FIRInstallationsBackoffController ()
   82|       |
   83|       |@property(nonatomic, readonly) FIRCurrentDateProvider currentDateProvider;
   84|       |
   85|       |@property(nonatomic, nullable) FIRInstallationsBackoffEventData *lastEventData;
   86|       |
   87|       |@end
   88|       |
   89|       |@implementation FIRInstallationsBackoffController
   90|       |
   91|      0|- (instancetype)init {
   92|      0|  return [self initWithCurrentDateProvider:FIRRealCurrentDateProvider()];
   93|      0|}
   94|       |
   95|      0|- (instancetype)initWithCurrentDateProvider:(FIRCurrentDateProvider)currentDateProvider {
   96|      0|  self = [super init];
   97|      0|  if (self) {
   98|      0|    _currentDateProvider = [currentDateProvider copy];
   99|      0|  }
  100|      0|  return self;
  101|      0|}
  102|       |
  103|      0|- (BOOL)isNextRequestAllowed {
  104|      0|  @synchronized(self) {
  105|      0|    if (self.lastEventData == nil) {
  106|      0|      return YES;
  107|      0|    }
  108|       |
  109|      0|    NSTimeInterval timeSinceLastEvent =
  110|      0|        [self.currentDateProvider() timeIntervalSinceDate:self.lastEventData.lastEventDate];
  111|      0|    return timeSinceLastEvent >= self.lastEventData.backoffTimeInterval;
  112|      0|  }
  113|      0|}
  114|       |
  115|      0|- (void)registerEvent:(FIRInstallationsBackoffEvent)event {
  116|      0|  @synchronized(self) {
  117|       |    // Event of the same type as was registered before.
  118|      0|    if (self.lastEventData && self.lastEventData.eventType == event) {
  119|      0|      self.lastEventData = [[FIRInstallationsBackoffEventData alloc]
  120|      0|          initWithEvent:event
  121|      0|          lastEventDate:self.currentDateProvider()
  122|      0|             eventCount:self.lastEventData.eventCount + 1];
  123|      0|    } else {  // A different event.
  124|      0|      self.lastEventData =
  125|      0|          [[FIRInstallationsBackoffEventData alloc] initWithEvent:event
  126|      0|                                                    lastEventDate:self.currentDateProvider()
  127|      0|                                                       eventCount:1];
  128|      0|    }
  129|      0|  }
  130|      0|}
  131|       |
  132|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsIDController/FIRInstallationsIDController.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseInstallations/Source/Library/InstallationsIDController/FIRInstallationsIDController.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |#import <GoogleUtilities/GULKeychainStorage.h>
   26|       |#import "FirebaseCore/Sources/Private/FirebaseCoreInternal.h"
   27|       |
   28|       |#import "FirebaseInstallations/Source/Library/Errors/FIRInstallationsErrorUtil.h"
   29|       |#import "FirebaseInstallations/Source/Library/FIRInstallationsItem.h"
   30|       |#import "FirebaseInstallations/Source/Library/FIRInstallationsLogger.h"
   31|       |#import "FirebaseInstallations/Source/Library/IIDMigration/FIRInstallationsIIDStore.h"
   32|       |#import "FirebaseInstallations/Source/Library/IIDMigration/FIRInstallationsIIDTokenStore.h"
   33|       |#import "FirebaseInstallations/Source/Library/InstallationsAPI/FIRInstallationsAPIService.h"
   34|       |#import "FirebaseInstallations/Source/Library/InstallationsIDController/FIRInstallationsBackoffController.h"
   35|       |#import "FirebaseInstallations/Source/Library/InstallationsIDController/FIRInstallationsSingleOperationPromiseCache.h"
   36|       |#import "FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStore.h"
   37|       |
   38|       |#import "FirebaseInstallations/Source/Library/Errors/FIRInstallationsHTTPError.h"
   39|       |#import "FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStoredAuthToken.h"
   40|       |
   41|       |const NSNotificationName FIRInstallationIDDidChangeNotification =
   42|       |    @"FIRInstallationIDDidChangeNotification";
   43|       |NSString *const kFIRInstallationIDDidChangeNotificationAppNameKey =
   44|       |    @"FIRInstallationIDDidChangeNotification";
   45|       |
   46|       |NSTimeInterval const kFIRInstallationsTokenExpirationThreshold = 60 * 60;  // 1 hour.
   47|       |
   48|       |static NSString *const kKeychainService = @"com.firebase.FIRInstallations.installations";
   49|       |
   50|       |@interface FIRInstallationsIDController ()
   51|       |@property(nonatomic, readonly) NSString *appID;
   52|       |@property(nonatomic, readonly) NSString *appName;
   53|       |
   54|       |@property(nonatomic, readonly) FIRInstallationsStore *installationsStore;
   55|       |@property(nonatomic, readonly) FIRInstallationsIIDStore *IIDStore;
   56|       |@property(nonatomic, readonly) FIRInstallationsIIDTokenStore *IIDTokenStore;
   57|       |
   58|       |@property(nonatomic, readonly) FIRInstallationsAPIService *APIService;
   59|       |
   60|       |@property(nonatomic, readonly) id<FIRInstallationsBackoffControllerProtocol> backoffController;
   61|       |
   62|       |@property(nonatomic, readonly) FIRInstallationsSingleOperationPromiseCache<FIRInstallationsItem *>
   63|       |    *getInstallationPromiseCache;
   64|       |@property(nonatomic, readonly)
   65|       |    FIRInstallationsSingleOperationPromiseCache<FIRInstallationsItem *> *authTokenPromiseCache;
   66|       |@property(nonatomic, readonly) FIRInstallationsSingleOperationPromiseCache<FIRInstallationsItem *>
   67|       |    *authTokenForcingRefreshPromiseCache;
   68|       |@property(nonatomic, readonly)
   69|       |    FIRInstallationsSingleOperationPromiseCache<NSNull *> *deleteInstallationPromiseCache;
   70|       |@end
   71|       |
   72|       |@implementation FIRInstallationsIDController
   73|       |
   74|       |- (instancetype)initWithGoogleAppID:(NSString *)appID
   75|       |                            appName:(NSString *)appName
   76|       |                             APIKey:(NSString *)APIKey
   77|       |                          projectID:(NSString *)projectID
   78|       |                        GCMSenderID:(NSString *)GCMSenderID
   79|      0|                        accessGroup:(nullable NSString *)accessGroup {
   80|      0|  NSString *serviceName = [FIRInstallationsIDController keychainServiceWithAppID:appID];
   81|      0|  GULKeychainStorage *secureStorage = [[GULKeychainStorage alloc] initWithService:serviceName];
   82|      0|  FIRInstallationsStore *installationsStore =
   83|      0|      [[FIRInstallationsStore alloc] initWithSecureStorage:secureStorage accessGroup:accessGroup];
   84|       |
   85|      0|  FIRInstallationsAPIService *apiService =
   86|      0|      [[FIRInstallationsAPIService alloc] initWithAPIKey:APIKey projectID:projectID];
   87|       |
   88|      0|  FIRInstallationsIIDStore *IIDStore = [[FIRInstallationsIIDStore alloc] init];
   89|      0|  FIRInstallationsIIDTokenStore *IIDCheckingStore =
   90|      0|      [[FIRInstallationsIIDTokenStore alloc] initWithGCMSenderID:GCMSenderID];
   91|       |
   92|      0|  FIRInstallationsBackoffController *backoffController =
   93|      0|      [[FIRInstallationsBackoffController alloc] init];
   94|       |
   95|      0|  return [self initWithGoogleAppID:appID
   96|      0|                           appName:appName
   97|      0|                installationsStore:installationsStore
   98|      0|                        APIService:apiService
   99|      0|                          IIDStore:IIDStore
  100|      0|                     IIDTokenStore:IIDCheckingStore
  101|      0|                 backoffController:backoffController];
  102|      0|}
  103|       |
  104|       |/// The initializer is supposed to be used by tests to inject `installationsStore`.
  105|       |- (instancetype)initWithGoogleAppID:(NSString *)appID
  106|       |                            appName:(NSString *)appName
  107|       |                 installationsStore:(FIRInstallationsStore *)installationsStore
  108|       |                         APIService:(FIRInstallationsAPIService *)APIService
  109|       |                           IIDStore:(FIRInstallationsIIDStore *)IIDStore
  110|       |                      IIDTokenStore:(FIRInstallationsIIDTokenStore *)IIDTokenStore
  111|       |                  backoffController:
  112|      0|                      (id<FIRInstallationsBackoffControllerProtocol>)backoffController {
  113|      0|  self = [super init];
  114|      0|  if (self) {
  115|      0|    _appID = appID;
  116|      0|    _appName = appName;
  117|      0|    _installationsStore = installationsStore;
  118|      0|    _APIService = APIService;
  119|      0|    _IIDStore = IIDStore;
  120|      0|    _IIDTokenStore = IIDTokenStore;
  121|      0|    _backoffController = backoffController;
  122|       |
  123|      0|    __weak FIRInstallationsIDController *weakSelf = self;
  124|       |
  125|      0|    _getInstallationPromiseCache = [[FIRInstallationsSingleOperationPromiseCache alloc]
  126|      0|        initWithNewOperationHandler:^FBLPromise *_Nonnull {
  127|      0|          FIRInstallationsIDController *strongSelf = weakSelf;
  128|      0|          return [strongSelf createGetInstallationItemPromise];
  129|      0|        }];
  130|       |
  131|      0|    _authTokenPromiseCache = [[FIRInstallationsSingleOperationPromiseCache alloc]
  132|      0|        initWithNewOperationHandler:^FBLPromise *_Nonnull {
  133|      0|          FIRInstallationsIDController *strongSelf = weakSelf;
  134|      0|          return [strongSelf installationWithValidAuthTokenForcingRefresh:NO];
  135|      0|        }];
  136|       |
  137|      0|    _authTokenForcingRefreshPromiseCache = [[FIRInstallationsSingleOperationPromiseCache alloc]
  138|      0|        initWithNewOperationHandler:^FBLPromise *_Nonnull {
  139|      0|          FIRInstallationsIDController *strongSelf = weakSelf;
  140|      0|          return [strongSelf installationWithValidAuthTokenForcingRefresh:YES];
  141|      0|        }];
  142|       |
  143|      0|    _deleteInstallationPromiseCache = [[FIRInstallationsSingleOperationPromiseCache alloc]
  144|      0|        initWithNewOperationHandler:^FBLPromise *_Nonnull {
  145|      0|          FIRInstallationsIDController *strongSelf = weakSelf;
  146|      0|          return [strongSelf createDeleteInstallationPromise];
  147|      0|        }];
  148|      0|  }
  149|      0|  return self;
  150|      0|}
  151|       |
  152|       |#pragma mark - Get Installation.
  153|       |
  154|      0|- (FBLPromise<FIRInstallationsItem *> *)getInstallationItem {
  155|      0|  return [self.getInstallationPromiseCache getExistingPendingOrCreateNewPromise];
  156|      0|}
  157|       |
  158|      0|- (FBLPromise<FIRInstallationsItem *> *)createGetInstallationItemPromise {
  159|      0|  FIRLogDebug(kFIRLoggerInstallations,
  160|      0|              kFIRInstallationsMessageCodeNewGetInstallationOperationCreated, @"%s, appName: %@",
  161|      0|              __PRETTY_FUNCTION__, self.appName);
  162|       |
  163|      0|  FBLPromise<FIRInstallationsItem *> *installationItemPromise =
  164|      0|      [self getStoredInstallation].recover(^id(NSError *error) {
  165|      0|        return [self createAndSaveFID];
  166|      0|      });
  167|       |
  168|       |  // Initiate registration process on success if needed, but return the installation without waiting
  169|       |  // for it.
  170|      0|  installationItemPromise.then(^id(FIRInstallationsItem *installation) {
  171|      0|    [self getAuthTokenForcingRefresh:NO];
  172|      0|    return nil;
  173|      0|  });
  174|       |
  175|      0|  return installationItemPromise;
  176|      0|}
  177|       |
  178|      0|- (FBLPromise<FIRInstallationsItem *> *)getStoredInstallation {
  179|      0|  return [self.installationsStore installationForAppID:self.appID appName:self.appName].validate(
  180|      0|      ^BOOL(FIRInstallationsItem *installation) {
  181|      0|        NSError *validationError;
  182|      0|        BOOL isValid = [installation isValid:&validationError];
  183|       |
  184|      0|        if (!isValid) {
  185|      0|          FIRLogWarning(
  186|      0|              kFIRLoggerInstallations, kFIRInstallationsMessageCodeCorruptedStoredInstallation,
  187|      0|              @"Stored installation validation error: %@", validationError.localizedDescription);
  188|      0|        }
  189|       |
  190|      0|        return isValid;
  191|      0|      });
  192|      0|}
  193|       |
  194|      0|- (FBLPromise<FIRInstallationsItem *> *)createAndSaveFID {
  195|      0|  return [self migrateOrGenerateInstallation]
  196|      0|      .then(^FBLPromise<FIRInstallationsItem *> *(FIRInstallationsItem *installation) {
  197|      0|        return [self saveInstallation:installation];
  198|      0|      })
  199|      0|      .then(^FIRInstallationsItem *(FIRInstallationsItem *installation) {
  200|      0|        [self postFIDDidChangeNotification];
  201|      0|        return installation;
  202|      0|      });
  203|      0|}
  204|       |
  205|      0|- (FBLPromise<FIRInstallationsItem *> *)saveInstallation:(FIRInstallationsItem *)installation {
  206|      0|  return [self.installationsStore saveInstallation:installation].then(
  207|      0|      ^FIRInstallationsItem *(NSNull *result) {
  208|      0|        return installation;
  209|      0|      });
  210|      0|}
  211|       |
  212|       |/**
  213|       | * Tries to migrate IID data stored by FirebaseInstanceID SDK or generates a new Installation ID if
  214|       | * not found.
  215|       | */
  216|      0|- (FBLPromise<FIRInstallationsItem *> *)migrateOrGenerateInstallation {
  217|      0|  if (![self isDefaultApp]) {
  218|       |    // Existing IID should be used only for default FirebaseApp.
  219|      0|    FIRInstallationsItem *installation =
  220|      0|        [self createInstallationWithFID:[FIRInstallationsItem generateFID] IIDDefaultToken:nil];
  221|      0|    return [FBLPromise resolvedWith:installation];
  222|      0|  }
  223|       |
  224|      0|  return [[[FBLPromise
  225|      0|      all:@[ [self.IIDStore existingIID], [self.IIDTokenStore existingIIDDefaultToken] ]]
  226|      0|      then:^id _Nullable(NSArray *_Nullable results) {
  227|      0|        NSString *existingIID = results[0];
  228|      0|        NSString *IIDDefaultToken = results[1];
  229|       |
  230|      0|        return [self createInstallationWithFID:existingIID IIDDefaultToken:IIDDefaultToken];
  231|      0|      }] recover:^id _Nullable(NSError *_Nonnull error) {
  232|      0|    return [self createInstallationWithFID:[FIRInstallationsItem generateFID] IIDDefaultToken:nil];
  233|      0|  }];
  234|      0|}
  235|       |
  236|       |- (FIRInstallationsItem *)createInstallationWithFID:(NSString *)FID
  237|      0|                                    IIDDefaultToken:(nullable NSString *)IIDDefaultToken {
  238|      0|  FIRInstallationsItem *installation = [[FIRInstallationsItem alloc] initWithAppID:self.appID
  239|      0|                                                                   firebaseAppName:self.appName];
  240|      0|  installation.firebaseInstallationID = FID;
  241|      0|  installation.IIDDefaultToken = IIDDefaultToken;
  242|      0|  installation.registrationStatus = FIRInstallationStatusUnregistered;
  243|      0|  return installation;
  244|      0|}
  245|       |
  246|       |#pragma mark - FID registration
  247|       |
  248|       |- (FBLPromise<FIRInstallationsItem *> *)registerInstallationIfNeeded:
  249|      0|    (FIRInstallationsItem *)installation {
  250|      0|  switch (installation.registrationStatus) {
  251|      0|    case FIRInstallationStatusRegistered:
  252|       |      // Already registered. Do nothing.
  253|      0|      return [FBLPromise resolvedWith:installation];
  254|       |
  255|      0|    case FIRInstallationStatusUnknown:
  256|      0|    case FIRInstallationStatusUnregistered:
  257|       |      // Registration required. Proceed.
  258|      0|      break;
  259|      0|  }
  260|       |
  261|       |  // Check for backoff.
  262|      0|  if (![self.backoffController isNextRequestAllowed]) {
  263|      0|    return [FIRInstallationsErrorUtil
  264|      0|        rejectedPromiseWithError:[FIRInstallationsErrorUtil backoffIntervalWaitError]];
  265|      0|  }
  266|       |
  267|      0|  return [self.APIService registerInstallation:installation]
  268|      0|      .catch(^(NSError *_Nonnull error) {
  269|      0|        [self updateBackoffWithSuccess:NO APIError:error];
  270|       |
  271|      0|        if ([self doesRegistrationErrorRequireConfigChange:error]) {
  272|      0|          FIRLogError(kFIRLoggerInstallations,
  273|      0|                      kFIRInstallationsMessageCodeInvalidFirebaseConfiguration,
  274|      0|                      @"Firebase Installation registration failed for app with name: %@, error:\n"
  275|      0|                      @"%@\nPlease make sure you use valid GoogleService-Info.plist",
  276|      0|                      self.appName, error.userInfo[NSLocalizedFailureReasonErrorKey]);
  277|      0|        }
  278|      0|      })
  279|      0|      .then(^id(FIRInstallationsItem *registeredInstallation) {
  280|      0|        [self updateBackoffWithSuccess:YES APIError:nil];
  281|      0|        return [self saveInstallation:registeredInstallation];
  282|      0|      })
  283|      0|      .then(^FIRInstallationsItem *(FIRInstallationsItem *registeredInstallation) {
  284|       |        // Server may respond with a different FID if the sent one cannot be accepted.
  285|      0|        if (![registeredInstallation.firebaseInstallationID
  286|      0|                isEqualToString:installation.firebaseInstallationID]) {
  287|      0|          [self postFIDDidChangeNotification];
  288|      0|        }
  289|      0|        return registeredInstallation;
  290|      0|      });
  291|      0|}
  292|       |
  293|      0|- (BOOL)doesRegistrationErrorRequireConfigChange:(NSError *)error {
  294|      0|  FIRInstallationsHTTPError *HTTPError = (FIRInstallationsHTTPError *)error;
  295|      0|  if (![HTTPError isKindOfClass:[FIRInstallationsHTTPError class]]) {
  296|      0|    return NO;
  297|      0|  }
  298|       |
  299|      0|  switch (HTTPError.HTTPResponse.statusCode) {
  300|       |    // These are the errors that require Firebase configuration change.
  301|      0|    case FIRInstallationsRegistrationHTTPCodeInvalidArgument:
  302|      0|    case FIRInstallationsRegistrationHTTPCodeAPIKeyToProjectIDMismatch:
  303|      0|    case FIRInstallationsRegistrationHTTPCodeProjectNotFound:
  304|      0|      return YES;
  305|       |
  306|      0|    default:
  307|      0|      return NO;
  308|      0|  }
  309|      0|}
  310|       |
  311|       |#pragma mark - Auth Token
  312|       |
  313|      0|- (FBLPromise<FIRInstallationsItem *> *)getAuthTokenForcingRefresh:(BOOL)forceRefresh {
  314|      0|  if (forceRefresh || [self.authTokenForcingRefreshPromiseCache getExistingPendingPromise] != nil) {
  315|      0|    return [self.authTokenForcingRefreshPromiseCache getExistingPendingOrCreateNewPromise];
  316|      0|  } else {
  317|      0|    return [self.authTokenPromiseCache getExistingPendingOrCreateNewPromise];
  318|      0|  }
  319|      0|}
  320|       |
  321|       |- (FBLPromise<FIRInstallationsItem *> *)installationWithValidAuthTokenForcingRefresh:
  322|      0|    (BOOL)forceRefresh {
  323|      0|  FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeNewGetAuthTokenOperationCreated,
  324|      0|              @"-[FIRInstallationsIDController installationWithValidAuthTokenForcingRefresh:%@], "
  325|      0|              @"appName: %@",
  326|      0|              @(forceRefresh), self.appName);
  327|       |
  328|      0|  return [self getInstallationItem]
  329|      0|      .then(^FBLPromise<FIRInstallationsItem *> *(FIRInstallationsItem *installation) {
  330|      0|        return [self registerInstallationIfNeeded:installation];
  331|      0|      })
  332|      0|      .then(^id(FIRInstallationsItem *registeredInstallation) {
  333|      0|        BOOL isTokenExpiredOrExpiresSoon =
  334|      0|            [registeredInstallation.authToken.expirationDate timeIntervalSinceDate:[NSDate date]] <
  335|      0|            kFIRInstallationsTokenExpirationThreshold;
  336|      0|        if (forceRefresh || isTokenExpiredOrExpiresSoon) {
  337|      0|          return [self refreshAuthTokenForInstallation:registeredInstallation];
  338|      0|        } else {
  339|      0|          return registeredInstallation;
  340|      0|        }
  341|      0|      })
  342|      0|      .recover(^id(NSError *error) {
  343|      0|        return [self regenerateFIDOnRefreshTokenErrorIfNeeded:error];
  344|      0|      });
  345|      0|}
  346|       |
  347|       |- (FBLPromise<FIRInstallationsItem *> *)refreshAuthTokenForInstallation:
  348|      0|    (FIRInstallationsItem *)installation {
  349|       |  // Check for backoff.
  350|      0|  if (![self.backoffController isNextRequestAllowed]) {
  351|      0|    return [FIRInstallationsErrorUtil
  352|      0|        rejectedPromiseWithError:[FIRInstallationsErrorUtil backoffIntervalWaitError]];
  353|      0|  }
  354|       |
  355|      0|  return [[[self.APIService refreshAuthTokenForInstallation:installation]
  356|      0|      then:^id _Nullable(FIRInstallationsItem *_Nullable refreshedInstallation) {
  357|      0|        [self updateBackoffWithSuccess:YES APIError:nil];
  358|      0|        return [self saveInstallation:refreshedInstallation];
  359|      0|      }] recover:^id _Nullable(NSError *_Nonnull error) {
  360|       |    // Pass the error to the backoff controller.
  361|      0|    [self updateBackoffWithSuccess:NO APIError:error];
  362|      0|    return error;
  363|      0|  }];
  364|      0|}
  365|       |
  366|      0|- (id)regenerateFIDOnRefreshTokenErrorIfNeeded:(NSError *)error {
  367|      0|  if (![error isKindOfClass:[FIRInstallationsHTTPError class]]) {
  368|       |    // No recovery possible. Return the same error.
  369|      0|    return error;
  370|      0|  }
  371|       |
  372|      0|  FIRInstallationsHTTPError *HTTPError = (FIRInstallationsHTTPError *)error;
  373|      0|  switch (HTTPError.HTTPResponse.statusCode) {
  374|      0|    case FIRInstallationsAuthTokenHTTPCodeInvalidAuthentication:
  375|      0|    case FIRInstallationsAuthTokenHTTPCodeFIDNotFound:
  376|       |      // The stored installation was damaged or blocked by the server.
  377|       |      // Delete the stored installation then generate and register a new one.
  378|      0|      return [self getInstallationItem]
  379|      0|          .then(^FBLPromise<NSNull *> *(FIRInstallationsItem *installation) {
  380|      0|            return [self deleteInstallationLocally:installation];
  381|      0|          })
  382|      0|          .then(^FBLPromise<FIRInstallationsItem *> *(id result) {
  383|      0|            return [self installationWithValidAuthTokenForcingRefresh:NO];
  384|      0|          });
  385|       |
  386|      0|    default:
  387|       |      // No recovery possible. Return the same error.
  388|      0|      return error;
  389|      0|  }
  390|      0|}
  391|       |
  392|       |#pragma mark - Delete FID
  393|       |
  394|      0|- (FBLPromise<NSNull *> *)deleteInstallation {
  395|      0|  return [self.deleteInstallationPromiseCache getExistingPendingOrCreateNewPromise];
  396|      0|}
  397|       |
  398|      0|- (FBLPromise<NSNull *> *)createDeleteInstallationPromise {
  399|      0|  FIRLogDebug(kFIRLoggerInstallations,
  400|      0|              kFIRInstallationsMessageCodeNewDeleteInstallationOperationCreated, @"%s, appName: %@",
  401|      0|              __PRETTY_FUNCTION__, self.appName);
  402|       |
  403|       |  // Check for ongoing requests first, if there is no a request, then check local storage for
  404|       |  // existing installation.
  405|      0|  FBLPromise<FIRInstallationsItem *> *currentInstallationPromise =
  406|      0|      [self mostRecentInstallationOperation] ?: [self getStoredInstallation];
  407|       |
  408|      0|  return currentInstallationPromise
  409|      0|      .then(^id(FIRInstallationsItem *installation) {
  410|      0|        return [self sendDeleteInstallationRequestIfNeeded:installation];
  411|      0|      })
  412|      0|      .then(^id(FIRInstallationsItem *installation) {
  413|       |        // Remove the installation from the local storage.
  414|      0|        return [self deleteInstallationLocally:installation];
  415|      0|      });
  416|      0|}
  417|       |
  418|      0|- (FBLPromise<NSNull *> *)deleteInstallationLocally:(FIRInstallationsItem *)installation {
  419|      0|  return [self.installationsStore removeInstallationForAppID:installation.appID
  420|      0|                                                     appName:installation.firebaseAppName]
  421|      0|      .then(^FBLPromise<NSNull *> *(NSNull *result) {
  422|      0|        return [self deleteExistingIIDIfNeeded];
  423|      0|      })
  424|      0|      .then(^NSNull *(NSNull *result) {
  425|      0|        [self postFIDDidChangeNotification];
  426|      0|        return result;
  427|      0|      });
  428|      0|}
  429|       |
  430|       |- (FBLPromise<FIRInstallationsItem *> *)sendDeleteInstallationRequestIfNeeded:
  431|      0|    (FIRInstallationsItem *)installation {
  432|      0|  switch (installation.registrationStatus) {
  433|      0|    case FIRInstallationStatusUnknown:
  434|      0|    case FIRInstallationStatusUnregistered:
  435|       |      // The installation is not registered, so it is safe to be deleted as is, so return early.
  436|      0|      return [FBLPromise resolvedWith:installation];
  437|      0|      break;
  438|       |
  439|      0|    case FIRInstallationStatusRegistered:
  440|       |      // Proceed to de-register the installation on the server.
  441|      0|      break;
  442|      0|  }
  443|       |
  444|      0|  return [self.APIService deleteInstallation:installation].recover(^id(NSError *APIError) {
  445|      0|    if ([FIRInstallationsErrorUtil isAPIError:APIError withHTTPCode:404]) {
  446|       |      // The installation was not found on the server.
  447|       |      // Return success.
  448|      0|      return installation;
  449|      0|    } else {
  450|       |      // Re-throw the error otherwise.
  451|      0|      return APIError;
  452|      0|    }
  453|      0|  });
  454|      0|}
  455|       |
  456|      0|- (FBLPromise<NSNull *> *)deleteExistingIIDIfNeeded {
  457|      0|  if ([self isDefaultApp]) {
  458|      0|    return [self.IIDStore deleteExistingIID];
  459|      0|  } else {
  460|      0|    return [FBLPromise resolvedWith:[NSNull null]];
  461|      0|  }
  462|      0|}
  463|       |
  464|      0|- (nullable FBLPromise<FIRInstallationsItem *> *)mostRecentInstallationOperation {
  465|      0|  return [self.authTokenForcingRefreshPromiseCache getExistingPendingPromise]
  466|      0|             ?: [self.authTokenPromiseCache getExistingPendingPromise]
  467|      0|                    ?: [self.getInstallationPromiseCache getExistingPendingPromise];
  468|      0|}
  469|       |
  470|       |#pragma mark - Backoff
  471|       |
  472|      0|- (void)updateBackoffWithSuccess:(BOOL)success APIError:(nullable NSError *)APIError {
  473|      0|  if (success) {
  474|      0|    [self.backoffController registerEvent:FIRInstallationsBackoffEventSuccess];
  475|      0|  } else if ([APIError isKindOfClass:[FIRInstallationsHTTPError class]]) {
  476|      0|    FIRInstallationsHTTPError *HTTPResponseError = (FIRInstallationsHTTPError *)APIError;
  477|      0|    NSInteger statusCode = HTTPResponseError.HTTPResponse.statusCode;
  478|       |
  479|      0|    if (statusCode == FIRInstallationsAuthTokenHTTPCodeInvalidAuthentication ||
  480|      0|        statusCode == FIRInstallationsAuthTokenHTTPCodeFIDNotFound) {
  481|       |      // These errors are explicitly excluded because they are handled by FIS SDK itself so don't
  482|       |      // require backoff.
  483|      0|    } else if (statusCode == 400 || statusCode == 403) {  // Explicitly unrecoverable errors.
  484|      0|      [self.backoffController registerEvent:FIRInstallationsBackoffEventUnrecoverableFailure];
  485|      0|    } else if (statusCode == 429 ||
  486|      0|               (statusCode >= 500 && statusCode < 600)) {  // Explicitly recoverable errors.
  487|      0|      [self.backoffController registerEvent:FIRInstallationsBackoffEventRecoverableFailure];
  488|      0|    } else {  // Treat all unknown errors as recoverable.
  489|      0|      [self.backoffController registerEvent:FIRInstallationsBackoffEventRecoverableFailure];
  490|      0|    }
  491|      0|  }
  492|       |
  493|       |  // If the error class is not `FIRInstallationsHTTPError` it indicates a connection error. Such
  494|       |  // errors should not change backoff interval.
  495|      0|}
  496|       |
  497|       |#pragma mark - Notifications
  498|       |
  499|      0|- (void)postFIDDidChangeNotification {
  500|      0|  [[NSNotificationCenter defaultCenter]
  501|      0|      postNotificationName:FIRInstallationIDDidChangeNotification
  502|      0|                    object:nil
  503|      0|                  userInfo:@{kFIRInstallationIDDidChangeNotificationAppNameKey : self.appName}];
  504|      0|}
  505|       |
  506|       |#pragma mark - Default App
  507|       |
  508|      0|- (BOOL)isDefaultApp {
  509|      0|  return [self.appName isEqualToString:kFIRDefaultAppName];
  510|      0|}
  511|       |
  512|       |#pragma mark - Keychain
  513|       |
  514|      0|+ (NSString *)keychainServiceWithAppID:(NSString *)appID {
  515|       |#if TARGET_OS_MACCATALYST || TARGET_OS_OSX
  516|       |  // We need to keep service name unique per application on macOS.
  517|       |  // Applications on macOS may request access to Keychain items stored by other applications. It
  518|       |  // means that when the app looks up for a relevant Keychain item in the service scope it will
  519|       |  // request user password to grant access to the Keychain if there are other Keychain items from
  520|       |  // other applications stored under the same Keychain Service.
  521|       |  return [kKeychainService stringByAppendingFormat:@".%@", appID];
  522|       |#else
  523|       |  // Use a constant Keychain service for non-macOS because:
  524|       |  // 1. Keychain items cannot be shared between apps until configured specifically so the service
  525|       |  // name collisions are not a concern
  526|       |  // 2. We don't want to change the service name to avoid doing a migration.
  527|      0|  return kKeychainService;
  528|      0|#endif
  529|      0|}
  530|       |
  531|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsIDController/FIRInstallationsSingleOperationPromiseCache.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseInstallations/Source/Library/InstallationsIDController/FIRInstallationsSingleOperationPromiseCache.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |@interface FIRInstallationsSingleOperationPromiseCache <ResultType>()
   26|       |@property(nonatomic, readonly) FBLPromise *_Nonnull (^newOperationHandler)(void);
   27|       |@property(nonatomic, nullable) FBLPromise *pendingPromise;
   28|       |@end
   29|       |
   30|       |@implementation FIRInstallationsSingleOperationPromiseCache
   31|       |
   32|       |- (instancetype)initWithNewOperationHandler:
   33|      0|    (FBLPromise<id> *_Nonnull (^)(void))newOperationHandler {
   34|      0|  if (newOperationHandler == nil) {
   35|      0|    [NSException raise:NSInvalidArgumentException
   36|      0|                format:@"`newOperationHandler` must not be `nil`."];
   37|      0|  }
   38|       |
   39|      0|  self = [super init];
   40|      0|  if (self) {
   41|      0|    _newOperationHandler = [newOperationHandler copy];
   42|      0|  }
   43|      0|  return self;
   44|      0|}
   45|       |
   46|      0|- (FBLPromise *)getExistingPendingOrCreateNewPromise {
   47|      0|  @synchronized(self) {
   48|      0|    if (!self.pendingPromise) {
   49|      0|      self.pendingPromise = self.newOperationHandler();
   50|       |
   51|      0|      self.pendingPromise
   52|      0|          .then(^id(id result) {
   53|      0|            @synchronized(self) {
   54|      0|              self.pendingPromise = nil;
   55|      0|              return nil;
   56|      0|            }
   57|      0|          })
   58|      0|          .catch(^void(NSError *error) {
   59|      0|            @synchronized(self) {
   60|      0|              self.pendingPromise = nil;
   61|      0|            }
   62|      0|          });
   63|      0|    }
   64|       |
   65|      0|    return self.pendingPromise;
   66|      0|  }
   67|      0|}
   68|       |
   69|      0|- (nullable FBLPromise *)getExistingPendingPromise {
   70|      0|  @synchronized(self) {
   71|      0|    return self.pendingPromise;
   72|      0|  }
   73|      0|}
   74|       |
   75|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStore.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStore.h"
   18|       |
   19|       |#import <GoogleUtilities/GULUserDefaults.h>
   20|       |
   21|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   22|       |#import <FBLPromises/FBLPromises.h>
   23|       |#else
   24|       |#import "FBLPromises.h"
   25|       |#endif
   26|       |
   27|       |#import <GoogleUtilities/GULKeychainStorage.h>
   28|       |
   29|       |#import "FirebaseInstallations/Source/Library/Errors/FIRInstallationsErrorUtil.h"
   30|       |#import "FirebaseInstallations/Source/Library/FIRInstallationsItem.h"
   31|       |#import "FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStoredItem.h"
   32|       |
   33|       |NSString *const kFIRInstallationsStoreUserDefaultsID = @"com.firebase.FIRInstallations";
   34|       |
   35|       |@interface FIRInstallationsStore ()
   36|       |@property(nonatomic, readonly) GULKeychainStorage *secureStorage;
   37|       |@property(nonatomic, readonly, nullable) NSString *accessGroup;
   38|       |@property(nonatomic, readonly) dispatch_queue_t queue;
   39|       |@property(nonatomic, readonly) GULUserDefaults *userDefaults;
   40|       |@end
   41|       |
   42|       |@implementation FIRInstallationsStore
   43|       |
   44|       |- (instancetype)initWithSecureStorage:(GULKeychainStorage *)storage
   45|      0|                          accessGroup:(NSString *)accessGroup {
   46|      0|  self = [super init];
   47|      0|  if (self) {
   48|      0|    _secureStorage = storage;
   49|      0|    _accessGroup = [accessGroup copy];
   50|      0|    _queue = dispatch_queue_create("com.firebase.FIRInstallationsStore", DISPATCH_QUEUE_SERIAL);
   51|       |
   52|      0|    NSString *userDefaultsSuiteName = _accessGroup ?: kFIRInstallationsStoreUserDefaultsID;
   53|      0|    _userDefaults = [[GULUserDefaults alloc] initWithSuiteName:userDefaultsSuiteName];
   54|      0|  }
   55|      0|  return self;
   56|      0|}
   57|       |
   58|       |- (FBLPromise<FIRInstallationsItem *> *)installationForAppID:(NSString *)appID
   59|      0|                                                     appName:(NSString *)appName {
   60|      0|  NSString *itemID = [FIRInstallationsItem identifierWithAppID:appID appName:appName];
   61|      0|  return [self installationExistsForAppID:appID appName:appName]
   62|      0|      .then(^id(id result) {
   63|      0|        return [self.secureStorage getObjectForKey:itemID
   64|      0|                                       objectClass:[FIRInstallationsStoredItem class]
   65|      0|                                       accessGroup:self.accessGroup];
   66|      0|      })
   67|      0|      .then(^id(FIRInstallationsStoredItem *_Nullable storedItem) {
   68|      0|        if (storedItem == nil) {
   69|      0|          return [FIRInstallationsErrorUtil installationItemNotFoundForAppID:appID appName:appName];
   70|      0|        }
   71|       |
   72|      0|        FIRInstallationsItem *item = [[FIRInstallationsItem alloc] initWithAppID:appID
   73|      0|                                                                 firebaseAppName:appName];
   74|      0|        [item updateWithStoredItem:storedItem];
   75|      0|        return item;
   76|      0|      });
   77|      0|}
   78|       |
   79|      0|- (FBLPromise<NSNull *> *)saveInstallation:(FIRInstallationsItem *)installationItem {
   80|      0|  FIRInstallationsStoredItem *storedItem = [installationItem storedItem];
   81|      0|  NSString *identifier = [installationItem identifier];
   82|       |
   83|      0|  return
   84|      0|      [self.secureStorage setObject:storedItem forKey:identifier accessGroup:self.accessGroup].then(
   85|      0|          ^id(id result) {
   86|      0|            return [self setInstallationExists:YES forItemWithIdentifier:identifier];
   87|      0|          });
   88|      0|}
   89|       |
   90|      0|- (FBLPromise<NSNull *> *)removeInstallationForAppID:(NSString *)appID appName:(NSString *)appName {
   91|      0|  NSString *identifier = [FIRInstallationsItem identifierWithAppID:appID appName:appName];
   92|      0|  return [self.secureStorage removeObjectForKey:identifier accessGroup:self.accessGroup].then(
   93|      0|      ^id(id result) {
   94|      0|        return [self setInstallationExists:NO forItemWithIdentifier:identifier];
   95|      0|      });
   96|      0|}
   97|       |
   98|       |#pragma mark - User defaults
   99|       |
  100|      0|- (FBLPromise<NSNull *> *)installationExistsForAppID:(NSString *)appID appName:(NSString *)appName {
  101|      0|  NSString *identifier = [FIRInstallationsItem identifierWithAppID:appID appName:appName];
  102|      0|  return [FBLPromise onQueue:self.queue
  103|      0|                          do:^id _Nullable {
  104|      0|                            return [[self userDefaults] objectForKey:identifier] != nil
  105|      0|                                       ? [NSNull null]
  106|      0|                                       : [FIRInstallationsErrorUtil
  107|      0|                                             installationItemNotFoundForAppID:appID
  108|      0|                                                                      appName:appName];
  109|      0|                          }];
  110|      0|}
  111|       |
  112|       |- (FBLPromise<NSNull *> *)setInstallationExists:(BOOL)exists
  113|      0|                          forItemWithIdentifier:(NSString *)identifier {
  114|      0|  return [FBLPromise onQueue:self.queue
  115|      0|                          do:^id _Nullable {
  116|      0|                            if (exists) {
  117|      0|                              [[self userDefaults] setBool:YES forKey:identifier];
  118|      0|                            } else {
  119|      0|                              [[self userDefaults] removeObjectForKey:identifier];
  120|      0|                            }
  121|       |
  122|      0|                            return [NSNull null];
  123|      0|                          }];
  124|      0|}
  125|       |
  126|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStoredAuthToken.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStoredAuthToken.h"
   18|       |
   19|       |#import "FirebaseInstallations/Source/Library/FIRInstallationsLogger.h"
   20|       |
   21|       |NSString *const kFIRInstallationsStoredAuthTokenStatusKey = @"status";
   22|       |NSString *const kFIRInstallationsStoredAuthTokenTokenKey = @"token";
   23|       |NSString *const kFIRInstallationsStoredAuthTokenExpirationDateKey = @"expirationDate";
   24|       |NSString *const kFIRInstallationsStoredAuthTokenStorageVersionKey = @"storageVersion";
   25|       |
   26|       |NSInteger const kFIRInstallationsStoredAuthTokenStorageVersion = 1;
   27|       |
   28|       |@implementation FIRInstallationsStoredAuthToken
   29|       |
   30|      0|- (NSInteger)storageVersion {
   31|      0|  return kFIRInstallationsStoredAuthTokenStorageVersion;
   32|      0|}
   33|       |
   34|      0|- (nonnull id)copyWithZone:(nullable NSZone *)zone {
   35|      0|  FIRInstallationsStoredAuthToken *clone = [[FIRInstallationsStoredAuthToken alloc] init];
   36|      0|  clone.status = self.status;
   37|      0|  clone.token = [self.token copy];
   38|      0|  clone.expirationDate = self.expirationDate;
   39|      0|  return clone;
   40|      0|}
   41|       |
   42|      0|- (void)encodeWithCoder:(nonnull NSCoder *)aCoder {
   43|      0|  [aCoder encodeInteger:self.status forKey:kFIRInstallationsStoredAuthTokenStatusKey];
   44|      0|  [aCoder encodeObject:self.token forKey:kFIRInstallationsStoredAuthTokenTokenKey];
   45|      0|  [aCoder encodeObject:self.expirationDate
   46|      0|                forKey:kFIRInstallationsStoredAuthTokenExpirationDateKey];
   47|      0|  [aCoder encodeInteger:self.storageVersion
   48|      0|                 forKey:kFIRInstallationsStoredAuthTokenStorageVersionKey];
   49|      0|}
   50|       |
   51|      0|- (nullable instancetype)initWithCoder:(nonnull NSCoder *)aDecoder {
   52|      0|  NSInteger storageVersion =
   53|      0|      [aDecoder decodeIntegerForKey:kFIRInstallationsStoredAuthTokenStorageVersionKey];
   54|      0|  if (storageVersion > kFIRInstallationsStoredAuthTokenStorageVersion) {
   55|      0|    FIRLogWarning(kFIRLoggerInstallations,
   56|      0|                  kFIRInstallationsMessageCodeAuthTokenCoderVersionMismatch,
   57|      0|                  @"FIRInstallationsStoredAuthToken was encoded by a newer coder version %ld. "
   58|      0|                  @"Current coder version is %ld. Some auth token data may be lost.",
   59|      0|                  (long)storageVersion, (long)kFIRInstallationsStoredAuthTokenStorageVersion);
   60|      0|  }
   61|       |
   62|      0|  FIRInstallationsStoredAuthToken *object = [[FIRInstallationsStoredAuthToken alloc] init];
   63|      0|  object.status = [aDecoder decodeIntegerForKey:kFIRInstallationsStoredAuthTokenStatusKey];
   64|      0|  object.token = [aDecoder decodeObjectOfClass:[NSString class]
   65|      0|                                        forKey:kFIRInstallationsStoredAuthTokenTokenKey];
   66|      0|  object.expirationDate =
   67|      0|      [aDecoder decodeObjectOfClass:[NSDate class]
   68|      0|                             forKey:kFIRInstallationsStoredAuthTokenExpirationDateKey];
   69|       |
   70|      0|  return object;
   71|      0|}
   72|       |
   73|      0|+ (BOOL)supportsSecureCoding {
   74|      0|  return YES;
   75|      0|}
   76|       |
   77|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStoredItem.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStoredItem.h"
   18|       |
   19|       |#import "FirebaseInstallations/Source/Library/FIRInstallationsLogger.h"
   20|       |#import "FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStoredAuthToken.h"
   21|       |
   22|       |NSString *const kFIRInstallationsStoredItemFirebaseInstallationIDKey = @"firebaseInstallationID";
   23|       |NSString *const kFIRInstallationsStoredItemRefreshTokenKey = @"refreshToken";
   24|       |NSString *const kFIRInstallationsStoredItemAuthTokenKey = @"authToken";
   25|       |NSString *const kFIRInstallationsStoredItemRegistrationStatusKey = @"registrationStatus";
   26|       |NSString *const kFIRInstallationsStoredItemIIDDefaultTokenKey = @"IIDDefaultToken";
   27|       |NSString *const kFIRInstallationsStoredItemStorageVersionKey = @"storageVersion";
   28|       |
   29|       |NSInteger const kFIRInstallationsStoredItemStorageVersion = 1;
   30|       |
   31|       |@implementation FIRInstallationsStoredItem
   32|       |
   33|      0|- (NSInteger)storageVersion {
   34|      0|  return kFIRInstallationsStoredItemStorageVersion;
   35|      0|}
   36|       |
   37|      0|- (void)encodeWithCoder:(nonnull NSCoder *)aCoder {
   38|      0|  [aCoder encodeObject:self.firebaseInstallationID
   39|      0|                forKey:kFIRInstallationsStoredItemFirebaseInstallationIDKey];
   40|      0|  [aCoder encodeObject:self.refreshToken forKey:kFIRInstallationsStoredItemRefreshTokenKey];
   41|      0|  [aCoder encodeObject:self.authToken forKey:kFIRInstallationsStoredItemAuthTokenKey];
   42|      0|  [aCoder encodeInteger:self.registrationStatus
   43|      0|                 forKey:kFIRInstallationsStoredItemRegistrationStatusKey];
   44|      0|  [aCoder encodeObject:self.IIDDefaultToken forKey:kFIRInstallationsStoredItemIIDDefaultTokenKey];
   45|      0|  [aCoder encodeInteger:self.storageVersion forKey:kFIRInstallationsStoredItemStorageVersionKey];
   46|      0|}
   47|       |
   48|      0|- (nullable instancetype)initWithCoder:(nonnull NSCoder *)aDecoder {
   49|      0|  NSInteger storageVersion =
   50|      0|      [aDecoder decodeIntegerForKey:kFIRInstallationsStoredItemStorageVersionKey];
   51|      0|  if (storageVersion > self.storageVersion) {
   52|      0|    FIRLogWarning(kFIRLoggerInstallations,
   53|      0|                  kFIRInstallationsMessageCodeInstallationCoderVersionMismatch,
   54|      0|                  @"FIRInstallationsStoredItem was encoded by a newer coder version %ld. Current "
   55|      0|                  @"coder version is %ld. Some installation data may be lost.",
   56|      0|                  (long)storageVersion, (long)kFIRInstallationsStoredItemStorageVersion);
   57|      0|  }
   58|       |
   59|      0|  FIRInstallationsStoredItem *item = [[FIRInstallationsStoredItem alloc] init];
   60|      0|  item.firebaseInstallationID =
   61|      0|      [aDecoder decodeObjectOfClass:[NSString class]
   62|      0|                             forKey:kFIRInstallationsStoredItemFirebaseInstallationIDKey];
   63|      0|  item.refreshToken = [aDecoder decodeObjectOfClass:[NSString class]
   64|      0|                                             forKey:kFIRInstallationsStoredItemRefreshTokenKey];
   65|      0|  item.authToken = [aDecoder decodeObjectOfClass:[FIRInstallationsStoredAuthToken class]
   66|      0|                                          forKey:kFIRInstallationsStoredItemAuthTokenKey];
   67|      0|  item.registrationStatus =
   68|      0|      [aDecoder decodeIntegerForKey:kFIRInstallationsStoredItemRegistrationStatusKey];
   69|      0|  item.IIDDefaultToken =
   70|      0|      [aDecoder decodeObjectOfClass:[NSString class]
   71|      0|                             forKey:kFIRInstallationsStoredItemIIDDefaultTokenKey];
   72|       |
   73|      0|  return item;
   74|      0|}
   75|       |
   76|      0|+ (BOOL)supportsSecureCoding {
   77|      0|  return YES;
   78|      0|}
   79|       |
   80|       |@end

