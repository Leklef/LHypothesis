/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/AppDelegateSwizzler/GULAppDelegateSwizzler.m:
    1|       |// Copyright 2018 Google LLC
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import <TargetConditionals.h>
   16|       |
   17|       |#import "GoogleUtilities/AppDelegateSwizzler/Internal/GULAppDelegateSwizzler_Private.h"
   18|       |#import "GoogleUtilities/AppDelegateSwizzler/Public/GoogleUtilities/GULAppDelegateSwizzler.h"
   19|       |#import "GoogleUtilities/Common/GULLoggerCodes.h"
   20|       |#import "GoogleUtilities/Environment/Public/GoogleUtilities/GULAppEnvironmentUtil.h"
   21|       |#import "GoogleUtilities/Logger/Public/GoogleUtilities/GULLogger.h"
   22|       |#import "GoogleUtilities/Network/Public/GoogleUtilities/GULMutableDictionary.h"
   23|       |
   24|       |#import <dispatch/group.h>
   25|       |#import <objc/runtime.h>
   26|       |
   27|       |// Implementations need to be typed before calling the implementation directly to cast the
   28|       |// arguments and the return types correctly. Otherwise, it will crash the app.
   29|       |typedef BOOL (*GULRealOpenURLSourceApplicationAnnotationIMP)(
   30|       |    id, SEL, GULApplication *, NSURL *, NSString *, id);
   31|       |
   32|       |typedef BOOL (*GULRealOpenURLOptionsIMP)(
   33|       |    id, SEL, GULApplication *, NSURL *, NSDictionary<NSString *, id> *);
   34|       |
   35|       |#pragma clang diagnostic push
   36|       |#pragma clang diagnostic ignored "-Wstrict-prototypes"
   37|       |typedef void (*GULRealHandleEventsForBackgroundURLSessionIMP)(
   38|       |    id, SEL, GULApplication *, NSString *, void (^)());
   39|       |#pragma clang diagnostic pop
   40|       |
   41|       |typedef BOOL (*GULRealContinueUserActivityIMP)(
   42|       |    id, SEL, GULApplication *, NSUserActivity *, void (^)(NSArray *restorableObjects));
   43|       |
   44|       |typedef void (*GULRealDidRegisterForRemoteNotificationsIMP)(id, SEL, GULApplication *, NSData *);
   45|       |
   46|       |typedef void (*GULRealDidFailToRegisterForRemoteNotificationsIMP)(id,
   47|       |                                                                  SEL,
   48|       |                                                                  GULApplication *,
   49|       |                                                                  NSError *);
   50|       |
   51|       |typedef void (*GULRealDidReceiveRemoteNotificationIMP)(id, SEL, GULApplication *, NSDictionary *);
   52|       |
   53|       |#if !TARGET_OS_WATCH && !TARGET_OS_OSX
   54|       |typedef void (*GULRealDidReceiveRemoteNotificationWithCompletionIMP)(
   55|       |    id, SEL, GULApplication *, NSDictionary *, void (^)(UIBackgroundFetchResult));
   56|       |#endif  // !TARGET_OS_WATCH && !TARGET_OS_OSX
   57|       |
   58|       |typedef void (^GULAppDelegateInterceptorCallback)(id<GULApplicationDelegate>);
   59|       |
   60|       |// The strings below are the keys for associated objects.
   61|       |static char const *const kGULRealIMPBySelectorKey = "GUL_realIMPBySelector";
   62|       |static char const *const kGULRealClassKey = "GUL_realClass";
   63|       |
   64|       |static NSString *const kGULAppDelegateKeyPath = @"delegate";
   65|       |
   66|       |static GULLoggerService kGULLoggerSwizzler = @"[GoogleUtilities/AppDelegateSwizzler]";
   67|       |
   68|       |// Since Firebase SDKs also use this for app delegate proxying, in order to not be a breaking change
   69|       |// we disable App Delegate proxying when either of these two flags are set to NO.
   70|       |
   71|       |/** Plist key that allows Firebase developers to disable App and Scene Delegate Proxying. */
   72|       |static NSString *const kGULFirebaseAppDelegateProxyEnabledPlistKey =
   73|       |    @"FirebaseAppDelegateProxyEnabled";
   74|       |
   75|       |/** Plist key that allows developers not using Firebase to disable App and Scene Delegate Proxying.
   76|       | */
   77|       |static NSString *const kGULGoogleUtilitiesAppDelegateProxyEnabledPlistKey =
   78|       |    @"GoogleUtilitiesAppDelegateProxyEnabled";
   79|       |
   80|       |/** The prefix of the App Delegate. */
   81|       |static NSString *const kGULAppDelegatePrefix = @"GUL_";
   82|       |
   83|       |/** The original instance of App Delegate. */
   84|       |static id<GULApplicationDelegate> gOriginalAppDelegate;
   85|       |
   86|       |/** The original App Delegate class */
   87|       |static Class gOriginalAppDelegateClass;
   88|       |
   89|       |/** The subclass of the original App Delegate. */
   90|       |static Class gAppDelegateSubclass;
   91|       |
   92|       |/** Remote notification methods selectors
   93|       | *
   94|       | *  We have to opt out of referencing APNS related App Delegate methods directly to prevent
   95|       | *  an Apple review warning email about missing Push Notification Entitlement
   96|       | *  (like here: https://github.com/firebase/firebase-ios-sdk/issues/2807). From our experience, the
   97|       | *  warning is triggered when any of the symbols is present in the application sent to review, even
   98|       | *  if the code is never executed. Because GULAppDelegateSwizzler may be used by applications that
   99|       | *  are not using APNS we have to refer to the methods indirectly using selector constructed from
  100|       | *  string.
  101|       | *
  102|       | *  NOTE: None of the methods is proxied unless it is explicitly requested by calling the method
  103|       | *  +[GULAppDelegateSwizzler proxyOriginalDelegateIncludingAPNSMethods]
  104|       | */
  105|       |static NSString *const kGULDidRegisterForRemoteNotificationsSEL =
  106|       |    @"application:didRegisterForRemoteNotificationsWithDeviceToken:";
  107|       |static NSString *const kGULDidFailToRegisterForRemoteNotificationsSEL =
  108|       |    @"application:didFailToRegisterForRemoteNotificationsWithError:";
  109|       |static NSString *const kGULDidReceiveRemoteNotificationSEL =
  110|       |    @"application:didReceiveRemoteNotification:";
  111|       |static NSString *const kGULDidReceiveRemoteNotificationWithCompletionSEL =
  112|       |    @"application:didReceiveRemoteNotification:fetchCompletionHandler:";
  113|       |
  114|       |/**
  115|       | * This class is necessary to store the delegates in an NSArray without retaining them.
  116|       | * [NSValue valueWithNonRetainedObject] also provides this functionality, but does not provide a
  117|       | * zeroing pointer. This will cause EXC_BAD_ACCESS when trying to access the object after it is
  118|       | * dealloced. Instead, this container stores a weak, zeroing reference to the object, which
  119|       | * automatically is set to nil by the runtime when the object is dealloced.
  120|       | */
  121|       |@interface GULZeroingWeakContainer : NSObject
  122|       |
  123|       |/** Stores a weak object. */
  124|       |@property(nonatomic, weak) id object;
  125|       |
  126|       |@end
  127|       |
  128|       |@implementation GULZeroingWeakContainer
  129|       |@end
  130|       |
  131|       |@interface GULAppDelegateObserver : NSObject
  132|       |@end
  133|       |
  134|       |@implementation GULAppDelegateObserver {
  135|       |  BOOL _isObserving;
  136|       |}
  137|       |
  138|      0|+ (GULAppDelegateObserver *)sharedInstance {
  139|      0|  static GULAppDelegateObserver *instance;
  140|      0|  static dispatch_once_t once;
  141|      0|  dispatch_once(&once, ^{
  142|      0|    instance = [[GULAppDelegateObserver alloc] init];
  143|      0|  });
  144|      0|  return instance;
  145|      0|}
  146|       |
  147|      0|- (void)observeUIApplication {
  148|      0|  if (_isObserving) {
  149|      0|    return;
  150|      0|  }
  151|      0|  [[GULAppDelegateSwizzler sharedApplication]
  152|      0|      addObserver:self
  153|      0|       forKeyPath:kGULAppDelegateKeyPath
  154|      0|          options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld
  155|      0|          context:nil];
  156|      0|  _isObserving = YES;
  157|      0|}
  158|       |
  159|       |- (void)observeValueForKeyPath:(NSString *)keyPath
  160|       |                      ofObject:(id)object
  161|       |                        change:(NSDictionary *)change
  162|      0|                       context:(void *)context {
  163|      0|  if ([keyPath isEqual:kGULAppDelegateKeyPath]) {
  164|      0|    id newValue = change[NSKeyValueChangeNewKey];
  165|      0|    id oldValue = change[NSKeyValueChangeOldKey];
  166|      0|    if ([newValue isEqual:oldValue]) {
  167|      0|      return;
  168|      0|    }
  169|       |    // Free the stored app delegate instance because it has been changed to a different instance to
  170|       |    // avoid keeping it alive forever.
  171|      0|    if ([oldValue isEqual:gOriginalAppDelegate]) {
  172|      0|      gOriginalAppDelegate = nil;
  173|       |      // Remove the observer. Parse it to NSObject to avoid warning.
  174|      0|      [[GULAppDelegateSwizzler sharedApplication] removeObserver:self
  175|      0|                                                      forKeyPath:kGULAppDelegateKeyPath];
  176|      0|      _isObserving = NO;
  177|      0|    }
  178|      0|  }
  179|      0|}
  180|       |
  181|       |@end
  182|       |
  183|       |@implementation GULAppDelegateSwizzler
  184|       |
  185|       |static dispatch_once_t sProxyAppDelegateOnceToken;
  186|       |static dispatch_once_t sProxyAppDelegateRemoteNotificationOnceToken;
  187|       |
  188|       |#pragma mark - Public methods
  189|       |
  190|      0|+ (BOOL)isAppDelegateProxyEnabled {
  191|      0|  NSDictionary *infoDictionary = [NSBundle mainBundle].infoDictionary;
  192|       |
  193|      0|  id isFirebaseProxyEnabledPlistValue = infoDictionary[kGULFirebaseAppDelegateProxyEnabledPlistKey];
  194|      0|  id isGoogleProxyEnabledPlistValue =
  195|      0|      infoDictionary[kGULGoogleUtilitiesAppDelegateProxyEnabledPlistKey];
  196|       |
  197|       |  // Enabled by default.
  198|      0|  BOOL isFirebaseAppDelegateProxyEnabled = YES;
  199|      0|  BOOL isGoogleUtilitiesAppDelegateProxyEnabled = YES;
  200|       |
  201|      0|  if ([isFirebaseProxyEnabledPlistValue isKindOfClass:[NSNumber class]]) {
  202|      0|    isFirebaseAppDelegateProxyEnabled = [isFirebaseProxyEnabledPlistValue boolValue];
  203|      0|  }
  204|       |
  205|      0|  if ([isGoogleProxyEnabledPlistValue isKindOfClass:[NSNumber class]]) {
  206|      0|    isGoogleUtilitiesAppDelegateProxyEnabled = [isGoogleProxyEnabledPlistValue boolValue];
  207|      0|  }
  208|       |
  209|       |  // Only deactivate the proxy if it is explicitly disabled by app developers using either one of
  210|       |  // the plist flags.
  211|      0|  return isFirebaseAppDelegateProxyEnabled && isGoogleUtilitiesAppDelegateProxyEnabled;
  212|      0|}
  213|       |
  214|       |+ (GULAppDelegateInterceptorID)registerAppDelegateInterceptor:
  215|      0|    (id<GULApplicationDelegate>)interceptor {
  216|      0|  NSAssert(interceptor, @"AppDelegateProxy cannot add nil interceptor");
  217|      0|  NSAssert([interceptor conformsToProtocol:@protocol(GULApplicationDelegate)],
  218|      0|           @"AppDelegateProxy interceptor does not conform to UIApplicationDelegate");
  219|       |
  220|      0|  if (!interceptor) {
  221|      0|    GULLogError(kGULLoggerSwizzler, NO,
  222|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  223|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling000],
  224|      0|                @"AppDelegateProxy cannot add nil interceptor.");
  225|      0|    return nil;
  226|      0|  }
  227|      0|  if (![interceptor conformsToProtocol:@protocol(GULApplicationDelegate)]) {
  228|      0|    GULLogError(kGULLoggerSwizzler, NO,
  229|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  230|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling001],
  231|      0|                @"AppDelegateProxy interceptor does not conform to UIApplicationDelegate");
  232|      0|    return nil;
  233|      0|  }
  234|       |
  235|       |  // The ID should be the same given the same interceptor object.
  236|      0|  NSString *interceptorID = [NSString stringWithFormat:@"%@%p", kGULAppDelegatePrefix, interceptor];
  237|      0|  if (!interceptorID.length) {
  238|      0|    GULLogError(kGULLoggerSwizzler, NO,
  239|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  240|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling002],
  241|      0|                @"AppDelegateProxy cannot create Interceptor ID.");
  242|      0|    return nil;
  243|      0|  }
  244|      0|  GULZeroingWeakContainer *weakObject = [[GULZeroingWeakContainer alloc] init];
  245|      0|  weakObject.object = interceptor;
  246|      0|  [GULAppDelegateSwizzler interceptors][interceptorID] = weakObject;
  247|      0|  return interceptorID;
  248|      0|}
  249|       |
  250|      0|+ (void)unregisterAppDelegateInterceptorWithID:(GULAppDelegateInterceptorID)interceptorID {
  251|      0|  NSAssert(interceptorID, @"AppDelegateProxy cannot unregister nil interceptor ID.");
  252|      0|  NSAssert(((NSString *)interceptorID).length != 0,
  253|      0|           @"AppDelegateProxy cannot unregister empty interceptor ID.");
  254|       |
  255|      0|  if (!interceptorID) {
  256|      0|    GULLogError(kGULLoggerSwizzler, NO,
  257|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  258|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling003],
  259|      0|                @"AppDelegateProxy cannot unregister empty interceptor ID.");
  260|      0|    return;
  261|      0|  }
  262|       |
  263|      0|  GULZeroingWeakContainer *weakContainer = [GULAppDelegateSwizzler interceptors][interceptorID];
  264|      0|  if (!weakContainer.object) {
  265|      0|    GULLogError(kGULLoggerSwizzler, NO,
  266|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  267|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling004],
  268|      0|                @"AppDelegateProxy cannot unregister interceptor that was not registered. "
  269|      0|                 "Interceptor ID %@",
  270|      0|                interceptorID);
  271|      0|    return;
  272|      0|  }
  273|       |
  274|      0|  [[GULAppDelegateSwizzler interceptors] removeObjectForKey:interceptorID];
  275|      0|}
  276|       |
  277|      0|+ (void)proxyOriginalDelegate {
  278|      0|  if ([GULAppEnvironmentUtil isAppExtension]) {
  279|      0|    return;
  280|      0|  }
  281|       |
  282|      0|  dispatch_once(&sProxyAppDelegateOnceToken, ^{
  283|      0|    id<GULApplicationDelegate> originalDelegate =
  284|      0|        [GULAppDelegateSwizzler sharedApplication].delegate;
  285|      0|    [GULAppDelegateSwizzler proxyAppDelegate:originalDelegate];
  286|      0|  });
  287|      0|}
  288|       |
  289|      0|+ (void)proxyOriginalDelegateIncludingAPNSMethods {
  290|      0|  if ([GULAppEnvironmentUtil isAppExtension]) {
  291|      0|    return;
  292|      0|  }
  293|       |
  294|      0|  [self proxyOriginalDelegate];
  295|       |
  296|      0|  dispatch_once(&sProxyAppDelegateRemoteNotificationOnceToken, ^{
  297|      0|    id<GULApplicationDelegate> appDelegate = [GULAppDelegateSwizzler sharedApplication].delegate;
  298|       |
  299|      0|    NSMutableDictionary *realImplementationsBySelector =
  300|      0|        [objc_getAssociatedObject(appDelegate, &kGULRealIMPBySelectorKey) mutableCopy];
  301|       |
  302|      0|    [self proxyRemoteNotificationsMethodsWithAppDelegateSubClass:gAppDelegateSubclass
  303|      0|                                                       realClass:gOriginalAppDelegateClass
  304|      0|                                                     appDelegate:appDelegate
  305|      0|                                   realImplementationsBySelector:realImplementationsBySelector];
  306|       |
  307|      0|    objc_setAssociatedObject(appDelegate, &kGULRealIMPBySelectorKey,
  308|      0|                             [realImplementationsBySelector copy], OBJC_ASSOCIATION_RETAIN);
  309|      0|    [self reassignAppDelegate];
  310|      0|  });
  311|      0|}
  312|       |
  313|       |#pragma mark - Create proxy
  314|       |
  315|      0|+ (GULApplication *)sharedApplication {
  316|      0|  if ([GULAppEnvironmentUtil isAppExtension]) {
  317|      0|    return nil;
  318|      0|  }
  319|      0|  id sharedApplication = nil;
  320|      0|  Class uiApplicationClass = NSClassFromString(kGULApplicationClassName);
  321|      0|  if (uiApplicationClass &&
  322|      0|      [uiApplicationClass respondsToSelector:(NSSelectorFromString(@"sharedApplication"))]) {
  323|      0|    sharedApplication = [uiApplicationClass sharedApplication];
  324|      0|  }
  325|      0|  return sharedApplication;
  326|      0|}
  327|       |
  328|       |#pragma mark - Override default methods
  329|       |
  330|       |/** Creates a new subclass of the class of the given object and sets the isa value of the given
  331|       | *  object to the new subclass. Additionally this copies methods to that new subclass that allow us
  332|       | *  to intercept UIApplicationDelegate methods. This is better known as isa swizzling.
  333|       | *
  334|       | *  @param appDelegate The object to which you want to isa swizzle. This has to conform to the
  335|       | *      UIApplicationDelegate subclass.
  336|       | *  @return Returns the new subclass.
  337|       | */
  338|      0|+ (nullable Class)createSubclassWithObject:(id<GULApplicationDelegate>)appDelegate {
  339|      0|  Class realClass = [appDelegate class];
  340|       |
  341|       |  // Create GUL_<RealAppDelegate>_<UUID>
  342|      0|  NSString *classNameWithPrefix =
  343|      0|      [kGULAppDelegatePrefix stringByAppendingString:NSStringFromClass(realClass)];
  344|      0|  NSString *newClassName =
  345|      0|      [NSString stringWithFormat:@"%@-%@", classNameWithPrefix, [NSUUID UUID].UUIDString];
  346|       |
  347|      0|  if (NSClassFromString(newClassName)) {
  348|      0|    GULLogError(kGULLoggerSwizzler, NO,
  349|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  350|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling005],
  351|      0|                @"Cannot create a proxy for App Delegate. Subclass already exists. Original Class: "
  352|      0|                @"%@, subclass: %@",
  353|      0|                NSStringFromClass(realClass), newClassName);
  354|      0|    return nil;
  355|      0|  }
  356|       |
  357|       |  // Register the new class as subclass of the real one. Do not allocate more than the real class
  358|       |  // size.
  359|      0|  Class appDelegateSubClass = objc_allocateClassPair(realClass, newClassName.UTF8String, 0);
  360|      0|  if (appDelegateSubClass == Nil) {
  361|      0|    GULLogError(kGULLoggerSwizzler, NO,
  362|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  363|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling006],
  364|      0|                @"Cannot create a proxy for App Delegate. Subclass already exists. Original Class: "
  365|      0|                @"%@, subclass: Nil",
  366|      0|                NSStringFromClass(realClass));
  367|      0|    return nil;
  368|      0|  }
  369|       |
  370|      0|  NSMutableDictionary<NSString *, NSValue *> *realImplementationsBySelector =
  371|      0|      [[NSMutableDictionary alloc] init];
  372|       |
  373|       |  // For application:continueUserActivity:restorationHandler:
  374|      0|  SEL continueUserActivitySEL = @selector(application:continueUserActivity:restorationHandler:);
  375|      0|  [self proxyDestinationSelector:continueUserActivitySEL
  376|      0|      implementationsFromSourceSelector:continueUserActivitySEL
  377|      0|                              fromClass:[GULAppDelegateSwizzler class]
  378|      0|                                toClass:appDelegateSubClass
  379|      0|                              realClass:realClass
  380|      0|       storeDestinationImplementationTo:realImplementationsBySelector];
  381|       |
  382|      0|#if TARGET_OS_IOS || TARGET_OS_TV
  383|       |  // Add the following methods from GULAppDelegate class, and store the real implementation so it
  384|       |  // can forward to the real one.
  385|       |  // For application:openURL:options:
  386|      0|  SEL applicationOpenURLOptionsSEL = @selector(application:openURL:options:);
  387|      0|  if ([appDelegate respondsToSelector:applicationOpenURLOptionsSEL]) {
  388|       |    // Only add the application:openURL:options: method if the original AppDelegate implements it.
  389|       |    // This fixes a bug if an app only implements application:openURL:sourceApplication:annotation:
  390|       |    // (if we add the `options` method, iOS sees that one exists and does not call the
  391|       |    // `sourceApplication` method, which in this case is the only one the app implements).
  392|       |
  393|      0|    [self proxyDestinationSelector:applicationOpenURLOptionsSEL
  394|      0|        implementationsFromSourceSelector:applicationOpenURLOptionsSEL
  395|      0|                                fromClass:[GULAppDelegateSwizzler class]
  396|      0|                                  toClass:appDelegateSubClass
  397|      0|                                realClass:realClass
  398|      0|         storeDestinationImplementationTo:realImplementationsBySelector];
  399|      0|  }
  400|       |
  401|       |  // For application:handleEventsForBackgroundURLSession:completionHandler:
  402|      0|  SEL handleEventsForBackgroundURLSessionSEL = @selector(application:
  403|      0|                                 handleEventsForBackgroundURLSession:completionHandler:);
  404|      0|  [self proxyDestinationSelector:handleEventsForBackgroundURLSessionSEL
  405|      0|      implementationsFromSourceSelector:handleEventsForBackgroundURLSessionSEL
  406|      0|                              fromClass:[GULAppDelegateSwizzler class]
  407|      0|                                toClass:appDelegateSubClass
  408|      0|                              realClass:realClass
  409|      0|       storeDestinationImplementationTo:realImplementationsBySelector];
  410|      0|#endif  // TARGET_OS_IOS || TARGET_OS_TV
  411|       |
  412|      0|#if TARGET_OS_IOS
  413|       |  // For application:openURL:sourceApplication:annotation:
  414|      0|  SEL openURLSourceApplicationAnnotationSEL = @selector(application:
  415|      0|                                                            openURL:sourceApplication:annotation:);
  416|       |
  417|      0|  [self proxyDestinationSelector:openURLSourceApplicationAnnotationSEL
  418|      0|      implementationsFromSourceSelector:openURLSourceApplicationAnnotationSEL
  419|      0|                              fromClass:[GULAppDelegateSwizzler class]
  420|      0|                                toClass:appDelegateSubClass
  421|      0|                              realClass:realClass
  422|      0|       storeDestinationImplementationTo:realImplementationsBySelector];
  423|      0|#endif  // TARGET_OS_IOS
  424|       |
  425|       |  // Override the description too so the custom class name will not show up.
  426|      0|  [GULAppDelegateSwizzler addInstanceMethodWithDestinationSelector:@selector(description)
  427|      0|                              withImplementationFromSourceSelector:@selector(fakeDescription)
  428|      0|                                                         fromClass:[self class]
  429|      0|                                                           toClass:appDelegateSubClass];
  430|       |
  431|       |  // Store original implementations to a fake property of the original delegate.
  432|      0|  objc_setAssociatedObject(appDelegate, &kGULRealIMPBySelectorKey,
  433|      0|                           [realImplementationsBySelector copy], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  434|      0|  objc_setAssociatedObject(appDelegate, &kGULRealClassKey, realClass,
  435|      0|                           OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  436|       |
  437|       |  // The subclass size has to be exactly the same size with the original class size. The subclass
  438|       |  // cannot have more ivars/properties than its superclass since it will cause an offset in memory
  439|       |  // that can lead to overwriting the isa of an object in the next frame.
  440|      0|  if (class_getInstanceSize(realClass) != class_getInstanceSize(appDelegateSubClass)) {
  441|      0|    GULLogError(kGULLoggerSwizzler, NO,
  442|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  443|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling007],
  444|      0|                @"Cannot create subclass of App Delegate, because the created subclass is not the "
  445|      0|                @"same size. %@",
  446|      0|                NSStringFromClass(realClass));
  447|      0|    NSAssert(NO, @"Classes must be the same size to swizzle isa");
  448|      0|    return nil;
  449|      0|  }
  450|       |
  451|       |  // Make the newly created class to be the subclass of the real App Delegate class.
  452|      0|  objc_registerClassPair(appDelegateSubClass);
  453|      0|  if (object_setClass(appDelegate, appDelegateSubClass)) {
  454|      0|    GULLogDebug(kGULLoggerSwizzler, NO,
  455|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  456|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling008],
  457|      0|                @"Successfully created App Delegate Proxy automatically. To disable the "
  458|      0|                @"proxy, set the flag %@ to NO (Boolean) in the Info.plist",
  459|      0|                [GULAppDelegateSwizzler correctAppDelegateProxyKey]);
  460|      0|  }
  461|       |
  462|      0|  return appDelegateSubClass;
  463|      0|}
  464|       |
  465|       |+ (void)proxyRemoteNotificationsMethodsWithAppDelegateSubClass:(Class)appDelegateSubClass
  466|       |                                                     realClass:(Class)realClass
  467|       |                                                   appDelegate:(id)appDelegate
  468|       |                                 realImplementationsBySelector:
  469|      0|                                     (NSMutableDictionary *)realImplementationsBySelector {
  470|      0|  if (realClass == nil || appDelegateSubClass == nil || appDelegate == nil ||
  471|      0|      realImplementationsBySelector == nil) {
  472|       |    // The App Delegate has not been swizzled.
  473|      0|    return;
  474|      0|  }
  475|       |
  476|       |  // For application:didRegisterForRemoteNotificationsWithDeviceToken:
  477|      0|  SEL didRegisterForRemoteNotificationsSEL =
  478|      0|      NSSelectorFromString(kGULDidRegisterForRemoteNotificationsSEL);
  479|      0|  SEL didRegisterForRemoteNotificationsDonorSEL = @selector(application:
  480|      0|                 donor_didRegisterForRemoteNotificationsWithDeviceToken:);
  481|       |
  482|      0|  [self proxyDestinationSelector:didRegisterForRemoteNotificationsSEL
  483|      0|      implementationsFromSourceSelector:didRegisterForRemoteNotificationsDonorSEL
  484|      0|                              fromClass:[GULAppDelegateSwizzler class]
  485|      0|                                toClass:appDelegateSubClass
  486|      0|                              realClass:realClass
  487|      0|       storeDestinationImplementationTo:realImplementationsBySelector];
  488|       |
  489|       |  // For application:didFailToRegisterForRemoteNotificationsWithError:
  490|      0|  SEL didFailToRegisterForRemoteNotificationsSEL =
  491|      0|      NSSelectorFromString(kGULDidFailToRegisterForRemoteNotificationsSEL);
  492|      0|  SEL didFailToRegisterForRemoteNotificationsDonorSEL = @selector(application:
  493|      0|                       donor_didFailToRegisterForRemoteNotificationsWithError:);
  494|       |
  495|      0|  [self proxyDestinationSelector:didFailToRegisterForRemoteNotificationsSEL
  496|      0|      implementationsFromSourceSelector:didFailToRegisterForRemoteNotificationsDonorSEL
  497|      0|                              fromClass:[GULAppDelegateSwizzler class]
  498|      0|                                toClass:appDelegateSubClass
  499|      0|                              realClass:realClass
  500|      0|       storeDestinationImplementationTo:realImplementationsBySelector];
  501|       |
  502|       |  // For application:didReceiveRemoteNotification:
  503|      0|  SEL didReceiveRemoteNotificationSEL = NSSelectorFromString(kGULDidReceiveRemoteNotificationSEL);
  504|      0|  SEL didReceiveRemoteNotificationDonotSEL = @selector(application:
  505|      0|                                donor_didReceiveRemoteNotification:);
  506|       |
  507|      0|  [self proxyDestinationSelector:didReceiveRemoteNotificationSEL
  508|      0|      implementationsFromSourceSelector:didReceiveRemoteNotificationDonotSEL
  509|      0|                              fromClass:[GULAppDelegateSwizzler class]
  510|      0|                                toClass:appDelegateSubClass
  511|      0|                              realClass:realClass
  512|      0|       storeDestinationImplementationTo:realImplementationsBySelector];
  513|       |
  514|       |  // For application:didReceiveRemoteNotification:fetchCompletionHandler:
  515|      0|#if !TARGET_OS_WATCH && !TARGET_OS_OSX
  516|      0|  SEL didReceiveRemoteNotificationWithCompletionSEL =
  517|      0|      NSSelectorFromString(kGULDidReceiveRemoteNotificationWithCompletionSEL);
  518|      0|  SEL didReceiveRemoteNotificationWithCompletionDonorSEL =
  519|      0|      @selector(application:donor_didReceiveRemoteNotification:fetchCompletionHandler:);
  520|      0|  if ([appDelegate respondsToSelector:didReceiveRemoteNotificationWithCompletionSEL]) {
  521|       |    // Only add the application:didReceiveRemoteNotification:fetchCompletionHandler: method if
  522|       |    // the original AppDelegate implements it.
  523|       |    // This fixes a bug if an app only implements application:didReceiveRemoteNotification:
  524|       |    // (if we add the method with completion, iOS sees that one exists and does not call
  525|       |    // the method without the completion, which in this case is the only one the app implements).
  526|       |
  527|      0|    [self proxyDestinationSelector:didReceiveRemoteNotificationWithCompletionSEL
  528|      0|        implementationsFromSourceSelector:didReceiveRemoteNotificationWithCompletionDonorSEL
  529|      0|                                fromClass:[GULAppDelegateSwizzler class]
  530|      0|                                  toClass:appDelegateSubClass
  531|      0|                                realClass:realClass
  532|      0|         storeDestinationImplementationTo:realImplementationsBySelector];
  533|      0|  }
  534|      0|#endif  // !TARGET_OS_WATCH && !TARGET_OS_OSX
  535|      0|}
  536|       |
  537|       |/// We have to do this to invalidate the cache that caches the original respondsToSelector of
  538|       |/// openURL handlers. Without this, it won't call the default implementations because the system
  539|       |/// checks and caches them.
  540|       |/// Register KVO only once. Otherwise, the observing method will be called as many times as
  541|       |/// being registered.
  542|      0|+ (void)reassignAppDelegate {
  543|      0|#if !TARGET_OS_WATCH
  544|      0|  id<GULApplicationDelegate> delegate = [self sharedApplication].delegate;
  545|      0|  [self sharedApplication].delegate = nil;
  546|      0|  [self sharedApplication].delegate = delegate;
  547|      0|  gOriginalAppDelegate = delegate;
  548|      0|  [[GULAppDelegateObserver sharedInstance] observeUIApplication];
  549|      0|#endif
  550|      0|}
  551|       |
  552|       |#pragma mark - Helper methods
  553|       |
  554|      0|+ (GULMutableDictionary *)interceptors {
  555|      0|  static dispatch_once_t onceToken;
  556|      0|  static GULMutableDictionary *sInterceptors;
  557|      0|  dispatch_once(&onceToken, ^{
  558|      0|    sInterceptors = [[GULMutableDictionary alloc] init];
  559|      0|  });
  560|      0|  return sInterceptors;
  561|      0|}
  562|       |
  563|      0|+ (nullable NSValue *)originalImplementationForSelector:(SEL)selector object:(id)object {
  564|      0|  NSDictionary *realImplementationBySelector =
  565|      0|      objc_getAssociatedObject(object, &kGULRealIMPBySelectorKey);
  566|      0|  return realImplementationBySelector[NSStringFromSelector(selector)];
  567|      0|}
  568|       |
  569|       |+ (void)proxyDestinationSelector:(SEL)destinationSelector
  570|       |    implementationsFromSourceSelector:(SEL)sourceSelector
  571|       |                            fromClass:(Class)sourceClass
  572|       |                              toClass:(Class)destinationClass
  573|       |                            realClass:(Class)realClass
  574|       |     storeDestinationImplementationTo:
  575|      0|         (NSMutableDictionary<NSString *, NSValue *> *)destinationImplementationsBySelector {
  576|      0|  [self addInstanceMethodWithDestinationSelector:destinationSelector
  577|      0|            withImplementationFromSourceSelector:sourceSelector
  578|      0|                                       fromClass:sourceClass
  579|      0|                                         toClass:destinationClass];
  580|      0|  IMP sourceImplementation =
  581|      0|      [GULAppDelegateSwizzler implementationOfMethodSelector:destinationSelector
  582|      0|                                                   fromClass:realClass];
  583|      0|  NSValue *sourceImplementationPointer = [NSValue valueWithPointer:sourceImplementation];
  584|       |
  585|      0|  NSString *destinationSelectorString = NSStringFromSelector(destinationSelector);
  586|      0|  destinationImplementationsBySelector[destinationSelectorString] = sourceImplementationPointer;
  587|      0|}
  588|       |
  589|       |/** Copies a method identified by the methodSelector from one class to the other. After this method
  590|       | *  is called, performing [toClassInstance methodSelector] will be similar to calling
  591|       | *  [fromClassInstance methodSelector]. This method does nothing if toClass already has a method
  592|       | *  identified by methodSelector.
  593|       | *
  594|       | *  @param methodSelector The SEL that identifies both the method on the fromClass as well as the
  595|       | *      one on the toClass.
  596|       | *  @param fromClass The class from which a method is sourced.
  597|       | *  @param toClass The class to which the method is added. If the class already has a method with
  598|       | *      the same selector, this has no effect.
  599|       | */
  600|       |+ (void)addInstanceMethodWithSelector:(SEL)methodSelector
  601|       |                            fromClass:(Class)fromClass
  602|      0|                              toClass:(Class)toClass {
  603|      0|  [self addInstanceMethodWithDestinationSelector:methodSelector
  604|      0|            withImplementationFromSourceSelector:methodSelector
  605|      0|                                       fromClass:fromClass
  606|      0|                                         toClass:toClass];
  607|      0|}
  608|       |
  609|       |/** Copies a method identified by the sourceSelector from the fromClass as a method for the
  610|       | *  destinationSelector on the toClass. After this method is called, performing
  611|       | *  [toClassInstance destinationSelector] will be similar to calling
  612|       | *  [fromClassInstance sourceSelector]. This method does nothing if toClass already has a method
  613|       | *  identified by destinationSelector.
  614|       | *
  615|       | *  @param destinationSelector The SEL that identifies the method on the toClass.
  616|       | *  @param sourceSelector The SEL that identifies the method on the fromClass.
  617|       | *  @param fromClass The class from which a method is sourced.
  618|       | *  @param toClass The class to which the method is added. If the class already has a method with
  619|       | *      the same selector, this has no effect.
  620|       | */
  621|       |+ (void)addInstanceMethodWithDestinationSelector:(SEL)destinationSelector
  622|       |            withImplementationFromSourceSelector:(SEL)sourceSelector
  623|       |                                       fromClass:(Class)fromClass
  624|      0|                                         toClass:(Class)toClass {
  625|      0|  Method method = class_getInstanceMethod(fromClass, sourceSelector);
  626|      0|  IMP methodIMP = method_getImplementation(method);
  627|      0|  const char *types = method_getTypeEncoding(method);
  628|      0|  if (!class_addMethod(toClass, destinationSelector, methodIMP, types)) {
  629|      0|    GULLogWarning(kGULLoggerSwizzler, NO,
  630|      0|                  [NSString stringWithFormat:@"I-SWZ%06ld",
  631|      0|                                             (long)kGULSwizzlerMessageCodeAppDelegateSwizzling009],
  632|      0|                  @"Cannot copy method to destination selector %@ as it already exists",
  633|      0|                  NSStringFromSelector(destinationSelector));
  634|      0|  }
  635|      0|}
  636|       |
  637|       |/** Gets the IMP of the instance method on the class identified by the selector.
  638|       | *
  639|       | *  @param selector The selector of which the IMP is to be fetched.
  640|       | *  @param aClass The class from which the IMP is to be fetched.
  641|       | *  @return The IMP of the instance method identified by selector and aClass.
  642|       | */
  643|      0|+ (IMP)implementationOfMethodSelector:(SEL)selector fromClass:(Class)aClass {
  644|      0|  Method aMethod = class_getInstanceMethod(aClass, selector);
  645|      0|  return method_getImplementation(aMethod);
  646|      0|}
  647|       |
  648|       |/** Enumerates through all the interceptors and if they respond to a given selector, executes a
  649|       | *  GULAppDelegateInterceptorCallback with the interceptor.
  650|       | *
  651|       | *  @param methodSelector The SEL to check if an interceptor responds to.
  652|       | *  @param callback the GULAppDelegateInterceptorCallback.
  653|       | */
  654|       |+ (void)notifyInterceptorsWithMethodSelector:(SEL)methodSelector
  655|      0|                                    callback:(GULAppDelegateInterceptorCallback)callback {
  656|      0|  if (!callback) {
  657|      0|    return;
  658|      0|  }
  659|       |
  660|      0|  NSDictionary *interceptors = [GULAppDelegateSwizzler interceptors].dictionary;
  661|      0|  [interceptors enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
  662|      0|    GULZeroingWeakContainer *interceptorContainer = obj;
  663|      0|    id interceptor = interceptorContainer.object;
  664|      0|    if (!interceptor) {
  665|      0|      GULLogWarning(
  666|      0|          kGULLoggerSwizzler, NO,
  667|      0|          [NSString
  668|      0|              stringWithFormat:@"I-SWZ%06ld", (long)kGULSwizzlerMessageCodeAppDelegateSwizzling010],
  669|      0|          @"AppDelegateProxy cannot find interceptor with ID %@. Removing the interceptor.", key);
  670|      0|      [[GULAppDelegateSwizzler interceptors] removeObjectForKey:key];
  671|      0|      return;
  672|      0|    }
  673|      0|    if ([interceptor respondsToSelector:methodSelector]) {
  674|      0|      callback(interceptor);
  675|      0|    }
  676|      0|  }];
  677|      0|}
  678|       |
  679|       |// The methods below are donor methods which are added to the dynamic subclass of the App Delegate.
  680|       |// They are called within the scope of the real App Delegate so |self| does not refer to the
  681|       |// GULAppDelegateSwizzler instance but the real App Delegate instance.
  682|       |
  683|       |#pragma mark - [Donor Methods] Overridden instance description method
  684|       |
  685|      0|- (NSString *)fakeDescription {
  686|      0|  Class realClass = objc_getAssociatedObject(self, &kGULRealClassKey);
  687|      0|  return [NSString stringWithFormat:@"<%@: %p>", realClass, self];
  688|      0|}
  689|       |
  690|       |#pragma mark - [Donor Methods] URL overridden handler methods
  691|       |#if TARGET_OS_IOS || TARGET_OS_TV
  692|       |
  693|       |- (BOOL)application:(GULApplication *)application
  694|       |            openURL:(NSURL *)url
  695|      0|            options:(NSDictionary<NSString *, id> *)options {
  696|      0|  SEL methodSelector = @selector(application:openURL:options:);
  697|       |  // Call the real implementation if the real App Delegate has any.
  698|      0|  NSValue *openURLIMPPointer =
  699|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  700|      0|  GULRealOpenURLOptionsIMP openURLOptionsIMP = [openURLIMPPointer pointerValue];
  701|       |
  702|      0|  __block BOOL returnedValue = NO;
  703|       |
  704|       |// This is needed to for the library to be warning free on iOS versions < 9.
  705|      0|#pragma clang diagnostic push
  706|      0|#pragma clang diagnostic ignored "-Wunguarded-availability"
  707|      0|  [GULAppDelegateSwizzler
  708|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  709|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  710|      0|                                    returnedValue |= [interceptor application:application
  711|      0|                                                                      openURL:url
  712|      0|                                                                      options:options];
  713|      0|                                  }];
  714|      0|#pragma clang diagnostic pop
  715|      0|  if (openURLOptionsIMP) {
  716|      0|    returnedValue |= openURLOptionsIMP(self, methodSelector, application, url, options);
  717|      0|  }
  718|      0|  return returnedValue;
  719|      0|}
  720|       |
  721|       |#endif  // TARGET_OS_IOS || TARGET_OS_TV
  722|       |
  723|       |#if TARGET_OS_IOS
  724|       |
  725|       |- (BOOL)application:(GULApplication *)application
  726|       |              openURL:(NSURL *)url
  727|       |    sourceApplication:(NSString *)sourceApplication
  728|      0|           annotation:(id)annotation {
  729|      0|  SEL methodSelector = @selector(application:openURL:sourceApplication:annotation:);
  730|       |
  731|       |  // Call the real implementation if the real App Delegate has any.
  732|      0|  NSValue *openURLSourceAppAnnotationIMPPointer =
  733|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  734|      0|  GULRealOpenURLSourceApplicationAnnotationIMP openURLSourceApplicationAnnotationIMP =
  735|      0|      [openURLSourceAppAnnotationIMPPointer pointerValue];
  736|       |
  737|      0|  __block BOOL returnedValue = NO;
  738|      0|  [GULAppDelegateSwizzler
  739|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  740|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  741|      0|#pragma clang diagnostic push
  742|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  743|      0|                                    returnedValue |= [interceptor application:application
  744|      0|                                                                      openURL:url
  745|      0|                                                            sourceApplication:sourceApplication
  746|      0|                                                                   annotation:annotation];
  747|      0|#pragma clang diagnostic pop
  748|      0|                                  }];
  749|      0|  if (openURLSourceApplicationAnnotationIMP) {
  750|      0|    returnedValue |= openURLSourceApplicationAnnotationIMP(self, methodSelector, application, url,
  751|      0|                                                           sourceApplication, annotation);
  752|      0|  }
  753|      0|  return returnedValue;
  754|      0|}
  755|       |
  756|       |#endif  // TARGET_OS_IOS
  757|       |
  758|       |#pragma mark - [Donor Methods] Network overridden handler methods
  759|       |
  760|       |#if TARGET_OS_IOS || TARGET_OS_TV
  761|       |
  762|       |#pragma clang diagnostic push
  763|       |#pragma clang diagnostic ignored "-Wstrict-prototypes"
  764|       |- (void)application:(GULApplication *)application
  765|       |    handleEventsForBackgroundURLSession:(NSString *)identifier
  766|      0|                      completionHandler:(void (^)())completionHandler API_AVAILABLE(ios(7.0)) {
  767|      0|#pragma clang diagnostic pop
  768|      0|  SEL methodSelector = @selector(application:
  769|      0|         handleEventsForBackgroundURLSession:completionHandler:);
  770|      0|  NSValue *handleBackgroundSessionPointer =
  771|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  772|      0|  GULRealHandleEventsForBackgroundURLSessionIMP handleBackgroundSessionIMP =
  773|      0|      [handleBackgroundSessionPointer pointerValue];
  774|       |
  775|       |  // Notify interceptors.
  776|      0|  [GULAppDelegateSwizzler
  777|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  778|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  779|      0|                                    [interceptor application:application
  780|      0|                                        handleEventsForBackgroundURLSession:identifier
  781|      0|                                                          completionHandler:completionHandler];
  782|      0|                                  }];
  783|       |  // Call the real implementation if the real App Delegate has any.
  784|      0|  if (handleBackgroundSessionIMP) {
  785|      0|    handleBackgroundSessionIMP(self, methodSelector, application, identifier, completionHandler);
  786|      0|  }
  787|      0|}
  788|       |
  789|       |#endif  // TARGET_OS_IOS || TARGET_OS_TV
  790|       |
  791|       |#pragma mark - [Donor Methods] User Activities overridden handler methods
  792|       |
  793|       |- (BOOL)application:(GULApplication *)application
  794|       |    continueUserActivity:(NSUserActivity *)userActivity
  795|      0|      restorationHandler:(void (^)(NSArray *restorableObjects))restorationHandler {
  796|      0|  SEL methodSelector = @selector(application:continueUserActivity:restorationHandler:);
  797|      0|  NSValue *continueUserActivityIMPPointer =
  798|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  799|      0|  GULRealContinueUserActivityIMP continueUserActivityIMP =
  800|      0|      continueUserActivityIMPPointer.pointerValue;
  801|       |
  802|      0|  __block BOOL returnedValue = NO;
  803|      0|#if !TARGET_OS_WATCH
  804|      0|  [GULAppDelegateSwizzler
  805|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  806|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  807|      0|                                    returnedValue |= [interceptor application:application
  808|      0|                                                         continueUserActivity:userActivity
  809|      0|                                                           restorationHandler:restorationHandler];
  810|      0|                                  }];
  811|      0|#endif
  812|       |  // Call the real implementation if the real App Delegate has any.
  813|      0|  if (continueUserActivityIMP) {
  814|      0|    returnedValue |= continueUserActivityIMP(self, methodSelector, application, userActivity,
  815|      0|                                             restorationHandler);
  816|      0|  }
  817|      0|  return returnedValue;
  818|      0|}
  819|       |
  820|       |#pragma mark - [Donor Methods] Remote Notifications
  821|       |
  822|       |- (void)application:(GULApplication *)application
  823|      0|    donor_didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {
  824|      0|  SEL methodSelector = NSSelectorFromString(kGULDidRegisterForRemoteNotificationsSEL);
  825|       |
  826|      0|  NSValue *didRegisterForRemoteNotificationsIMPPointer =
  827|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  828|      0|  GULRealDidRegisterForRemoteNotificationsIMP didRegisterForRemoteNotificationsIMP =
  829|      0|      [didRegisterForRemoteNotificationsIMPPointer pointerValue];
  830|       |
  831|       |  // Notify interceptors.
  832|      0|  [GULAppDelegateSwizzler
  833|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  834|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  835|      0|                                    NSInvocation *invocation = [GULAppDelegateSwizzler
  836|      0|                                        appDelegateInvocationForSelector:methodSelector];
  837|      0|                                    [invocation setTarget:interceptor];
  838|      0|                                    [invocation setSelector:methodSelector];
  839|      0|                                    [invocation setArgument:(void *)(&application) atIndex:2];
  840|      0|                                    [invocation setArgument:(void *)(&deviceToken) atIndex:3];
  841|      0|                                    [invocation invoke];
  842|      0|                                  }];
  843|       |  // Call the real implementation if the real App Delegate has any.
  844|      0|  if (didRegisterForRemoteNotificationsIMP) {
  845|      0|    didRegisterForRemoteNotificationsIMP(self, methodSelector, application, deviceToken);
  846|      0|  }
  847|      0|}
  848|       |
  849|       |- (void)application:(GULApplication *)application
  850|      0|    donor_didFailToRegisterForRemoteNotificationsWithError:(NSError *)error {
  851|      0|  SEL methodSelector = NSSelectorFromString(kGULDidFailToRegisterForRemoteNotificationsSEL);
  852|      0|  NSValue *didFailToRegisterForRemoteNotificationsIMPPointer =
  853|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  854|      0|  GULRealDidFailToRegisterForRemoteNotificationsIMP didFailToRegisterForRemoteNotificationsIMP =
  855|      0|      [didFailToRegisterForRemoteNotificationsIMPPointer pointerValue];
  856|       |
  857|       |  // Notify interceptors.
  858|      0|  [GULAppDelegateSwizzler
  859|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  860|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  861|      0|                                    NSInvocation *invocation = [GULAppDelegateSwizzler
  862|      0|                                        appDelegateInvocationForSelector:methodSelector];
  863|      0|                                    [invocation setTarget:interceptor];
  864|      0|                                    [invocation setSelector:methodSelector];
  865|      0|                                    [invocation setArgument:(void *)(&application) atIndex:2];
  866|      0|                                    [invocation setArgument:(void *)(&error) atIndex:3];
  867|      0|                                    [invocation invoke];
  868|      0|                                  }];
  869|       |  // Call the real implementation if the real App Delegate has any.
  870|      0|  if (didFailToRegisterForRemoteNotificationsIMP) {
  871|      0|    didFailToRegisterForRemoteNotificationsIMP(self, methodSelector, application, error);
  872|      0|  }
  873|      0|}
  874|       |
  875|       |#if !TARGET_OS_WATCH && !TARGET_OS_OSX
  876|       |- (void)application:(GULApplication *)application
  877|       |    donor_didReceiveRemoteNotification:(NSDictionary *)userInfo
  878|      0|                fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {
  879|      0|  SEL methodSelector = NSSelectorFromString(kGULDidReceiveRemoteNotificationWithCompletionSEL);
  880|      0|  NSValue *didReceiveRemoteNotificationWithCompletionIMPPointer =
  881|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  882|      0|  GULRealDidReceiveRemoteNotificationWithCompletionIMP
  883|      0|      didReceiveRemoteNotificationWithCompletionIMP =
  884|      0|          [didReceiveRemoteNotificationWithCompletionIMPPointer pointerValue];
  885|       |
  886|      0|  dispatch_group_t __block callbackGroup = dispatch_group_create();
  887|      0|  NSMutableArray<NSNumber *> *__block fetchResults = [NSMutableArray array];
  888|       |
  889|      0|  void (^localCompletionHandler)(UIBackgroundFetchResult) =
  890|      0|      ^void(UIBackgroundFetchResult fetchResult) {
  891|      0|        [fetchResults addObject:[NSNumber numberWithInt:(int)fetchResult]];
  892|      0|        dispatch_group_leave(callbackGroup);
  893|      0|      };
  894|       |
  895|       |  // Notify interceptors.
  896|      0|  [GULAppDelegateSwizzler
  897|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  898|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  899|      0|                                    dispatch_group_enter(callbackGroup);
  900|       |
  901|      0|                                    NSInvocation *invocation = [GULAppDelegateSwizzler
  902|      0|                                        appDelegateInvocationForSelector:methodSelector];
  903|      0|                                    [invocation setTarget:interceptor];
  904|      0|                                    [invocation setSelector:methodSelector];
  905|      0|                                    [invocation setArgument:(void *)(&application) atIndex:2];
  906|      0|                                    [invocation setArgument:(void *)(&userInfo) atIndex:3];
  907|      0|                                    [invocation setArgument:(void *)(&localCompletionHandler)
  908|      0|                                                    atIndex:4];
  909|      0|                                    [invocation invoke];
  910|      0|                                  }];
  911|       |  // Call the real implementation if the real App Delegate has any.
  912|      0|  if (didReceiveRemoteNotificationWithCompletionIMP) {
  913|      0|    dispatch_group_enter(callbackGroup);
  914|       |
  915|      0|    didReceiveRemoteNotificationWithCompletionIMP(self, methodSelector, application, userInfo,
  916|      0|                                                  localCompletionHandler);
  917|      0|  }
  918|       |
  919|      0|  dispatch_group_notify(callbackGroup, dispatch_get_main_queue(), ^() {
  920|      0|    BOOL allFetchesFailed = YES;
  921|      0|    BOOL anyFetchHasNewData = NO;
  922|       |
  923|      0|    for (NSNumber *oneResult in fetchResults) {
  924|      0|      UIBackgroundFetchResult result = oneResult.intValue;
  925|       |
  926|      0|      switch (result) {
  927|      0|        case UIBackgroundFetchResultNoData:
  928|      0|          allFetchesFailed = NO;
  929|      0|          break;
  930|      0|        case UIBackgroundFetchResultNewData:
  931|      0|          allFetchesFailed = NO;
  932|      0|          anyFetchHasNewData = YES;
  933|      0|          break;
  934|      0|        case UIBackgroundFetchResultFailed:
  935|       |
  936|      0|          break;
  937|      0|      }
  938|      0|    }
  939|       |
  940|      0|    UIBackgroundFetchResult finalFetchResult = UIBackgroundFetchResultNoData;
  941|       |
  942|      0|    if (allFetchesFailed) {
  943|      0|      finalFetchResult = UIBackgroundFetchResultFailed;
  944|      0|    } else if (anyFetchHasNewData) {
  945|      0|      finalFetchResult = UIBackgroundFetchResultNewData;
  946|      0|    } else {
  947|      0|      finalFetchResult = UIBackgroundFetchResultNoData;
  948|      0|    }
  949|       |
  950|      0|    completionHandler(finalFetchResult);
  951|      0|  });
  952|      0|}
  953|       |#endif  // !TARGET_OS_WATCH && !TARGET_OS_OSX
  954|       |
  955|       |- (void)application:(GULApplication *)application
  956|      0|    donor_didReceiveRemoteNotification:(NSDictionary *)userInfo {
  957|      0|  SEL methodSelector = NSSelectorFromString(kGULDidReceiveRemoteNotificationSEL);
  958|      0|  NSValue *didReceiveRemoteNotificationIMPPointer =
  959|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  960|      0|  GULRealDidReceiveRemoteNotificationIMP didReceiveRemoteNotificationIMP =
  961|      0|      [didReceiveRemoteNotificationIMPPointer pointerValue];
  962|       |
  963|       |  // Notify interceptors.
  964|      0|#pragma clang diagnostic push
  965|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  966|      0|  [GULAppDelegateSwizzler
  967|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  968|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  969|      0|                                    NSInvocation *invocation = [GULAppDelegateSwizzler
  970|      0|                                        appDelegateInvocationForSelector:methodSelector];
  971|      0|                                    [invocation setTarget:interceptor];
  972|      0|                                    [invocation setSelector:methodSelector];
  973|      0|                                    [invocation setArgument:(void *)(&application) atIndex:2];
  974|      0|                                    [invocation setArgument:(void *)(&userInfo) atIndex:3];
  975|      0|                                    [invocation invoke];
  976|      0|                                  }];
  977|      0|#pragma clang diagnostic pop
  978|       |  // Call the real implementation if the real App Delegate has any.
  979|      0|  if (didReceiveRemoteNotificationIMP) {
  980|      0|    didReceiveRemoteNotificationIMP(self, methodSelector, application, userInfo);
  981|      0|  }
  982|      0|}
  983|       |
  984|      0|+ (nullable NSInvocation *)appDelegateInvocationForSelector:(SEL)selector {
  985|      0|  struct objc_method_description methodDescription =
  986|      0|      protocol_getMethodDescription(@protocol(GULApplicationDelegate), selector, NO, YES);
  987|      0|  if (methodDescription.types == NULL) {
  988|      0|    return nil;
  989|      0|  }
  990|       |
  991|      0|  NSMethodSignature *signature = [NSMethodSignature signatureWithObjCTypes:methodDescription.types];
  992|      0|  return [NSInvocation invocationWithMethodSignature:signature];
  993|      0|}
  994|       |
  995|      0|+ (void)proxyAppDelegate:(id<GULApplicationDelegate>)appDelegate {
  996|      0|  if (![appDelegate conformsToProtocol:@protocol(GULApplicationDelegate)]) {
  997|      0|    GULLogNotice(
  998|      0|        kGULLoggerSwizzler, NO,
  999|      0|        [NSString
 1000|      0|            stringWithFormat:@"I-SWZ%06ld",
 1001|      0|                             (long)kGULSwizzlerMessageCodeAppDelegateSwizzlingInvalidAppDelegate],
 1002|      0|        @"App Delegate does not conform to UIApplicationDelegate protocol. %@",
 1003|      0|        [GULAppDelegateSwizzler correctAlternativeWhenAppDelegateProxyNotCreated]);
 1004|      0|    return;
 1005|      0|  }
 1006|       |
 1007|      0|  id<GULApplicationDelegate> originalDelegate = appDelegate;
 1008|       |  // Do not create a subclass if it is not enabled.
 1009|      0|  if (![GULAppDelegateSwizzler isAppDelegateProxyEnabled]) {
 1010|      0|    GULLogNotice(kGULLoggerSwizzler, NO,
 1011|      0|                 [NSString stringWithFormat:@"I-SWZ%06ld",
 1012|      0|                                            (long)kGULSwizzlerMessageCodeAppDelegateSwizzling011],
 1013|      0|                 @"App Delegate Proxy is disabled. %@",
 1014|      0|                 [GULAppDelegateSwizzler correctAlternativeWhenAppDelegateProxyNotCreated]);
 1015|      0|    return;
 1016|      0|  }
 1017|       |  // Do not accept nil delegate.
 1018|      0|  if (!originalDelegate) {
 1019|      0|    GULLogError(kGULLoggerSwizzler, NO,
 1020|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
 1021|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling012],
 1022|      0|                @"Cannot create App Delegate Proxy because App Delegate instance is nil. %@",
 1023|      0|                [GULAppDelegateSwizzler correctAlternativeWhenAppDelegateProxyNotCreated]);
 1024|      0|    return;
 1025|      0|  }
 1026|       |
 1027|      0|  @try {
 1028|      0|    gOriginalAppDelegateClass = [originalDelegate class];
 1029|      0|    gAppDelegateSubclass = [self createSubclassWithObject:originalDelegate];
 1030|      0|    [self reassignAppDelegate];
 1031|      0|  } @catch (NSException *exception) {
 1032|      0|    GULLogError(kGULLoggerSwizzler, NO,
 1033|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
 1034|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling013],
 1035|      0|                @"Cannot create App Delegate Proxy. %@",
 1036|      0|                [GULAppDelegateSwizzler correctAlternativeWhenAppDelegateProxyNotCreated]);
 1037|      0|    return;
 1038|      0|  }
 1039|      0|}
 1040|       |
 1041|       |#pragma mark - Methods to print correct debug logs
 1042|       |
 1043|      0|+ (NSString *)correctAppDelegateProxyKey {
 1044|      0|  return NSClassFromString(@"FIRCore") ? kGULFirebaseAppDelegateProxyEnabledPlistKey
 1045|      0|                                       : kGULGoogleUtilitiesAppDelegateProxyEnabledPlistKey;
 1046|      0|}
 1047|       |
 1048|      0|+ (NSString *)correctAlternativeWhenAppDelegateProxyNotCreated {
 1049|      0|  return NSClassFromString(@"FIRCore")
 1050|      0|             ? @"To log deep link campaigns manually, call the methods in "
 1051|      0|               @"FIRAnalytics+AppDelegate.h."
 1052|      0|             : @"";
 1053|      0|}
 1054|       |
 1055|       |#pragma mark - Private Methods for Testing
 1056|       |
 1057|      0|+ (void)clearInterceptors {
 1058|      0|  [[self interceptors] removeAllObjects];
 1059|      0|}
 1060|       |
 1061|      0|+ (void)resetProxyOriginalDelegateOnceToken {
 1062|      0|  sProxyAppDelegateOnceToken = 0;
 1063|      0|  sProxyAppDelegateRemoteNotificationOnceToken = 0;
 1064|      0|}
 1065|       |
 1066|      0|+ (id<GULApplicationDelegate>)originalDelegate {
 1067|      0|  return gOriginalAppDelegate;
 1068|      0|}
 1069|       |
 1070|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/AppDelegateSwizzler/GULSceneDelegateSwizzler.m:
    1|       |// Copyright 2019 Google LLC
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import <TargetConditionals.h>
   16|       |
   17|       |#import "GoogleUtilities/AppDelegateSwizzler/Public/GoogleUtilities/GULSceneDelegateSwizzler.h"
   18|       |
   19|       |#import "GoogleUtilities/AppDelegateSwizzler/Internal/GULSceneDelegateSwizzler_Private.h"
   20|       |#import "GoogleUtilities/AppDelegateSwizzler/Public/GoogleUtilities/GULAppDelegateSwizzler.h"
   21|       |#import "GoogleUtilities/Common/GULLoggerCodes.h"
   22|       |#import "GoogleUtilities/Environment/Public/GoogleUtilities/GULAppEnvironmentUtil.h"
   23|       |#import "GoogleUtilities/Logger/Public/GoogleUtilities/GULLogger.h"
   24|       |#import "GoogleUtilities/Network/Public/GoogleUtilities/GULMutableDictionary.h"
   25|       |
   26|       |#import <objc/runtime.h>
   27|       |
   28|       |#if UISCENE_SUPPORTED
   29|       |API_AVAILABLE(ios(13.0), tvos(13.0))
   30|       |typedef void (*GULOpenURLContextsIMP)(id, SEL, UIScene *, NSSet<UIOpenURLContext *> *);
   31|       |
   32|       |API_AVAILABLE(ios(13.0), tvos(13.0))
   33|       |typedef void (^GULSceneDelegateInterceptorCallback)(id<UISceneDelegate>);
   34|       |
   35|       |// The strings below are the keys for associated objects.
   36|       |static char const *const kGULRealIMPBySelectorKey = "GUL_realIMPBySelector";
   37|       |static char const *const kGULRealClassKey = "GUL_realClass";
   38|       |#endif  // UISCENE_SUPPORTED
   39|       |
   40|       |static GULLoggerService kGULLoggerSwizzler = @"[GoogleUtilities/SceneDelegateSwizzler]";
   41|       |
   42|       |// Since Firebase SDKs also use this for app delegate proxying, in order to not be a breaking change
   43|       |// we disable App Delegate proxying when either of these two flags are set to NO.
   44|       |
   45|       |/** Plist key that allows Firebase developers to disable App and Scene Delegate Proxying. */
   46|       |static NSString *const kGULFirebaseSceneDelegateProxyEnabledPlistKey =
   47|       |    @"FirebaseAppDelegateProxyEnabled";
   48|       |
   49|       |/** Plist key that allows developers not using Firebase to disable App and Scene Delegate Proxying.
   50|       | */
   51|       |static NSString *const kGULGoogleUtilitiesSceneDelegateProxyEnabledPlistKey =
   52|       |    @"GoogleUtilitiesAppDelegateProxyEnabled";
   53|       |
   54|       |/** The prefix of the Scene Delegate. */
   55|       |static NSString *const kGULSceneDelegatePrefix = @"GUL_";
   56|       |
   57|       |/**
   58|       | * This class is necessary to store the delegates in an NSArray without retaining them.
   59|       | * [NSValue valueWithNonRetainedObject] also provides this functionality, but does not provide a
   60|       | * zeroing pointer. This will cause EXC_BAD_ACCESS when trying to access the object after it is
   61|       | * dealloced. Instead, this container stores a weak, zeroing reference to the object, which
   62|       | * automatically is set to nil by the runtime when the object is dealloced.
   63|       | */
   64|       |@interface GULSceneZeroingWeakContainer : NSObject
   65|       |
   66|       |/** Stores a weak object. */
   67|       |@property(nonatomic, weak) id object;
   68|       |
   69|       |@end
   70|       |
   71|       |@implementation GULSceneZeroingWeakContainer
   72|       |@end
   73|       |
   74|       |@implementation GULSceneDelegateSwizzler
   75|       |
   76|       |#pragma mark - Public methods
   77|       |
   78|      0|+ (BOOL)isSceneDelegateProxyEnabled {
   79|      0|  return [GULAppDelegateSwizzler isAppDelegateProxyEnabled];
   80|      0|}
   81|       |
   82|      0|+ (void)proxyOriginalSceneDelegate {
   83|      0|#if UISCENE_SUPPORTED
   84|      0|  if ([GULAppEnvironmentUtil isAppExtension]) {
   85|      0|    return;
   86|      0|  }
   87|       |
   88|      0|  static dispatch_once_t onceToken;
   89|      0|  dispatch_once(&onceToken, ^{
   90|      0|    if (@available(iOS 13.0, tvOS 13.0, *)) {
   91|      0|      if (![GULSceneDelegateSwizzler isSceneDelegateProxyEnabled]) {
   92|      0|        return;
   93|      0|      }
   94|      0|      [[NSNotificationCenter defaultCenter]
   95|      0|          addObserver:self
   96|      0|             selector:@selector(handleSceneWillConnectToNotification:)
   97|      0|                 name:UISceneWillConnectNotification
   98|      0|               object:nil];
   99|      0|    }
  100|      0|  });
  101|      0|#endif  // UISCENE_SUPPORTED
  102|      0|}
  103|       |
  104|       |#if UISCENE_SUPPORTED
  105|      0|+ (GULSceneDelegateInterceptorID)registerSceneDelegateInterceptor:(id<UISceneDelegate>)interceptor {
  106|      0|  NSAssert(interceptor, @"SceneDelegateProxy cannot add nil interceptor");
  107|      0|  NSAssert([interceptor conformsToProtocol:@protocol(UISceneDelegate)],
  108|      0|           @"SceneDelegateProxy interceptor does not conform to UIApplicationDelegate");
  109|       |
  110|      0|  if (!interceptor) {
  111|      0|    GULLogError(kGULLoggerSwizzler, NO,
  112|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  113|      0|                                           (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling000],
  114|      0|                @"SceneDelegateProxy cannot add nil interceptor.");
  115|      0|    return nil;
  116|      0|  }
  117|      0|  if (![interceptor conformsToProtocol:@protocol(UISceneDelegate)]) {
  118|      0|    GULLogError(kGULLoggerSwizzler, NO,
  119|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  120|      0|                                           (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling001],
  121|      0|                @"SceneDelegateProxy interceptor does not conform to UIApplicationDelegate");
  122|      0|    return nil;
  123|      0|  }
  124|       |
  125|       |  // The ID should be the same given the same interceptor object.
  126|      0|  NSString *interceptorID =
  127|      0|      [NSString stringWithFormat:@"%@%p", kGULSceneDelegatePrefix, interceptor];
  128|      0|  if (!interceptorID.length) {
  129|      0|    GULLogError(kGULLoggerSwizzler, NO,
  130|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  131|      0|                                           (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling002],
  132|      0|                @"SceneDelegateProxy cannot create Interceptor ID.");
  133|      0|    return nil;
  134|      0|  }
  135|      0|  GULSceneZeroingWeakContainer *weakObject = [[GULSceneZeroingWeakContainer alloc] init];
  136|      0|  weakObject.object = interceptor;
  137|      0|  [GULSceneDelegateSwizzler interceptors][interceptorID] = weakObject;
  138|      0|  return interceptorID;
  139|      0|}
  140|       |
  141|      0|+ (void)unregisterSceneDelegateInterceptorWithID:(GULSceneDelegateInterceptorID)interceptorID {
  142|      0|  NSAssert(interceptorID, @"SceneDelegateProxy cannot unregister nil interceptor ID.");
  143|      0|  NSAssert(((NSString *)interceptorID).length != 0,
  144|      0|           @"SceneDelegateProxy cannot unregister empty interceptor ID.");
  145|       |
  146|      0|  if (!interceptorID) {
  147|      0|    GULLogError(kGULLoggerSwizzler, NO,
  148|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  149|      0|                                           (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling003],
  150|      0|                @"SceneDelegateProxy cannot unregister empty interceptor ID.");
  151|      0|    return;
  152|      0|  }
  153|       |
  154|      0|  GULSceneZeroingWeakContainer *weakContainer =
  155|      0|      [GULSceneDelegateSwizzler interceptors][interceptorID];
  156|      0|  if (!weakContainer.object) {
  157|      0|    GULLogError(kGULLoggerSwizzler, NO,
  158|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  159|      0|                                           (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling004],
  160|      0|                @"SceneDelegateProxy cannot unregister interceptor that was not registered. "
  161|      0|                 "Interceptor ID %@",
  162|      0|                interceptorID);
  163|      0|    return;
  164|      0|  }
  165|       |
  166|      0|  [[GULSceneDelegateSwizzler interceptors] removeObjectForKey:interceptorID];
  167|      0|}
  168|       |
  169|       |#pragma mark - Helper methods
  170|       |
  171|      0|+ (GULMutableDictionary *)interceptors {
  172|      0|  static dispatch_once_t onceToken;
  173|      0|  static GULMutableDictionary *sInterceptors;
  174|      0|  dispatch_once(&onceToken, ^{
  175|      0|    sInterceptors = [[GULMutableDictionary alloc] init];
  176|      0|  });
  177|      0|  return sInterceptors;
  178|      0|}
  179|       |
  180|      0|+ (void)clearInterceptors {
  181|      0|  [[self interceptors] removeAllObjects];
  182|      0|}
  183|       |
  184|      0|+ (nullable NSValue *)originalImplementationForSelector:(SEL)selector object:(id)object {
  185|      0|  NSDictionary *realImplementationBySelector =
  186|      0|      objc_getAssociatedObject(object, &kGULRealIMPBySelectorKey);
  187|      0|  return realImplementationBySelector[NSStringFromSelector(selector)];
  188|      0|}
  189|       |
  190|       |+ (void)proxyDestinationSelector:(SEL)destinationSelector
  191|       |    implementationsFromSourceSelector:(SEL)sourceSelector
  192|       |                            fromClass:(Class)sourceClass
  193|       |                              toClass:(Class)destinationClass
  194|       |                            realClass:(Class)realClass
  195|       |     storeDestinationImplementationTo:
  196|      0|         (NSMutableDictionary<NSString *, NSValue *> *)destinationImplementationsBySelector {
  197|      0|  [self addInstanceMethodWithDestinationSelector:destinationSelector
  198|      0|            withImplementationFromSourceSelector:sourceSelector
  199|      0|                                       fromClass:sourceClass
  200|      0|                                         toClass:destinationClass];
  201|      0|  IMP sourceImplementation =
  202|      0|      [GULSceneDelegateSwizzler implementationOfMethodSelector:destinationSelector
  203|      0|                                                     fromClass:realClass];
  204|      0|  NSValue *sourceImplementationPointer = [NSValue valueWithPointer:sourceImplementation];
  205|       |
  206|      0|  NSString *destinationSelectorString = NSStringFromSelector(destinationSelector);
  207|      0|  destinationImplementationsBySelector[destinationSelectorString] = sourceImplementationPointer;
  208|      0|}
  209|       |
  210|       |/** Copies a method identified by the methodSelector from one class to the other. After this method
  211|       | *  is called, performing [toClassInstance methodSelector] will be similar to calling
  212|       | *  [fromClassInstance methodSelector]. This method does nothing if toClass already has a method
  213|       | *  identified by methodSelector.
  214|       | *
  215|       | *  @param methodSelector The SEL that identifies both the method on the fromClass as well as the
  216|       | *      one on the toClass.
  217|       | *  @param fromClass The class from which a method is sourced.
  218|       | *  @param toClass The class to which the method is added. If the class already has a method with
  219|       | *      the same selector, this has no effect.
  220|       | */
  221|       |+ (void)addInstanceMethodWithSelector:(SEL)methodSelector
  222|       |                            fromClass:(Class)fromClass
  223|      0|                              toClass:(Class)toClass {
  224|      0|  [self addInstanceMethodWithDestinationSelector:methodSelector
  225|      0|            withImplementationFromSourceSelector:methodSelector
  226|      0|                                       fromClass:fromClass
  227|      0|                                         toClass:toClass];
  228|      0|}
  229|       |
  230|       |/** Copies a method identified by the sourceSelector from the fromClass as a method for the
  231|       | *  destinationSelector on the toClass. After this method is called, performing
  232|       | *  [toClassInstance destinationSelector] will be similar to calling
  233|       | *  [fromClassInstance sourceSelector]. This method does nothing if toClass already has a method
  234|       | *  identified by destinationSelector.
  235|       | *
  236|       | *  @param destinationSelector The SEL that identifies the method on the toClass.
  237|       | *  @param sourceSelector The SEL that identifies the method on the fromClass.
  238|       | *  @param fromClass The class from which a method is sourced.
  239|       | *  @param toClass The class to which the method is added. If the class already has a method with
  240|       | *      the same selector, this has no effect.
  241|       | */
  242|       |+ (void)addInstanceMethodWithDestinationSelector:(SEL)destinationSelector
  243|       |            withImplementationFromSourceSelector:(SEL)sourceSelector
  244|       |                                       fromClass:(Class)fromClass
  245|      0|                                         toClass:(Class)toClass {
  246|      0|  Method method = class_getInstanceMethod(fromClass, sourceSelector);
  247|      0|  IMP methodIMP = method_getImplementation(method);
  248|      0|  const char *types = method_getTypeEncoding(method);
  249|      0|  if (!class_addMethod(toClass, destinationSelector, methodIMP, types)) {
  250|      0|    GULLogWarning(
  251|      0|        kGULLoggerSwizzler, NO,
  252|      0|        [NSString
  253|      0|            stringWithFormat:@"I-SWZ%06ld", (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling009],
  254|      0|        @"Cannot copy method to destination selector %@ as it already exists",
  255|      0|        NSStringFromSelector(destinationSelector));
  256|      0|  }
  257|      0|}
  258|       |
  259|       |/** Gets the IMP of the instance method on the class identified by the selector.
  260|       | *
  261|       | *  @param selector The selector of which the IMP is to be fetched.
  262|       | *  @param aClass The class from which the IMP is to be fetched.
  263|       | *  @return The IMP of the instance method identified by selector and aClass.
  264|       | */
  265|      0|+ (IMP)implementationOfMethodSelector:(SEL)selector fromClass:(Class)aClass {
  266|      0|  Method aMethod = class_getInstanceMethod(aClass, selector);
  267|      0|  return method_getImplementation(aMethod);
  268|      0|}
  269|       |
  270|       |/** Enumerates through all the interceptors and if they respond to a given selector, executes a
  271|       | *  GULSceneDelegateInterceptorCallback with the interceptor.
  272|       | *
  273|       | *  @param methodSelector The SEL to check if an interceptor responds to.
  274|       | *  @param callback the GULSceneDelegateInterceptorCallback.
  275|       | */
  276|       |+ (void)notifyInterceptorsWithMethodSelector:(SEL)methodSelector
  277|       |                                    callback:(GULSceneDelegateInterceptorCallback)callback
  278|      0|    API_AVAILABLE(ios(13.0)) {
  279|      0|  if (!callback) {
  280|      0|    return;
  281|      0|  }
  282|       |
  283|      0|  NSDictionary *interceptors = [GULSceneDelegateSwizzler interceptors].dictionary;
  284|      0|  [interceptors enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
  285|      0|    GULSceneZeroingWeakContainer *interceptorContainer = obj;
  286|      0|    id interceptor = interceptorContainer.object;
  287|      0|    if (!interceptor) {
  288|      0|      GULLogWarning(
  289|      0|          kGULLoggerSwizzler, NO,
  290|      0|          [NSString stringWithFormat:@"I-SWZ%06ld",
  291|      0|                                     (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling010],
  292|      0|          @"SceneDelegateProxy cannot find interceptor with ID %@. Removing the interceptor.", key);
  293|      0|      [[GULSceneDelegateSwizzler interceptors] removeObjectForKey:key];
  294|      0|      return;
  295|      0|    }
  296|      0|    if ([interceptor respondsToSelector:methodSelector]) {
  297|      0|      callback(interceptor);
  298|      0|    }
  299|      0|  }];
  300|      0|}
  301|       |
  302|      0|+ (void)handleSceneWillConnectToNotification:(NSNotification *)notification {
  303|      0|  if (@available(iOS 13.0, tvOS 13.0, *)) {
  304|      0|    if ([notification.object isKindOfClass:[UIScene class]]) {
  305|      0|      UIScene *scene = (UIScene *)notification.object;
  306|      0|      [GULSceneDelegateSwizzler proxySceneDelegateIfNeeded:scene];
  307|      0|    }
  308|      0|  }
  309|      0|}
  310|       |
  311|       |#pragma mark - [Donor Methods] UISceneDelegate URL handler
  312|       |
  313|       |- (void)scene:(UIScene *)scene
  314|      0|    openURLContexts:(NSSet<UIOpenURLContext *> *)URLContexts API_AVAILABLE(ios(13.0), tvos(13.0)) {
  315|      0|  if (@available(iOS 13.0, tvOS 13.0, *)) {
  316|      0|    SEL methodSelector = @selector(scene:openURLContexts:);
  317|       |    // Call the real implementation if the real Scene Delegate has any.
  318|      0|    NSValue *openURLContextsIMPPointer =
  319|      0|        [GULSceneDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  320|      0|    GULOpenURLContextsIMP openURLContextsIMP = [openURLContextsIMPPointer pointerValue];
  321|       |
  322|      0|    [GULSceneDelegateSwizzler
  323|      0|        notifyInterceptorsWithMethodSelector:methodSelector
  324|      0|                                    callback:^(id<UISceneDelegate> interceptor) {
  325|      0|                                      if ([interceptor
  326|      0|                                              conformsToProtocol:@protocol(UISceneDelegate)]) {
  327|      0|                                        id<UISceneDelegate> sceneInterceptor =
  328|      0|                                            (id<UISceneDelegate>)interceptor;
  329|      0|                                        [sceneInterceptor scene:scene openURLContexts:URLContexts];
  330|      0|                                      }
  331|      0|                                    }];
  332|       |
  333|      0|    if (openURLContextsIMP) {
  334|      0|      openURLContextsIMP(self, methodSelector, scene, URLContexts);
  335|      0|    }
  336|      0|  }
  337|      0|}
  338|       |
  339|      0|+ (void)proxySceneDelegateIfNeeded:(UIScene *)scene {
  340|      0|  Class realClass = [scene.delegate class];
  341|      0|  NSString *className = NSStringFromClass(realClass);
  342|       |
  343|       |  // Skip proxying if failed to get the delegate class name for some reason (e.g. `delegate == nil`)
  344|       |  // or the class has a prefix of kGULAppDelegatePrefix, which means it has been proxied before.
  345|      0|  if (className == nil || [className hasPrefix:kGULSceneDelegatePrefix]) {
  346|      0|    return;
  347|      0|  }
  348|       |
  349|      0|  NSString *classNameWithPrefix = [kGULSceneDelegatePrefix stringByAppendingString:className];
  350|      0|  NSString *newClassName =
  351|      0|      [NSString stringWithFormat:@"%@-%@", classNameWithPrefix, [NSUUID UUID].UUIDString];
  352|       |
  353|      0|  if (NSClassFromString(newClassName)) {
  354|      0|    GULLogError(
  355|      0|        kGULLoggerSwizzler, NO,
  356|      0|        [NSString
  357|      0|            stringWithFormat:@"I-SWZ%06ld",
  358|      0|                             (long)
  359|      0|                                 kGULSwizzlerMessageCodeSceneDelegateSwizzlingInvalidSceneDelegate],
  360|      0|        @"Cannot create a proxy for Scene Delegate. Subclass already exists. Original Class"
  361|      0|        @": %@, subclass: %@",
  362|      0|        className, newClassName);
  363|      0|    return;
  364|      0|  }
  365|       |
  366|       |  // Register the new class as subclass of the real one. Do not allocate more than the real class
  367|       |  // size.
  368|      0|  Class sceneDelegateSubClass = objc_allocateClassPair(realClass, newClassName.UTF8String, 0);
  369|      0|  if (sceneDelegateSubClass == Nil) {
  370|      0|    GULLogError(
  371|      0|        kGULLoggerSwizzler, NO,
  372|      0|        [NSString
  373|      0|            stringWithFormat:@"I-SWZ%06ld",
  374|      0|                             (long)
  375|      0|                                 kGULSwizzlerMessageCodeSceneDelegateSwizzlingInvalidSceneDelegate],
  376|      0|        @"Cannot create a proxy for Scene Delegate. Subclass already exists. Original Class"
  377|      0|        @": %@, subclass: Nil",
  378|      0|        className);
  379|      0|    return;
  380|      0|  }
  381|       |
  382|      0|  NSMutableDictionary<NSString *, NSValue *> *realImplementationsBySelector =
  383|      0|      [[NSMutableDictionary alloc] init];
  384|       |
  385|       |  // For scene:openURLContexts:
  386|      0|  SEL openURLContextsSEL = @selector(scene:openURLContexts:);
  387|      0|  [self proxyDestinationSelector:openURLContextsSEL
  388|      0|      implementationsFromSourceSelector:openURLContextsSEL
  389|      0|                              fromClass:[GULSceneDelegateSwizzler class]
  390|      0|                                toClass:sceneDelegateSubClass
  391|      0|                              realClass:realClass
  392|      0|       storeDestinationImplementationTo:realImplementationsBySelector];
  393|       |
  394|       |  // Store original implementations to a fake property of the original delegate.
  395|      0|  objc_setAssociatedObject(scene.delegate, &kGULRealIMPBySelectorKey,
  396|      0|                           [realImplementationsBySelector copy], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  397|      0|  objc_setAssociatedObject(scene.delegate, &kGULRealClassKey, realClass,
  398|      0|                           OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  399|       |
  400|       |  // The subclass size has to be exactly the same size with the original class size. The subclass
  401|       |  // cannot have more ivars/properties than its superclass since it will cause an offset in memory
  402|       |  // that can lead to overwriting the isa of an object in the next frame.
  403|      0|  if (class_getInstanceSize(realClass) != class_getInstanceSize(sceneDelegateSubClass)) {
  404|      0|    GULLogError(
  405|      0|        kGULLoggerSwizzler, NO,
  406|      0|        [NSString
  407|      0|            stringWithFormat:@"I-SWZ%06ld",
  408|      0|                             (long)
  409|      0|                                 kGULSwizzlerMessageCodeSceneDelegateSwizzlingInvalidSceneDelegate],
  410|      0|        @"Cannot create subclass of Scene Delegate, because the created subclass is not the "
  411|      0|        @"same size. %@",
  412|      0|        className);
  413|      0|    NSAssert(NO, @"Classes must be the same size to swizzle isa");
  414|      0|    return;
  415|      0|  }
  416|       |
  417|       |  // Make the newly created class to be the subclass of the real Scene Delegate class.
  418|      0|  objc_registerClassPair(sceneDelegateSubClass);
  419|      0|  if (object_setClass(scene.delegate, sceneDelegateSubClass)) {
  420|      0|    GULLogDebug(
  421|      0|        kGULLoggerSwizzler, NO,
  422|      0|        [NSString
  423|      0|            stringWithFormat:@"I-SWZ%06ld",
  424|      0|                             (long)
  425|      0|                                 kGULSwizzlerMessageCodeSceneDelegateSwizzlingInvalidSceneDelegate],
  426|      0|        @"Successfully created Scene Delegate Proxy automatically. To disable the "
  427|      0|        @"proxy, set the flag %@ to NO (Boolean) in the Info.plist",
  428|      0|        [GULSceneDelegateSwizzler correctSceneDelegateProxyKey]);
  429|      0|  }
  430|      0|}
  431|       |
  432|      0|+ (NSString *)correctSceneDelegateProxyKey {
  433|      0|  return NSClassFromString(@"FIRCore") ? kGULFirebaseSceneDelegateProxyEnabledPlistKey
  434|      0|                                       : kGULGoogleUtilitiesSceneDelegateProxyEnabledPlistKey;
  435|      0|}
  436|       |
  437|       |#endif  // UISCENE_SUPPORTED
  438|       |
  439|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/Environment/GULHeartbeatDateStorage.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleUtilities/Environment/Public/GoogleUtilities/GULHeartbeatDateStorage.h"
   18|       |#import "GoogleUtilities/Environment/Public/GoogleUtilities/GULSecureCoding.h"
   19|       |
   20|       |NSString *const kGULHeartbeatStorageDirectory = @"Google/FIRApp";
   21|       |
   22|       |@interface GULHeartbeatDateStorage ()
   23|       |
   24|       |/** The name of the file that stores heartbeat information. */
   25|       |@property(nonatomic, readonly) NSString *fileName;
   26|       |@end
   27|       |
   28|       |@implementation GULHeartbeatDateStorage
   29|       |
   30|       |@synthesize fileURL = _fileURL;
   31|       |
   32|      0|- (instancetype)initWithFileName:(NSString *)fileName {
   33|      0|  if (fileName == nil) return nil;
   34|       |
   35|      0|  self = [super init];
   36|      0|  if (self) {
   37|      0|    _fileName = fileName;
   38|      0|  }
   39|      0|  return self;
   40|      0|}
   41|       |
   42|       |/** Lazy getter for fileURL.
   43|       | * @return fileURL where heartbeat information is stored.
   44|       | */
   45|      0|- (NSURL *)fileURL {
   46|      0|  if (!_fileURL) {
   47|      0|    NSURL *directoryURL = [self directoryPathURL];
   48|      0|    [self checkAndCreateDirectory:directoryURL];
   49|      0|    _fileURL = [directoryURL URLByAppendingPathComponent:_fileName];
   50|      0|  }
   51|      0|  return _fileURL;
   52|      0|}
   53|       |
   54|       |/** Returns the URL path of the directory for heartbeat storage data.
   55|       | * @return the URL path of the directory for heartbeat storage data.
   56|       | */
   57|      0|- (NSURL *)directoryPathURL {
   58|      0|  NSArray<NSString *> *paths;
   59|       |#if TARGET_OS_TV
   60|       |  paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
   61|       |#else
   62|      0|  paths = NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES);
   63|      0|#endif  // TARGET_OS_TV
   64|      0|  NSString *rootPath = [paths lastObject];
   65|      0|  NSURL *rootURL = [NSURL fileURLWithPath:rootPath];
   66|      0|  NSURL *directoryURL = [rootURL URLByAppendingPathComponent:kGULHeartbeatStorageDirectory];
   67|      0|  return directoryURL;
   68|      0|}
   69|       |
   70|       |/** Check for the existence of the directory specified by the URL, and create it if it does not
   71|       | * exist.
   72|       | * @param directoryPathURL The path to the directory that needs to exist.
   73|       | */
   74|      0|- (void)checkAndCreateDirectory:(NSURL *)directoryPathURL {
   75|      0|  NSError *error;
   76|      0|  if (![directoryPathURL checkResourceIsReachableAndReturnError:&error]) {
   77|      0|    NSError *error;
   78|      0|    [[NSFileManager defaultManager] createDirectoryAtURL:directoryPathURL
   79|      0|                             withIntermediateDirectories:YES
   80|      0|                                              attributes:nil
   81|      0|                                                   error:&error];
   82|      0|  }
   83|      0|}
   84|       |
   85|      0|- (nullable NSDate *)heartbeatDateForTag:(NSString *)tag {
   86|      0|  @synchronized(self.class) {
   87|      0|    NSDictionary *heartbeatDictionary = [self heartbeatDictionaryWithFileURL:self.fileURL];
   88|      0|    NSDate *heartbeatDate = heartbeatDictionary[tag];
   89|       |
   90|       |    // Validate the value type. If the storage file was corrupted or updated with a different format
   91|       |    // by a newer SDK version the value type may be different.
   92|      0|    if (![heartbeatDate isKindOfClass:[NSDate class]]) {
   93|      0|      heartbeatDate = nil;
   94|      0|    }
   95|       |
   96|      0|    return heartbeatDate;
   97|      0|  }
   98|      0|}
   99|       |
  100|      0|- (BOOL)setHearbeatDate:(NSDate *)date forTag:(NSString *)tag {
  101|       |  // Synchronize on the class to ensure that the different instances of the class will not access
  102|       |  // the same file concurrently.
  103|       |  // TODO: Consider a different synchronization strategy here and in `-heartbeatDateForTag:` method.
  104|       |  // Currently no heartbeats can be read/written concurrently even if they are in different files.
  105|      0|  @synchronized(self.class) {
  106|      0|    NSMutableDictionary *heartbeatDictionary =
  107|      0|        [[self heartbeatDictionaryWithFileURL:self.fileURL] mutableCopy];
  108|      0|    heartbeatDictionary[tag] = date;
  109|      0|    NSError *error;
  110|      0|    BOOL isSuccess = [self writeDictionary:[heartbeatDictionary copy]
  111|      0|                             forWritingURL:self.fileURL
  112|      0|                                     error:&error];
  113|      0|    return isSuccess;
  114|      0|  }
  115|      0|}
  116|       |
  117|      0|- (NSDictionary *)heartbeatDictionaryWithFileURL:(NSURL *)readingFileURL {
  118|      0|  NSDictionary *heartbeatDictionary;
  119|       |
  120|      0|  NSError *error;
  121|      0|  NSData *objectData = [NSData dataWithContentsOfURL:readingFileURL options:0 error:&error];
  122|       |
  123|      0|  if (objectData.length > 0 && error == nil) {
  124|      0|    NSSet<Class> *objectClasses =
  125|      0|        [NSSet setWithArray:@[ NSDictionary.class, NSDate.class, NSString.class ]];
  126|      0|    heartbeatDictionary = [GULSecureCoding unarchivedObjectOfClasses:objectClasses
  127|      0|                                                            fromData:objectData
  128|      0|                                                               error:&error];
  129|      0|  }
  130|       |
  131|      0|  if (heartbeatDictionary.count == 0 || error != nil) {
  132|      0|    heartbeatDictionary = [NSDictionary dictionary];
  133|      0|  }
  134|       |
  135|      0|  return heartbeatDictionary;
  136|      0|}
  137|       |
  138|       |- (BOOL)writeDictionary:(NSDictionary *)dictionary
  139|       |          forWritingURL:(NSURL *)writingFileURL
  140|      0|                  error:(NSError **)outError {
  141|       |  // Archive a mutable copy `dictionary` for writing to disk. This is done for
  142|       |  // backwards compatibility. See Google Utilities issue #36 for more context.
  143|       |  // TODO: Remove usage of mutable copy in a future version of Google Utilities.
  144|      0|  NSData *data = [GULSecureCoding archivedDataWithRootObject:[dictionary mutableCopy]
  145|      0|                                                       error:outError];
  146|      0|  if (data.length == 0) {
  147|      0|    return NO;
  148|      0|  }
  149|       |
  150|      0|  return [data writeToURL:writingFileURL atomically:YES];
  151|      0|}
  152|       |
  153|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/Environment/GULHeartbeatDateStorageUserDefaults.m:
    1|       |/*
    2|       | * Copyright 2021 Google LLC
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleUtilities/Environment/Public/GoogleUtilities/GULHeartbeatDateStorageUserDefaults.h"
   18|       |
   19|       |@interface GULHeartbeatDateStorageUserDefaults ()
   20|       |
   21|       |/** The storage to store the date of the last sent heartbeat. */
   22|       |@property(nonatomic, readonly) NSUserDefaults *userDefaults;
   23|       |
   24|       |/** The key for user defaults to store heartbeat information. */
   25|       |@property(nonatomic, readonly) NSString *key;
   26|       |
   27|       |@end
   28|       |
   29|       |@implementation GULHeartbeatDateStorageUserDefaults
   30|       |
   31|      0|- (instancetype)initWithDefaults:(NSUserDefaults *)defaults key:(NSString *)key {
   32|      0|  self = [super init];
   33|      0|  if (self) {
   34|      0|    _userDefaults = defaults;
   35|      0|    _key = key;
   36|      0|  }
   37|      0|  return self;
   38|      0|}
   39|       |
   40|      0|- (NSMutableDictionary *)heartbeatDictionaryFromDefaults {
   41|      0|  NSDictionary *heartbeatDict = [self.userDefaults objectForKey:self.key];
   42|      0|  if (heartbeatDict != nil) {
   43|      0|    return [heartbeatDict mutableCopy];
   44|      0|  } else {
   45|      0|    return [NSMutableDictionary dictionary];
   46|      0|  }
   47|      0|}
   48|       |
   49|      0|- (nullable NSDate *)heartbeatDateForTag:(NSString *)tag {
   50|      0|  NSDate *date = nil;
   51|      0|  @synchronized(self.userDefaults) {
   52|      0|    NSMutableDictionary *dict = [self heartbeatDictionaryFromDefaults];
   53|      0|    date = dict[tag];
   54|      0|  }
   55|       |
   56|      0|  return date;
   57|      0|}
   58|       |
   59|      0|- (BOOL)setHearbeatDate:(NSDate *)date forTag:(NSString *)tag {
   60|      0|  @synchronized(self.userDefaults) {
   61|      0|    NSMutableDictionary *dict = [self heartbeatDictionaryFromDefaults];
   62|      0|    dict[tag] = date;
   63|      0|    [self.userDefaults setObject:dict forKey:self.key];
   64|      0|  }
   65|      0|  return true;
   66|      0|}
   67|       |
   68|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/Environment/GULSecureCoding.m:
    1|       |// Copyright 2019 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/Environment/Public/GoogleUtilities/GULSecureCoding.h"
   16|       |
   17|       |NSString *const kGULSecureCodingError = @"GULSecureCodingError";
   18|       |
   19|       |@implementation GULSecureCoding
   20|       |
   21|       |+ (nullable id)unarchivedObjectOfClasses:(NSSet<Class> *)classes
   22|       |                                fromData:(NSData *)data
   23|      0|                                   error:(NSError **)outError {
   24|      0|  id object;
   25|      0|#if __has_builtin(__builtin_available)
   26|      0|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)) {
   27|      0|    object = [NSKeyedUnarchiver unarchivedObjectOfClasses:classes fromData:data error:outError];
   28|      0|  } else
   29|      0|#endif  // __has_builtin(__builtin_available)
   30|      0|  {
   31|      0|    @try {
   32|      0|#pragma clang diagnostic push
   33|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
   34|      0|      NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
   35|      0|#pragma clang diagnostic pop
   36|      0|      unarchiver.requiresSecureCoding = YES;
   37|       |
   38|      0|      object = [unarchiver decodeObjectOfClasses:classes forKey:NSKeyedArchiveRootObjectKey];
   39|      0|    } @catch (NSException *exception) {
   40|      0|      if (outError) {
   41|      0|        *outError = [self archivingErrorWithException:exception];
   42|      0|      }
   43|      0|    }
   44|       |
   45|      0|    if (object == nil && outError && *outError == nil) {
   46|      0|      NSString *failureReason = @"NSKeyedUnarchiver failed to unarchive data.";
   47|      0|      *outError = [NSError errorWithDomain:kGULSecureCodingError
   48|      0|                                      code:-1
   49|      0|                                  userInfo:@{NSLocalizedFailureReasonErrorKey : failureReason}];
   50|      0|    }
   51|      0|  }
   52|       |
   53|      0|  return object;
   54|      0|}
   55|       |
   56|       |+ (nullable id)unarchivedObjectOfClass:(Class)class
   57|       |                              fromData:(NSData *)data
   58|      0|                                 error:(NSError **)outError {
   59|      0|  return [self unarchivedObjectOfClasses:[NSSet setWithObject:class] fromData:data error:outError];
   60|      0|}
   61|       |
   62|      0|+ (nullable NSData *)archivedDataWithRootObject:(id<NSCoding>)object error:(NSError **)outError {
   63|      0|  NSData *archiveData;
   64|      0|#if __has_builtin(__builtin_available)
   65|      0|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)) {
   66|      0|    archiveData = [NSKeyedArchiver archivedDataWithRootObject:object
   67|      0|                                        requiringSecureCoding:YES
   68|      0|                                                        error:outError];
   69|      0|  } else
   70|      0|#endif  // __has_builtin(__builtin_available)
   71|      0|  {
   72|      0|    @try {
   73|      0|      NSMutableData *data = [NSMutableData data];
   74|      0|#pragma clang diagnostic push
   75|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
   76|      0|      NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];
   77|      0|#pragma clang diagnostic pop
   78|      0|      archiver.requiresSecureCoding = YES;
   79|       |
   80|      0|      [archiver encodeObject:object forKey:NSKeyedArchiveRootObjectKey];
   81|      0|      [archiver finishEncoding];
   82|       |
   83|      0|      archiveData = [data copy];
   84|      0|    } @catch (NSException *exception) {
   85|      0|      if (outError) {
   86|      0|        *outError = [self archivingErrorWithException:exception];
   87|      0|      }
   88|      0|    }
   89|      0|  }
   90|       |
   91|      0|  return archiveData;
   92|      0|}
   93|       |
   94|      0|+ (NSError *)archivingErrorWithException:(NSException *)exception {
   95|      0|  NSString *failureReason = [NSString
   96|      0|      stringWithFormat:@"NSKeyedArchiver exception with name: %@, reason: %@, userInfo: %@",
   97|      0|                       exception.name, exception.reason, exception.userInfo];
   98|      0|  NSDictionary *errorUserInfo = @{NSLocalizedFailureReasonErrorKey : failureReason};
   99|       |
  100|      0|  return [NSError errorWithDomain:kGULSecureCodingError code:-1 userInfo:errorUserInfo];
  101|      0|}
  102|       |
  103|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/Environment/SecureStorage/GULKeychainStorage.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleUtilities/Environment/Public/GoogleUtilities/GULKeychainStorage.h"
   18|       |#import <Security/Security.h>
   19|       |
   20|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   21|       |#import <FBLPromises/FBLPromises.h>
   22|       |#else
   23|       |#import "FBLPromises.h"
   24|       |#endif
   25|       |
   26|       |#import "GoogleUtilities/Environment/Public/GoogleUtilities/GULKeychainUtils.h"
   27|       |#import "GoogleUtilities/Environment/Public/GoogleUtilities/GULSecureCoding.h"
   28|       |
   29|       |@interface GULKeychainStorage ()
   30|       |@property(nonatomic, readonly) dispatch_queue_t keychainQueue;
   31|       |@property(nonatomic, readonly) dispatch_queue_t inMemoryCacheQueue;
   32|       |@property(nonatomic, readonly) NSString *service;
   33|       |@property(nonatomic, readonly) NSCache<NSString *, id<NSSecureCoding>> *inMemoryCache;
   34|       |@end
   35|       |
   36|       |@implementation GULKeychainStorage
   37|       |
   38|      0|- (instancetype)initWithService:(NSString *)service {
   39|      0|  NSCache *cache = [[NSCache alloc] init];
   40|       |  // Cache up to 5 installations.
   41|      0|  cache.countLimit = 5;
   42|      0|  return [self initWithService:service cache:cache];
   43|      0|}
   44|       |
   45|      0|- (instancetype)initWithService:(NSString *)service cache:(NSCache *)cache {
   46|      0|  self = [super init];
   47|      0|  if (self) {
   48|      0|    _keychainQueue =
   49|      0|        dispatch_queue_create("com.gul.KeychainStorage.Keychain", DISPATCH_QUEUE_SERIAL);
   50|      0|    _inMemoryCacheQueue =
   51|      0|        dispatch_queue_create("com.gul.KeychainStorage.InMemoryCache", DISPATCH_QUEUE_SERIAL);
   52|      0|    _service = [service copy];
   53|      0|    _inMemoryCache = cache;
   54|      0|  }
   55|      0|  return self;
   56|      0|}
   57|       |
   58|       |#pragma mark - Public
   59|       |
   60|       |- (FBLPromise<id<NSSecureCoding>> *)getObjectForKey:(NSString *)key
   61|       |                                        objectClass:(Class)objectClass
   62|      0|                                        accessGroup:(nullable NSString *)accessGroup {
   63|      0|  return [FBLPromise onQueue:self.inMemoryCacheQueue
   64|      0|                          do:^id _Nullable {
   65|       |                            // Return cached object or fail otherwise.
   66|      0|                            id object = [self.inMemoryCache objectForKey:key];
   67|      0|                            return object
   68|      0|                                       ?: [[NSError alloc]
   69|      0|                                              initWithDomain:FBLPromiseErrorDomain
   70|      0|                                                        code:FBLPromiseErrorCodeValidationFailure
   71|      0|                                                    userInfo:nil];
   72|      0|                          }]
   73|      0|      .recover(^id _Nullable(NSError *error) {
   74|       |        // Look for the object in the keychain.
   75|      0|        return [self getObjectFromKeychainForKey:key
   76|      0|                                     objectClass:objectClass
   77|      0|                                     accessGroup:accessGroup];
   78|      0|      });
   79|      0|}
   80|       |
   81|       |- (FBLPromise<NSNull *> *)setObject:(id<NSSecureCoding>)object
   82|       |                             forKey:(NSString *)key
   83|      0|                        accessGroup:(nullable NSString *)accessGroup {
   84|      0|  return [FBLPromise onQueue:self.inMemoryCacheQueue
   85|      0|                          do:^id _Nullable {
   86|       |                            // Save to the in-memory cache first.
   87|      0|                            [self.inMemoryCache setObject:object forKey:[key copy]];
   88|      0|                            return [NSNull null];
   89|      0|                          }]
   90|      0|      .thenOn(self.keychainQueue, ^id(id result) {
   91|       |        // Then store the object to the keychain.
   92|      0|        NSDictionary *query = [self keychainQueryWithKey:key accessGroup:accessGroup];
   93|      0|        NSError *error;
   94|      0|        NSData *encodedObject = [GULSecureCoding archivedDataWithRootObject:object error:&error];
   95|      0|        if (!encodedObject) {
   96|      0|          return error;
   97|      0|        }
   98|       |
   99|      0|        if (![GULKeychainUtils setItem:encodedObject withQuery:query error:&error]) {
  100|      0|          return error;
  101|      0|        }
  102|       |
  103|      0|        return [NSNull null];
  104|      0|      });
  105|      0|}
  106|       |
  107|       |- (FBLPromise<NSNull *> *)removeObjectForKey:(NSString *)key
  108|      0|                                 accessGroup:(nullable NSString *)accessGroup {
  109|      0|  return [FBLPromise onQueue:self.inMemoryCacheQueue
  110|      0|                          do:^id _Nullable {
  111|      0|                            [self.inMemoryCache removeObjectForKey:key];
  112|      0|                            return nil;
  113|      0|                          }]
  114|      0|      .thenOn(self.keychainQueue, ^id(id result) {
  115|      0|        NSDictionary *query = [self keychainQueryWithKey:key accessGroup:accessGroup];
  116|       |
  117|      0|        NSError *error;
  118|      0|        if (![GULKeychainUtils removeItemWithQuery:query error:&error]) {
  119|      0|          return error;
  120|      0|        }
  121|       |
  122|      0|        return [NSNull null];
  123|      0|      });
  124|      0|}
  125|       |
  126|       |#pragma mark - Private
  127|       |
  128|       |- (FBLPromise<id<NSSecureCoding>> *)getObjectFromKeychainForKey:(NSString *)key
  129|       |                                                    objectClass:(Class)objectClass
  130|      0|                                                    accessGroup:(nullable NSString *)accessGroup {
  131|       |  // Look for the object in the keychain.
  132|      0|  return [FBLPromise
  133|      0|             onQueue:self.keychainQueue
  134|      0|                  do:^id {
  135|      0|                    NSDictionary *query = [self keychainQueryWithKey:key accessGroup:accessGroup];
  136|      0|                    NSError *error;
  137|      0|                    NSData *encodedObject = [GULKeychainUtils getItemWithQuery:query error:&error];
  138|       |
  139|      0|                    if (error) {
  140|      0|                      return error;
  141|      0|                    }
  142|      0|                    if (!encodedObject) {
  143|      0|                      return nil;
  144|      0|                    }
  145|      0|                    id object = [GULSecureCoding unarchivedObjectOfClass:objectClass
  146|      0|                                                                fromData:encodedObject
  147|      0|                                                                   error:&error];
  148|      0|                    if (error) {
  149|      0|                      return error;
  150|      0|                    }
  151|       |
  152|      0|                    return object;
  153|      0|                  }]
  154|      0|      .thenOn(self.inMemoryCacheQueue,
  155|      0|              ^id<NSSecureCoding> _Nullable(id<NSSecureCoding> _Nullable object) {
  156|       |                // Save object to the in-memory cache if exists and return the object.
  157|      0|                if (object) {
  158|      0|                  [self.inMemoryCache setObject:object forKey:[key copy]];
  159|      0|                }
  160|      0|                return object;
  161|      0|              });
  162|      0|}
  163|       |
  164|      0|- (void)resetInMemoryCache {
  165|      0|  [self.inMemoryCache removeAllObjects];
  166|      0|}
  167|       |
  168|       |#pragma mark - Keychain
  169|       |
  170|       |- (NSMutableDictionary<NSString *, id> *)keychainQueryWithKey:(NSString *)key
  171|      0|                                                  accessGroup:(nullable NSString *)accessGroup {
  172|      0|  NSMutableDictionary<NSString *, id> *query = [NSMutableDictionary dictionary];
  173|       |
  174|      0|  query[(__bridge NSString *)kSecClass] = (__bridge NSString *)kSecClassGenericPassword;
  175|      0|  query[(__bridge NSString *)kSecAttrService] = self.service;
  176|      0|  query[(__bridge NSString *)kSecAttrAccount] = key;
  177|       |
  178|      0|  if (accessGroup) {
  179|      0|    query[(__bridge NSString *)kSecAttrAccessGroup] = accessGroup;
  180|      0|  }
  181|       |
  182|       |#if TARGET_OS_OSX
  183|       |  if (self.keychainRef) {
  184|       |    query[(__bridge NSString *)kSecUseKeychain] = (__bridge id)(self.keychainRef);
  185|       |    query[(__bridge NSString *)kSecMatchSearchList] = @[ (__bridge id)(self.keychainRef) ];
  186|       |  }
  187|       |#endif  // TARGET_OSX
  188|       |
  189|      0|  return query;
  190|      0|}
  191|       |
  192|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/Environment/SecureStorage/GULKeychainUtils.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleUtilities/Environment/Public/GoogleUtilities/GULKeychainUtils.h"
   18|       |
   19|       |NSString *const kGULKeychainUtilsErrorDomain = @"com.gul.keychain.ErrorDomain";
   20|       |
   21|       |@implementation GULKeychainUtils
   22|       |
   23|       |+ (nullable NSData *)getItemWithQuery:(NSDictionary *)query
   24|      0|                                error:(NSError *_Nullable *_Nullable)outError {
   25|      0|  NSMutableDictionary *mutableQuery = [query mutableCopy];
   26|       |
   27|      0|  mutableQuery[(__bridge id)kSecReturnData] = @YES;
   28|      0|  mutableQuery[(__bridge id)kSecMatchLimit] = (__bridge id)kSecMatchLimitOne;
   29|       |
   30|      0|  CFDataRef result = NULL;
   31|      0|  OSStatus status =
   32|      0|      SecItemCopyMatching((__bridge CFDictionaryRef)mutableQuery, (CFTypeRef *)&result);
   33|       |
   34|      0|  if (status == errSecSuccess && result != NULL) {
   35|      0|    if (outError) {
   36|      0|      *outError = nil;
   37|      0|    }
   38|       |
   39|      0|    return (__bridge_transfer NSData *)result;
   40|      0|  }
   41|       |
   42|      0|  if (status == errSecItemNotFound) {
   43|      0|    if (outError) {
   44|      0|      *outError = nil;
   45|      0|    }
   46|      0|  } else {
   47|      0|    if (outError) {
   48|      0|      *outError = [self keychainErrorWithFunction:@"SecItemCopyMatching" status:status];
   49|      0|    }
   50|      0|  }
   51|      0|  return nil;
   52|      0|}
   53|       |
   54|       |+ (BOOL)setItem:(NSData *)item
   55|       |      withQuery:(NSDictionary *)query
   56|      0|          error:(NSError *_Nullable *_Nullable)outError {
   57|      0|  NSData *existingItem = [self getItemWithQuery:query error:outError];
   58|      0|  if (outError && *outError) {
   59|      0|    return NO;
   60|      0|  }
   61|       |
   62|      0|  NSMutableDictionary *mutableQuery = [query mutableCopy];
   63|      0|  mutableQuery[(__bridge id)kSecAttrAccessible] =
   64|      0|      (__bridge id)kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly;
   65|       |
   66|      0|  OSStatus status;
   67|      0|  if (!existingItem) {
   68|      0|    mutableQuery[(__bridge id)kSecValueData] = item;
   69|      0|    status = SecItemAdd((__bridge CFDictionaryRef)mutableQuery, NULL);
   70|      0|  } else {
   71|      0|    NSDictionary *attributes = @{(__bridge id)kSecValueData : item};
   72|      0|    status = SecItemUpdate((__bridge CFDictionaryRef)query, (__bridge CFDictionaryRef)attributes);
   73|      0|  }
   74|       |
   75|      0|  if (status == noErr) {
   76|      0|    if (outError) {
   77|      0|      *outError = nil;
   78|      0|    }
   79|      0|    return YES;
   80|      0|  }
   81|       |
   82|      0|  NSString *function = existingItem ? @"SecItemUpdate" : @"SecItemAdd";
   83|      0|  if (outError) {
   84|      0|    *outError = [self keychainErrorWithFunction:function status:status];
   85|      0|  }
   86|      0|  return NO;
   87|      0|}
   88|       |
   89|      0|+ (BOOL)removeItemWithQuery:(NSDictionary *)query error:(NSError *_Nullable *_Nullable)outError {
   90|      0|  OSStatus status = SecItemDelete((__bridge CFDictionaryRef)query);
   91|       |
   92|      0|  if (status == noErr || status == errSecItemNotFound) {
   93|      0|    if (outError) {
   94|      0|      *outError = nil;
   95|      0|    }
   96|      0|    return YES;
   97|      0|  }
   98|       |
   99|      0|  if (outError) {
  100|      0|    *outError = [self keychainErrorWithFunction:@"SecItemDelete" status:status];
  101|      0|  }
  102|      0|  return NO;
  103|      0|}
  104|       |
  105|       |#pragma mark - Errors
  106|       |
  107|      0|+ (NSError *)keychainErrorWithFunction:(NSString *)keychainFunction status:(OSStatus)status {
  108|      0|  NSString *failureReason = [NSString stringWithFormat:@"%@ (%li)", keychainFunction, (long)status];
  109|      0|  NSDictionary *userInfo = @{NSLocalizedFailureReasonErrorKey : failureReason};
  110|      0|  return [NSError errorWithDomain:kGULKeychainUtilsErrorDomain code:0 userInfo:userInfo];
  111|      0|}
  112|       |
  113|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/Environment/URLSessionPromiseWrapper/GULURLSessionDataResponse.m:
    1|       |/*
    2|       | * Copyright 2020 Google LLC
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleUtilities/Environment/Public/GoogleUtilities/GULURLSessionDataResponse.h"
   18|       |
   19|       |@implementation GULURLSessionDataResponse
   20|       |
   21|      0|- (instancetype)initWithResponse:(NSHTTPURLResponse *)response HTTPBody:(NSData *)body {
   22|      0|  self = [super init];
   23|      0|  if (self) {
   24|      0|    _HTTPResponse = response;
   25|      0|    _HTTPBody = body;
   26|      0|  }
   27|      0|  return self;
   28|      0|}
   29|       |
   30|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/Environment/URLSessionPromiseWrapper/NSURLSession+GULPromises.m:
    1|       |/*
    2|       | * Copyright 2020 Google LLC
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleUtilities/Environment/Public/GoogleUtilities/NSURLSession+GULPromises.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |#import "GoogleUtilities/Environment/Public/GoogleUtilities/GULURLSessionDataResponse.h"
   26|       |
   27|       |@implementation NSURLSession (GULPromises)
   28|       |
   29|       |- (FBLPromise<GULURLSessionDataResponse *> *)gul_dataTaskPromiseWithRequest:
   30|      0|    (NSURLRequest *)URLRequest {
   31|      0|  return [FBLPromise async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) {
   32|      0|    [[self dataTaskWithRequest:URLRequest
   33|      0|             completionHandler:^(NSData *_Nullable data, NSURLResponse *_Nullable response,
   34|      0|                                 NSError *_Nullable error) {
   35|      0|               if (error) {
   36|      0|                 reject(error);
   37|      0|               } else {
   38|      0|                 fulfill([[GULURLSessionDataResponse alloc]
   39|      0|                     initWithResponse:(NSHTTPURLResponse *)response
   40|      0|                             HTTPBody:data]);
   41|      0|               }
   42|      0|             }] resume];
   43|      0|  }];
   44|      0|}
   45|       |
   46|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/Environment/third_party/GULAppEnvironmentUtil.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/Environment/Public/GoogleUtilities/GULAppEnvironmentUtil.h"
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |#import <dlfcn.h>
   19|       |#import <mach-o/dyld.h>
   20|       |#import <sys/sysctl.h>
   21|       |#import <sys/utsname.h>
   22|       |#import <objc/runtime.h>
   23|       |
   24|       |#if TARGET_OS_IOS
   25|       |#import <UIKit/UIKit.h>
   26|       |#endif
   27|       |
   28|       |/// The encryption info struct and constants are missing from the iPhoneSimulator SDK, but not from
   29|       |/// the iPhoneOS or Mac OS X SDKs. Since one doesn't ever ship a Simulator binary, we'll just
   30|       |/// provide the definitions here.
   31|       |#if TARGET_OS_SIMULATOR && !defined(LC_ENCRYPTION_INFO)
   32|       |#define LC_ENCRYPTION_INFO 0x21
   33|       |struct encryption_info_command {
   34|       |  uint32_t cmd;
   35|       |  uint32_t cmdsize;
   36|       |  uint32_t cryptoff;
   37|       |  uint32_t cryptsize;
   38|       |  uint32_t cryptid;
   39|       |};
   40|       |#endif
   41|       |
   42|       |@implementation GULAppEnvironmentUtil
   43|       |
   44|       |/// A key for the Info.plist to enable or disable checking if the App Store is running in a sandbox.
   45|       |/// This will affect your data integrity when using Firebase Analytics, as it will disable some
   46|       |/// necessary checks.
   47|       |static NSString *const kFIRAppStoreReceiptURLCheckEnabledKey =
   48|       |    @"FirebaseAppStoreReceiptURLCheckEnabled";
   49|       |
   50|       |/// The file name of the sandbox receipt. This is available on iOS >= 8.0
   51|       |static NSString *const kFIRAIdentitySandboxReceiptFileName = @"sandboxReceipt";
   52|       |
   53|       |/// The following copyright from Landon J. Fuller applies to the isAppEncrypted function.
   54|       |///
   55|       |/// Copyright (c) 2017 Landon J. Fuller <landon@landonf.org>
   56|       |/// All rights reserved.
   57|       |///
   58|       |/// Permission is hereby granted, free of charge, to any person obtaining a copy of this software
   59|       |/// and associated documentation files (the "Software"), to deal in the Software without
   60|       |/// restriction, including without limitation the rights to use, copy, modify, merge, publish,
   61|       |/// distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
   62|       |/// Software is furnished to do so, subject to the following conditions:
   63|       |///
   64|       |/// The above copyright notice and this permission notice shall be included in all copies or
   65|       |/// substantial portions of the Software.
   66|       |///
   67|       |/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
   68|       |/// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   69|       |/// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
   70|       |/// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   71|       |/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   72|       |///
   73|       |/// Comment from <a href="http://iphonedevwiki.net/index.php/Crack_prevention">iPhone Dev Wiki
   74|       |/// Crack Prevention</a>:
   75|       |/// App Store binaries are signed by both their developer and Apple. This encrypts the binary so
   76|       |/// that decryption keys are needed in order to make the binary readable. When iOS executes the
   77|       |/// binary, the decryption keys are used to decrypt the binary into a readable state where it is
   78|       |/// then loaded into memory and executed. iOS can tell the encryption status of a binary via the
   79|       |/// cryptid structure member of LC_ENCRYPTION_INFO MachO load command. If cryptid is a non-zero
   80|       |/// value then the binary is encrypted.
   81|       |///
   82|       |/// 'Cracking' works by letting the kernel decrypt the binary then siphoning the decrypted data into
   83|       |/// a new binary file, resigning, and repackaging. This will only work on jailbroken devices as
   84|       |/// codesignature validation has been removed. Resigning takes place because while the codesignature
   85|       |/// doesn't have to be valid thanks to the jailbreak, it does have to be in place unless you have
   86|       |/// AppSync or similar to disable codesignature checks.
   87|       |///
   88|       |/// More information at <a href="http://landonf.org/2009/02/index.html">Landon Fuller's blog</a>
   89|      0|static BOOL IsAppEncrypted() {
   90|      0|  const struct mach_header *executableHeader = NULL;
   91|      0|  for (uint32_t i = 0; i < _dyld_image_count(); i++) {
   92|      0|    const struct mach_header *header = _dyld_get_image_header(i);
   93|      0|    if (header && header->filetype == MH_EXECUTE) {
   94|      0|      executableHeader = header;
   95|      0|      break;
   96|      0|    }
   97|      0|  }
   98|       |
   99|      0|  if (!executableHeader) {
  100|      0|    return NO;
  101|      0|  }
  102|       |
  103|      0|  BOOL is64bit = (executableHeader->magic == MH_MAGIC_64);
  104|      0|  uintptr_t cursor = (uintptr_t)executableHeader +
  105|      0|                     (is64bit ? sizeof(struct mach_header_64) : sizeof(struct mach_header));
  106|      0|  const struct segment_command *segmentCommand = NULL;
  107|      0|  uint32_t i = 0;
  108|       |
  109|      0|  while (i++ < executableHeader->ncmds) {
  110|      0|    segmentCommand = (struct segment_command *)cursor;
  111|       |
  112|      0|    if (!segmentCommand) {
  113|      0|      continue;
  114|      0|    }
  115|       |
  116|      0|    if ((!is64bit && segmentCommand->cmd == LC_ENCRYPTION_INFO) ||
  117|      0|        (is64bit && segmentCommand->cmd == LC_ENCRYPTION_INFO_64)) {
  118|      0|      if (is64bit) {
  119|      0|        struct encryption_info_command_64 *cryptCmd =
  120|      0|            (struct encryption_info_command_64 *)segmentCommand;
  121|      0|        return cryptCmd && cryptCmd->cryptid != 0;
  122|      0|      } else {
  123|      0|        struct encryption_info_command *cryptCmd = (struct encryption_info_command *)segmentCommand;
  124|      0|        return cryptCmd && cryptCmd->cryptid != 0;
  125|      0|      }
  126|      0|    }
  127|      0|    cursor += segmentCommand->cmdsize;
  128|      0|  }
  129|       |
  130|      0|  return NO;
  131|      0|}
  132|       |
  133|      0|static BOOL HasSCInfoFolder() {
  134|      0|#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH
  135|      0|  NSString *bundlePath = [NSBundle mainBundle].bundlePath;
  136|      0|  NSString *scInfoPath = [bundlePath stringByAppendingPathComponent:@"SC_Info"];
  137|      0|  return [[NSFileManager defaultManager] fileExistsAtPath:scInfoPath];
  138|       |#elif TARGET_OS_OSX
  139|       |  return NO;
  140|       |#endif
  141|      0|}
  142|       |
  143|      0|static BOOL HasEmbeddedMobileProvision() {
  144|      0|#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH
  145|      0|  return [[NSBundle mainBundle] pathForResource:@"embedded" ofType:@"mobileprovision"].length > 0;
  146|       |#elif TARGET_OS_OSX
  147|       |  return NO;
  148|       |#endif
  149|      0|}
  150|       |
  151|      0|+ (BOOL)isFromAppStore {
  152|      0|  static dispatch_once_t isEncryptedOnce;
  153|      0|  static BOOL isEncrypted = NO;
  154|       |
  155|      0|  dispatch_once(&isEncryptedOnce, ^{
  156|      0|    isEncrypted = IsAppEncrypted();
  157|      0|  });
  158|       |
  159|      0|  if ([GULAppEnvironmentUtil isSimulator]) {
  160|      0|    return NO;
  161|      0|  }
  162|       |
  163|       |  // If an app contain the sandboxReceipt file, it means its coming from TestFlight
  164|       |  // This must be checked before the SCInfo Folder check below since TestFlight apps may
  165|       |  // also have an SCInfo folder.
  166|      0|  if ([GULAppEnvironmentUtil isAppStoreReceiptSandbox]) {
  167|      0|    return NO;
  168|      0|  }
  169|       |
  170|      0|  if (HasSCInfoFolder()) {
  171|       |    // When iTunes downloads a .ipa, it also gets a customized .sinf file which is added to the
  172|       |    // main SC_Info directory.
  173|      0|    return YES;
  174|      0|  }
  175|       |
  176|       |  // For iOS >= 8.0, iTunesMetadata.plist is moved outside of the sandbox. Any attempt to read
  177|       |  // the iTunesMetadata.plist outside of the sandbox will be rejected by Apple.
  178|       |  // If the app does not contain the embedded.mobileprovision which is stripped out by Apple when
  179|       |  // the app is submitted to store, then it is highly likely that it is from Apple Store.
  180|      0|  return isEncrypted && !HasEmbeddedMobileProvision();
  181|      0|}
  182|       |
  183|      0|+ (BOOL)isAppStoreReceiptSandbox {
  184|       |  // Since checking the App Store's receipt URL can be memory intensive, check the option in the
  185|       |  // Info.plist if developers opted out of this check.
  186|      0|  id enableSandboxCheck =
  187|      0|      [[NSBundle mainBundle] objectForInfoDictionaryKey:kFIRAppStoreReceiptURLCheckEnabledKey];
  188|      0|  if (enableSandboxCheck && [enableSandboxCheck isKindOfClass:[NSNumber class]] &&
  189|      0|      ![enableSandboxCheck boolValue]) {
  190|      0|    return NO;
  191|      0|  }
  192|       |
  193|      0|  NSURL *appStoreReceiptURL = [NSBundle mainBundle].appStoreReceiptURL;
  194|      0|  NSString *appStoreReceiptFileName = appStoreReceiptURL.lastPathComponent;
  195|      0|  return [appStoreReceiptFileName isEqualToString:kFIRAIdentitySandboxReceiptFileName];
  196|      0|}
  197|       |
  198|      0|+ (BOOL)isSimulator {
  199|      0|#if TARGET_OS_SIMULATOR
  200|      0|  return YES;
  201|       |#elif TARGET_OS_MACCATALYST
  202|       |  return NO;
  203|       |#elif TARGET_OS_IOS || TARGET_OS_TV
  204|       |  NSString *platform = [GULAppEnvironmentUtil deviceModel];
  205|       |  return [platform isEqual:@"x86_64"] || [platform isEqual:@"i386"];
  206|       |#elif TARGET_OS_OSX
  207|       |  return NO;
  208|       |#endif
  209|      0|  return NO;
  210|      0|}
  211|       |
  212|      0|+ (NSString *)deviceModel {
  213|      0|  static dispatch_once_t once;
  214|      0|  static NSString *deviceModel;
  215|       |
  216|       |#if TARGET_OS_OSX || TARGET_OS_MACCATALYST
  217|       |  dispatch_once(&once, ^{
  218|       |    // The `uname` function only returns x86_64 for Macs. Use `sysctlbyname` instead, but fall back
  219|       |    // to the `uname` function if it fails.
  220|       |    size_t size;
  221|       |    sysctlbyname("hw.model", NULL, &size, NULL, 0);
  222|       |    if (size > 0) {
  223|       |      char *machine = malloc(size);
  224|       |      sysctlbyname("hw.model", machine, &size, NULL, 0);
  225|       |      deviceModel = [NSString stringWithCString:machine encoding:NSUTF8StringEncoding];
  226|       |      free(machine);
  227|       |    } else {
  228|       |      struct utsname systemInfo;
  229|       |      if (uname(&systemInfo) == 0) {
  230|       |        deviceModel = [NSString stringWithUTF8String:systemInfo.machine];
  231|       |      }
  232|       |    }
  233|       |  });
  234|       |#else
  235|      0|  dispatch_once(&once, ^{
  236|      0|    struct utsname systemInfo;
  237|      0|    if (uname(&systemInfo) == 0) {
  238|      0|      deviceModel = [NSString stringWithUTF8String:systemInfo.machine];
  239|      0|    }
  240|      0|  });
  241|      0|#endif  // TARGET_OS_OSX || TARGET_OS_MACCATALYST
  242|      0|  return deviceModel;
  243|      0|}
  244|       |
  245|      1|+ (NSString *)systemVersion {
  246|      1|#if TARGET_OS_IOS
  247|      1|  return [UIDevice currentDevice].systemVersion;
  248|       |#elif TARGET_OS_OSX || TARGET_OS_TV || TARGET_OS_WATCH
  249|       |  // Assemble the systemVersion, excluding the patch version if it's 0.
  250|       |  NSOperatingSystemVersion osVersion = [NSProcessInfo processInfo].operatingSystemVersion;
  251|       |  NSMutableString *versionString = [[NSMutableString alloc]
  252|       |      initWithFormat:@"%ld.%ld", (long)osVersion.majorVersion, (long)osVersion.minorVersion];
  253|       |  if (osVersion.patchVersion != 0) {
  254|       |    [versionString appendFormat:@".%ld", (long)osVersion.patchVersion];
  255|       |  }
  256|       |  return versionString;
  257|       |#endif
  258|      1|}
  259|       |
  260|      0|+ (BOOL)isAppExtension {
  261|      0|#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH
  262|       |  // Documented by <a href="https://goo.gl/RRB2Up">Apple</a>
  263|      0|  BOOL appExtension = [[[NSBundle mainBundle] bundlePath] hasSuffix:@".appex"];
  264|      0|  return appExtension;
  265|       |#elif TARGET_OS_OSX
  266|       |  return NO;
  267|       |#endif
  268|      0|}
  269|       |
  270|      0|+ (BOOL)isIOS7OrHigher {
  271|      0|  return YES;
  272|      0|}
  273|       |
  274|      0|+ (BOOL)hasSwiftRuntime {
  275|       |  // The class
  276|       |  // [Swift._SwiftObject](https://github.com/apple/swift/blob/5eac3e2818eb340b11232aff83edfbd1c307fa03/stdlib/public/runtime/SwiftObject.h#L35)
  277|       |  // is a part of Swift runtime, so it should be present if Swift runtime is available.
  278|       |
  279|      0|  BOOL hasSwiftRuntime =
  280|      0|      objc_lookUpClass("Swift._SwiftObject") != nil ||
  281|       |      // Swift object class name before
  282|       |      // https://github.com/apple/swift/commit/9637b4a6e11ddca72f5f6dbe528efc7c92f14d01
  283|      0|      objc_getClass("_TtCs12_SwiftObject") != nil;
  284|       |
  285|      0|  return hasSwiftRuntime;
  286|      0|}
  287|       |
  288|      0|+ (NSString *)applePlatform {
  289|      0|  NSString *applePlatform = @"unknown";
  290|       |
  291|       |  // When a Catalyst app is run on macOS then both `TARGET_OS_MACCATALYST` and `TARGET_OS_IOS` are
  292|       |  // `true`, which means the condition list is order-sensitive.
  293|       |#if TARGET_OS_MACCATALYST
  294|       |  applePlatform = @"maccatalyst";
  295|       |#elif TARGET_OS_IOS
  296|      0|#if defined(__IPHONE_14_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 140000
  297|      0|  if (@available(iOS 14.0, *)) {
  298|       |    // Early iOS 14 betas do not include isiOSAppOnMac (#6969)
  299|      0|    applePlatform = ([[NSProcessInfo processInfo] respondsToSelector:@selector(isiOSAppOnMac)] &&
  300|      0|                      [NSProcessInfo processInfo].isiOSAppOnMac) ? @"ios_on_mac" : @"ios";
  301|      0|  } else {
  302|      0|    applePlatform = @"ios";
  303|      0|  }
  304|       |#else // defined(__IPHONE_14_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 140000
  305|       |  applePlatform = @"ios";
  306|       |#endif // defined(__IPHONE_14_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 140000
  307|       |
  308|       |#elif TARGET_OS_TV
  309|       |  applePlatform = @"tvos";
  310|       |#elif TARGET_OS_OSX
  311|       |  applePlatform = @"macos";
  312|       |#elif TARGET_OS_WATCH
  313|       |  applePlatform = @"watchos";
  314|       |#endif // TARGET_OS_MACCATALYST
  315|       |
  316|      0|  return applePlatform;
  317|      0|}
  318|       |
  319|      0|+ (NSString *)deploymentType {
  320|       |#if SWIFT_PACKAGE
  321|       |  NSString *deploymentType = @"swiftpm";
  322|       |#elif FIREBASE_BUILD_CARTHAGE
  323|       |  NSString *deploymentType = @"carthage";
  324|       |#elif FIREBASE_BUILD_ZIP_FILE
  325|       |  NSString *deploymentType = @"zip";
  326|       |#else
  327|      0|  NSString *deploymentType = @"cocoapods";
  328|      0|#endif
  329|       |
  330|      0|  return deploymentType;
  331|      0|}
  332|       |
  333|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/Logger/GULLogger.m:
    1|       |// Copyright 2018 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/Logger/Public/GoogleUtilities/GULLogger.h"
   16|       |
   17|       |#include <asl.h>
   18|       |
   19|       |#import "GoogleUtilities/Environment/Public/GoogleUtilities/GULAppEnvironmentUtil.h"
   20|       |#import "GoogleUtilities/Logger/Public/GoogleUtilities/GULLoggerLevel.h"
   21|       |
   22|       |/// ASL client facility name used by GULLogger.
   23|       |const char *kGULLoggerASLClientFacilityName = "com.google.utilities.logger";
   24|       |
   25|       |static dispatch_once_t sGULLoggerOnceToken;
   26|       |
   27|       |static aslclient sGULLoggerClient;
   28|       |
   29|       |static dispatch_queue_t sGULClientQueue;
   30|       |
   31|       |static BOOL sGULLoggerDebugMode;
   32|       |
   33|       |static GULLoggerLevel sGULLoggerMaximumLevel;
   34|       |
   35|       |// Allow clients to register a version to include in the log.
   36|       |static NSString *sVersion = @"";
   37|       |
   38|       |static GULLoggerService kGULLoggerLogger = @"[GULLogger]";
   39|       |
   40|       |#ifdef DEBUG
   41|       |/// The regex pattern for the message code.
   42|       |static NSString *const kMessageCodePattern = @"^I-[A-Z]{3}[0-9]{6}$";
   43|       |static NSRegularExpression *sMessageCodeRegex;
   44|       |#endif
   45|       |
   46|      9|void GULLoggerInitializeASL(void) {
   47|      1|  dispatch_once(&sGULLoggerOnceToken, ^{
   48|      1|    NSInteger majorOSVersion = [[GULAppEnvironmentUtil systemVersion] integerValue];
   49|      1|    uint32_t aslOptions = ASL_OPT_STDERR;
   50|      1|#if TARGET_OS_SIMULATOR
   51|       |    // The iOS 11 simulator doesn't need the ASL_OPT_STDERR flag.
   52|      1|    if (majorOSVersion >= 11) {
   53|      1|      aslOptions = 0;
   54|      1|    }
   55|       |#else
   56|       |    // Devices running iOS 10 or higher don't need the ASL_OPT_STDERR flag.
   57|       |    if (majorOSVersion >= 10) {
   58|       |      aslOptions = 0;
   59|       |    }
   60|       |#endif  // TARGET_OS_SIMULATOR
   61|       |
   62|      1|#pragma clang diagnostic push
   63|      1|#pragma clang diagnostic ignored "-Wdeprecated-declarations"  // asl is deprecated
   64|       |    // Initialize the ASL client handle.
   65|      1|    sGULLoggerClient = asl_open(NULL, kGULLoggerASLClientFacilityName, aslOptions);
   66|      1|    sGULLoggerMaximumLevel = GULLoggerLevelNotice;
   67|       |
   68|       |    // Set the filter used by system/device log. Initialize in default mode.
   69|      1|    asl_set_filter(sGULLoggerClient, ASL_FILTER_MASK_UPTO(ASL_LEVEL_NOTICE));
   70|       |
   71|      1|    sGULClientQueue = dispatch_queue_create("GULLoggingClientQueue", DISPATCH_QUEUE_SERIAL);
   72|      1|    dispatch_set_target_queue(sGULClientQueue,
   73|      1|                              dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0));
   74|      1|#ifdef DEBUG
   75|      1|    sMessageCodeRegex = [NSRegularExpression regularExpressionWithPattern:kMessageCodePattern
   76|      1|                                                                  options:0
   77|      1|                                                                    error:NULL];
   78|      1|#endif
   79|      1|  });
   80|      9|}
   81|       |
   82|      0|void GULLoggerEnableSTDERR(void) {
   83|      0|  asl_add_log_file(sGULLoggerClient, STDERR_FILENO);
   84|      0|}
   85|       |
   86|      0|void GULLoggerForceDebug(void) {
   87|       |  // We should enable debug mode if we're not running from App Store.
   88|      0|  if (![GULAppEnvironmentUtil isFromAppStore]) {
   89|      0|    sGULLoggerDebugMode = YES;
   90|      0|    GULSetLoggerLevel(GULLoggerLevelDebug);
   91|      0|  }
   92|      0|}
   93|       |
   94|      0|__attribute__((no_sanitize("thread"))) void GULSetLoggerLevel(GULLoggerLevel loggerLevel) {
   95|      0|  if (loggerLevel < GULLoggerLevelMin || loggerLevel > GULLoggerLevelMax) {
   96|      0|    GULLogError(kGULLoggerLogger, NO, @"I-COR000023", @"Invalid logger level, %ld",
   97|      0|                (long)loggerLevel);
   98|      0|    return;
   99|      0|  }
  100|      0|  GULLoggerInitializeASL();
  101|       |  // We should not raise the logger level if we are running from App Store.
  102|      0|  if (loggerLevel >= GULLoggerLevelNotice && [GULAppEnvironmentUtil isFromAppStore]) {
  103|      0|    return;
  104|      0|  }
  105|       |
  106|      0|  sGULLoggerMaximumLevel = loggerLevel;
  107|      0|  dispatch_async(sGULClientQueue, ^{
  108|      0|    asl_set_filter(sGULLoggerClient, ASL_FILTER_MASK_UPTO(loggerLevel));
  109|      0|  });
  110|      0|}
  111|       |
  112|       |/**
  113|       | * Check if the level is high enough to be loggable.
  114|       | */
  115|      6|__attribute__((no_sanitize("thread"))) BOOL GULIsLoggableLevel(GULLoggerLevel loggerLevel) {
  116|      6|  GULLoggerInitializeASL();
  117|      6|  if (sGULLoggerDebugMode) {
  118|      0|    return YES;
  119|      0|  }
  120|      6|  return (BOOL)(loggerLevel <= sGULLoggerMaximumLevel);
  121|      6|}
  122|       |
  123|       |#ifdef DEBUG
  124|      0|void GULResetLogger(void) {
  125|      0|  sGULLoggerOnceToken = 0;
  126|      0|  sGULLoggerDebugMode = NO;
  127|      0|}
  128|       |
  129|      0|aslclient getGULLoggerClient(void) {
  130|      0|  return sGULLoggerClient;
  131|      0|}
  132|       |
  133|      0|dispatch_queue_t getGULClientQueue(void) {
  134|      0|  return sGULClientQueue;
  135|      0|}
  136|       |
  137|      0|BOOL getGULLoggerDebugMode(void) {
  138|      0|  return sGULLoggerDebugMode;
  139|      0|}
  140|       |#endif
  141|       |
  142|      0|void GULLoggerRegisterVersion(NSString *version) {
  143|      0|  sVersion = version;
  144|      0|}
  145|       |
  146|       |void GULLogBasic(GULLoggerLevel level,
  147|       |                 GULLoggerService service,
  148|       |                 BOOL forceLog,
  149|       |                 NSString *messageCode,
  150|       |                 NSString *message,
  151|      3|                 va_list args_ptr) {
  152|      3|  GULLoggerInitializeASL();
  153|      3|  if (!(level <= sGULLoggerMaximumLevel || sGULLoggerDebugMode || forceLog)) {
  154|      0|    return;
  155|      0|  }
  156|       |
  157|      3|#ifdef DEBUG
  158|      3|  NSCAssert(messageCode.length == 11, @"Incorrect message code length.");
  159|      3|  NSRange messageCodeRange = NSMakeRange(0, messageCode.length);
  160|      3|  NSUInteger numberOfMatches = [sMessageCodeRegex numberOfMatchesInString:messageCode
  161|      3|                                                                  options:0
  162|      3|                                                                    range:messageCodeRange];
  163|      3|  NSCAssert(numberOfMatches == 1, @"Incorrect message code format.");
  164|      3|#endif
  165|      3|  NSString *logMsg;
  166|      3|  if (args_ptr == NULL) {
  167|      3|    logMsg = message;
  168|      0|  } else {
  169|      0|    logMsg = [[NSString alloc] initWithFormat:message arguments:args_ptr];
  170|      0|  }
  171|      3|  logMsg = [NSString stringWithFormat:@"%@ - %@[%@] %@", sVersion, service, messageCode, logMsg];
  172|      3|  dispatch_async(sGULClientQueue, ^{
  173|      3|    asl_log(sGULLoggerClient, NULL, (int)level, "%s", logMsg.UTF8String);
  174|      3|  });
  175|      3|}
  176|       |#pragma clang diagnostic pop
  177|       |
  178|       |/**
  179|       | * Generates the logging functions using macros.
  180|       | *
  181|       | * Calling GULLogError({service}, @"I-XYZ000001", @"Configure %@ failed.", @"blah") shows:
  182|       | * yyyy-mm-dd hh:mm:ss.SSS sender[PID] <Error> [{service}][I-XYZ000001] Configure blah failed.
  183|       | * Calling GULLogDebug({service}, @"I-XYZ000001", @"Configure succeed.") shows:
  184|       | * yyyy-mm-dd hh:mm:ss.SSS sender[PID] <Debug> [{service}][I-XYZ000001] Configure succeed.
  185|       | */
  186|       |#define GUL_LOGGING_FUNCTION(level)                                                     \
  187|       |  void GULLog##level(GULLoggerService service, BOOL force, NSString *messageCode,       \
  188|      0|                     NSString *message, ...) {                                          \
  189|      0|    va_list args_ptr;                                                                   \
  190|      0|    va_start(args_ptr, message);                                                        \
  191|      0|    GULLogBasic(GULLoggerLevel##level, service, force, messageCode, message, args_ptr); \
  192|      0|    va_end(args_ptr);                                                                   \
  193|      0|  }
  ------------------
  | Unexecuted instantiation: GULLogError
  ------------------
  | Unexecuted instantiation: GULLogWarning
  ------------------
  | Unexecuted instantiation: GULLogNotice
  ------------------
  | Unexecuted instantiation: GULLogInfo
  ------------------
  | Unexecuted instantiation: GULLogDebug
  ------------------
  194|       |
  195|       |GUL_LOGGING_FUNCTION(Error)
  196|       |GUL_LOGGING_FUNCTION(Warning)
  197|       |GUL_LOGGING_FUNCTION(Notice)
  198|       |GUL_LOGGING_FUNCTION(Info)
  199|       |GUL_LOGGING_FUNCTION(Debug)
  200|       |
  201|       |#undef GUL_MAKE_LOGGER
  202|       |
  203|       |#pragma mark - GULLoggerWrapper
  204|       |
  205|       |@implementation GULLoggerWrapper
  206|       |
  207|       |+ (void)logWithLevel:(GULLoggerLevel)level
  208|       |         withService:(GULLoggerService)service
  209|       |            withCode:(NSString *)messageCode
  210|       |         withMessage:(NSString *)message
  211|      0|            withArgs:(va_list)args {
  212|      0|  GULLogBasic(level, service, NO, messageCode, message, args);
  213|      0|}
  214|       |
  215|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/MethodSwizzler/GULSwizzler.m:
    1|       |// Copyright 2018 Google LLC
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/MethodSwizzler/Public/GoogleUtilities/GULSwizzler.h"
   16|       |
   17|       |#import <objc/runtime.h>
   18|       |
   19|       |#ifdef DEBUG
   20|       |#import "GoogleUtilities/Common/GULLoggerCodes.h"
   21|       |#import "GoogleUtilities/Logger/Public/GoogleUtilities/GULLogger.h"
   22|       |
   23|       |static GULLoggerService kGULLoggerSwizzler = @"[GoogleUtilities/MethodSwizzler]";
   24|       |#endif
   25|       |
   26|      4|dispatch_queue_t GetGULSwizzlingQueue(void) {
   27|      4|  static dispatch_queue_t queue;
   28|      4|  static dispatch_once_t onceToken;
   29|      1|  dispatch_once(&onceToken, ^{
   30|      1|    queue = dispatch_queue_create("com.google.GULSwizzler", DISPATCH_QUEUE_SERIAL);
   31|      1|  });
   32|      4|  return queue;
   33|      4|}
   34|       |
   35|       |@implementation GULSwizzler
   36|       |
   37|       |+ (void)swizzleClass:(Class)aClass
   38|       |            selector:(SEL)selector
   39|       |     isClassSelector:(BOOL)isClassSelector
   40|      2|           withBlock:(nullable id)block {
   41|      2|  dispatch_sync(GetGULSwizzlingQueue(), ^{
   42|      2|    NSAssert(selector, @"The selector cannot be NULL");
   43|      2|    NSAssert(aClass, @"The class cannot be Nil");
   44|      2|    Class resolvedClass = aClass;
   45|      2|    Method method = nil;
   46|      2|    if (isClassSelector) {
   47|      0|      method = class_getClassMethod(aClass, selector);
   48|      0|      resolvedClass = object_getClass(aClass);
   49|      2|    } else {
   50|      2|      method = class_getInstanceMethod(aClass, selector);
   51|      2|    }
   52|      2|    NSAssert(method, @"You're attempting to swizzle a method that doesn't exist. (%@, %@)",
   53|      2|             NSStringFromClass(resolvedClass), NSStringFromSelector(selector));
   54|      2|    IMP newImp = imp_implementationWithBlock(block);
   55|      2|#ifdef DEBUG
   56|      2|    IMP currentImp = class_getMethodImplementation(resolvedClass, selector);
   57|      2|    Class class = NSClassFromString(@"GULSwizzlingCache");
   58|      2|    if (class) {
   59|      0|      SEL cacheSelector = NSSelectorFromString(@"cacheCurrentIMP:forNewIMP:forClass:withSelector:");
   60|      0|      NSMethodSignature *methodSignature = [class methodSignatureForSelector:cacheSelector];
   61|      0|      if (methodSignature != nil) {
   62|      0|        NSInvocation *inv = [NSInvocation invocationWithMethodSignature:methodSignature];
   63|      0|        [inv setSelector:cacheSelector];
   64|      0|        [inv setTarget:class];
   65|      0|        [inv setArgument:&(currentImp) atIndex:2];
   66|      0|        [inv setArgument:&(newImp) atIndex:3];
   67|      0|        [inv setArgument:&(resolvedClass) atIndex:4];
   68|      0|        [inv setArgument:(void *_Nonnull)&(selector) atIndex:5];
   69|      0|        [inv invoke];
   70|      0|      }
   71|      0|    }
   72|      2|#endif
   73|       |
   74|      2|    const char *typeEncoding = method_getTypeEncoding(method);
   75|      2|    __unused IMP originalImpOfClass =
   76|      2|        class_replaceMethod(resolvedClass, selector, newImp, typeEncoding);
   77|       |
   78|      2|#ifdef DEBUG
   79|       |    // If !originalImpOfClass, then the IMP came from a superclass.
   80|      2|    if (originalImpOfClass) {
   81|      2|      SEL selector = NSSelectorFromString(@"originalIMPOfCurrentIMP:");
   82|      2|      NSMethodSignature *methodSignature = [class methodSignatureForSelector:selector];
   83|      2|      if (methodSignature != nil) {
   84|      0|        NSInvocation *inv = [NSInvocation invocationWithMethodSignature:methodSignature];
   85|      0|        [inv setSelector:selector];
   86|      0|        [inv setTarget:class];
   87|      0|        [inv setArgument:&(currentImp) atIndex:2];
   88|      0|        [inv invoke];
   89|      0|        IMP testOriginal;
   90|      0|        [inv getReturnValue:&testOriginal];
   91|      0|        if (originalImpOfClass != testOriginal) {
   92|      0|          GULLogWarning(kGULLoggerSwizzler, NO,
   93|      0|                        [NSString stringWithFormat:@"I-SWZ%06ld",
   94|      0|                                                   (long)kGULSwizzlerMessageCodeMethodSwizzling000],
   95|      0|                        @"Swizzling class: %@ SEL:%@ after it has been previously been swizzled.",
   96|      0|                        NSStringFromClass(resolvedClass), NSStringFromSelector(selector));
   97|      0|        }
   98|      0|      }
   99|      2|    }
  100|      2|#endif
  101|      2|  });
  102|      2|}
  103|       |
  104|       |+ (nullable IMP)currentImplementationForClass:(Class)aClass
  105|       |                                     selector:(SEL)selector
  106|      2|                              isClassSelector:(BOOL)isClassSelector {
  107|      2|  NSAssert(selector, @"The selector cannot be NULL");
  108|      2|  NSAssert(aClass, @"The class cannot be Nil");
  109|      2|  if (selector == NULL || aClass == nil) {
  110|      0|    return nil;
  111|      0|  }
  112|      2|  __block IMP currentIMP = nil;
  113|      2|  dispatch_sync(GetGULSwizzlingQueue(), ^{
  114|      2|    Method method = nil;
  115|      2|    if (isClassSelector) {
  116|      0|      method = class_getClassMethod(aClass, selector);
  117|      2|    } else {
  118|      2|      method = class_getInstanceMethod(aClass, selector);
  119|      2|    }
  120|      2|    NSAssert(method, @"The Method for this class/selector combo doesn't exist (%@, %@).",
  121|      2|             NSStringFromClass(aClass), NSStringFromSelector(selector));
  122|      2|    if (method == nil) {
  123|      0|      return;
  124|      0|    }
  125|      2|    currentIMP = method_getImplementation(method);
  126|      2|    NSAssert(currentIMP, @"The IMP for this class/selector combo doesn't exist (%@, %@).",
  127|      2|             NSStringFromClass(aClass), NSStringFromSelector(selector));
  128|      2|  });
  129|      2|  return currentIMP;
  130|      2|}
  131|       |
  132|      0|+ (BOOL)selector:(SEL)selector existsInClass:(Class)aClass isClassSelector:(BOOL)isClassSelector {
  133|      0|  Method method = isClassSelector ? class_getClassMethod(aClass, selector)
  134|      0|                                  : class_getInstanceMethod(aClass, selector);
  135|      0|  return method != nil;
  136|      0|}
  137|       |
  138|      0|+ (NSArray<id> *)ivarObjectsForObject:(id)object {
  139|      0|  NSMutableArray *array = [NSMutableArray array];
  140|      0|  unsigned int count;
  141|      0|  Ivar *vars = class_copyIvarList([object class], &count);
  142|      0|  for (NSUInteger i = 0; i < count; i++) {
  143|      0|    const char *typeEncoding = ivar_getTypeEncoding(vars[i]);
  144|       |    // Check to see if the ivar is an object.
  145|      0|    if (strncmp(typeEncoding, "@", 1) == 0) {
  146|      0|      id ivarObject = object_getIvar(object, vars[i]);
  147|      0|      [array addObject:ivarObject];
  148|      0|    }
  149|      0|  }
  150|      0|  free(vars);
  151|      0|  return array;
  152|      0|}
  153|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/NSData+zlib/GULNSData+zlib.m:
    1|       |// Copyright 2018 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/NSData+zlib/Public/GoogleUtilities/GULNSData+zlib.h"
   16|       |
   17|       |#import <zlib.h>
   18|       |
   19|      0|#define kChunkSize 1024
   20|      0|#define Z_DEFAULT_COMPRESSION (-1)
   21|       |
   22|       |NSString *const GULNSDataZlibErrorDomain = @"com.google.GULNSDataZlibErrorDomain";
   23|       |NSString *const GULNSDataZlibErrorKey = @"GULNSDataZlibErrorKey";
   24|       |NSString *const GULNSDataZlibRemainingBytesKey = @"GULNSDataZlibRemainingBytesKey";
   25|       |
   26|       |@implementation NSData (GULGzip)
   27|       |
   28|      0|+ (NSData *)gul_dataByInflatingGzippedData:(NSData *)data error:(NSError **)error {
   29|      0|  const void *bytes = [data bytes];
   30|      0|  NSUInteger length = [data length];
   31|      0|  if (!bytes || !length) {
   32|      0|    return nil;
   33|      0|  }
   34|       |
   35|      0|#if defined(__LP64__) && __LP64__
   36|       |  // Don't support > 32bit length for 64 bit, see note in header.
   37|      0|  if (length > UINT_MAX) {
   38|      0|    return nil;
   39|      0|  }
   40|      0|#endif
   41|       |
   42|      0|  z_stream strm;
   43|      0|  bzero(&strm, sizeof(z_stream));
   44|       |
   45|       |  // Setup the input.
   46|      0|  strm.avail_in = (unsigned int)length;
   47|      0|  strm.next_in = (unsigned char *)bytes;
   48|       |
   49|      0|  int windowBits = 15;  // 15 to enable any window size
   50|      0|  windowBits += 32;     // and +32 to enable zlib or gzip header detection.
   51|       |
   52|      0|  int retCode;
   53|      0|  if ((retCode = inflateInit2(&strm, windowBits)) != Z_OK) {
   54|      0|    if (error) {
   55|      0|      NSDictionary *userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
   56|      0|                                                           forKey:GULNSDataZlibErrorKey];
   57|      0|      *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
   58|      0|                                   code:GULNSDataZlibErrorInternal
   59|      0|                               userInfo:userInfo];
   60|      0|    }
   61|      0|    return nil;
   62|      0|  }
   63|       |
   64|       |  // Hint the size at 4x the input size.
   65|      0|  NSMutableData *result = [NSMutableData dataWithCapacity:(length * 4)];
   66|      0|  unsigned char output[kChunkSize];
   67|       |
   68|       |  // Loop to collect the data.
   69|      0|  do {
   70|       |    // Update what we're passing in.
   71|      0|    strm.avail_out = kChunkSize;
   72|      0|    strm.next_out = output;
   73|      0|    retCode = inflate(&strm, Z_NO_FLUSH);
   74|      0|    if ((retCode != Z_OK) && (retCode != Z_STREAM_END)) {
   75|      0|      if (error) {
   76|      0|        NSMutableDictionary *userInfo =
   77|      0|            [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
   78|      0|                                               forKey:GULNSDataZlibErrorKey];
   79|      0|        if (strm.msg) {
   80|      0|          NSString *message = [NSString stringWithUTF8String:strm.msg];
   81|      0|          if (message) {
   82|      0|            [userInfo setObject:message forKey:NSLocalizedDescriptionKey];
   83|      0|          }
   84|      0|        }
   85|      0|        *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
   86|      0|                                     code:GULNSDataZlibErrorInternal
   87|      0|                                 userInfo:userInfo];
   88|      0|      }
   89|      0|      inflateEnd(&strm);
   90|      0|      return nil;
   91|      0|    }
   92|       |    // Collect what we got.
   93|      0|    unsigned gotBack = kChunkSize - strm.avail_out;
   94|      0|    if (gotBack > 0) {
   95|      0|      [result appendBytes:output length:gotBack];
   96|      0|    }
   97|       |
   98|      0|  } while (retCode == Z_OK);
   99|       |
  100|       |  // Make sure there wasn't more data tacked onto the end of a valid compressed stream.
  101|      0|  if (strm.avail_in != 0) {
  102|      0|    if (error) {
  103|      0|      NSDictionary *userInfo =
  104|      0|          [NSDictionary dictionaryWithObject:[NSNumber numberWithUnsignedInt:strm.avail_in]
  105|      0|                                      forKey:GULNSDataZlibRemainingBytesKey];
  106|      0|      *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
  107|      0|                                   code:GULNSDataZlibErrorDataRemaining
  108|      0|                               userInfo:userInfo];
  109|      0|    }
  110|      0|    result = nil;
  111|      0|  }
  112|       |  // The only way out of the loop was by hitting the end of the stream.
  113|      0|  NSAssert(retCode == Z_STREAM_END,
  114|      0|           @"Thought we finished inflate w/o getting a result of stream end, code %d", retCode);
  115|       |
  116|       |  // Clean up.
  117|      0|  inflateEnd(&strm);
  118|       |
  119|      0|  return result;
  120|      0|}
  121|       |
  122|      0|+ (NSData *)gul_dataByGzippingData:(NSData *)data error:(NSError **)error {
  123|      0|  const void *bytes = [data bytes];
  124|      0|  NSUInteger length = [data length];
  125|       |
  126|      0|  int level = Z_DEFAULT_COMPRESSION;
  127|      0|  if (!bytes || !length) {
  128|      0|    return nil;
  129|      0|  }
  130|       |
  131|      0|#if defined(__LP64__) && __LP64__
  132|       |  // Don't support > 32bit length for 64 bit, see note in header.
  133|      0|  if (length > UINT_MAX) {
  134|      0|    if (error) {
  135|      0|      *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
  136|      0|                                   code:GULNSDataZlibErrorGreaterThan32BitsToCompress
  137|      0|                               userInfo:nil];
  138|      0|    }
  139|      0|    return nil;
  140|      0|  }
  141|      0|#endif
  142|       |
  143|      0|  z_stream strm;
  144|      0|  bzero(&strm, sizeof(z_stream));
  145|       |
  146|      0|  int memLevel = 8;          // Default.
  147|      0|  int windowBits = 15 + 16;  // Enable gzip header instead of zlib header.
  148|       |
  149|      0|  int retCode;
  150|      0|  if ((retCode = deflateInit2(&strm, level, Z_DEFLATED, windowBits, memLevel,
  151|      0|                              Z_DEFAULT_STRATEGY)) != Z_OK) {
  152|      0|    if (error) {
  153|      0|      NSDictionary *userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
  154|      0|                                                           forKey:GULNSDataZlibErrorKey];
  155|      0|      *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
  156|      0|                                   code:GULNSDataZlibErrorInternal
  157|      0|                               userInfo:userInfo];
  158|      0|    }
  159|      0|    return nil;
  160|      0|  }
  161|       |
  162|       |  // Hint the size at 1/4 the input size.
  163|      0|  NSMutableData *result = [NSMutableData dataWithCapacity:(length / 4)];
  164|      0|  unsigned char output[kChunkSize];
  165|       |
  166|       |  // Setup the input.
  167|      0|  strm.avail_in = (unsigned int)length;
  168|      0|  strm.next_in = (unsigned char *)bytes;
  169|       |
  170|       |  // Collect the data.
  171|      0|  do {
  172|       |    // update what we're passing in
  173|      0|    strm.avail_out = kChunkSize;
  174|      0|    strm.next_out = output;
  175|      0|    retCode = deflate(&strm, Z_FINISH);
  176|      0|    if ((retCode != Z_OK) && (retCode != Z_STREAM_END)) {
  177|      0|      if (error) {
  178|      0|        NSDictionary *userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
  179|      0|                                                             forKey:GULNSDataZlibErrorKey];
  180|      0|        *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
  181|      0|                                     code:GULNSDataZlibErrorInternal
  182|      0|                                 userInfo:userInfo];
  183|      0|      }
  184|      0|      deflateEnd(&strm);
  185|      0|      return nil;
  186|      0|    }
  187|       |    // Collect what we got.
  188|      0|    unsigned gotBack = kChunkSize - strm.avail_out;
  189|      0|    if (gotBack > 0) {
  190|      0|      [result appendBytes:output length:gotBack];
  191|      0|    }
  192|       |
  193|      0|  } while (retCode == Z_OK);
  194|       |
  195|       |  // If the loop exits, it used all input and the stream ended.
  196|      0|  NSAssert(strm.avail_in == 0,
  197|      0|           @"Should have finished deflating without using all input, %u bytes left", strm.avail_in);
  198|      0|  NSAssert(retCode == Z_STREAM_END,
  199|      0|           @"thought we finished deflate w/o getting a result of stream end, code %d", retCode);
  200|       |
  201|       |  // Clean up.
  202|      0|  deflateEnd(&strm);
  203|       |
  204|      0|  return result;
  205|      0|}
  206|       |
  207|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/Network/GULMutableDictionary.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/Network/Public/GoogleUtilities/GULMutableDictionary.h"
   16|       |
   17|       |@implementation GULMutableDictionary {
   18|       |  /// The mutable dictionary.
   19|       |  NSMutableDictionary *_objects;
   20|       |
   21|       |  /// Serial synchronization queue. All reads should use dispatch_sync, while writes use
   22|       |  /// dispatch_async.
   23|       |  dispatch_queue_t _queue;
   24|       |}
   25|       |
   26|      0|- (instancetype)init {
   27|      0|  self = [super init];
   28|       |
   29|      0|  if (self) {
   30|      0|    _objects = [[NSMutableDictionary alloc] init];
   31|      0|    _queue = dispatch_queue_create("GULMutableDictionary", DISPATCH_QUEUE_SERIAL);
   32|      0|  }
   33|       |
   34|      0|  return self;
   35|      0|}
   36|       |
   37|      0|- (NSString *)description {
   38|      0|  __block NSString *description;
   39|      0|  dispatch_sync(_queue, ^{
   40|      0|    description = self->_objects.description;
   41|      0|  });
   42|      0|  return description;
   43|      0|}
   44|       |
   45|      0|- (id)objectForKey:(id)key {
   46|      0|  __block id object;
   47|      0|  dispatch_sync(_queue, ^{
   48|      0|    object = [self->_objects objectForKey:key];
   49|      0|  });
   50|      0|  return object;
   51|      0|}
   52|       |
   53|      0|- (void)setObject:(id)object forKey:(id<NSCopying>)key {
   54|      0|  dispatch_async(_queue, ^{
   55|      0|    [self->_objects setObject:object forKey:key];
   56|      0|  });
   57|      0|}
   58|       |
   59|      0|- (void)removeObjectForKey:(id)key {
   60|      0|  dispatch_async(_queue, ^{
   61|      0|    [self->_objects removeObjectForKey:key];
   62|      0|  });
   63|      0|}
   64|       |
   65|      0|- (void)removeAllObjects {
   66|      0|  dispatch_async(_queue, ^{
   67|      0|    [self->_objects removeAllObjects];
   68|      0|  });
   69|      0|}
   70|       |
   71|      0|- (NSUInteger)count {
   72|      0|  __block NSUInteger count;
   73|      0|  dispatch_sync(_queue, ^{
   74|      0|    count = self->_objects.count;
   75|      0|  });
   76|      0|  return count;
   77|      0|}
   78|       |
   79|      0|- (id)objectForKeyedSubscript:(id<NSCopying>)key {
   80|      0|  __block id object;
   81|      0|  dispatch_sync(_queue, ^{
   82|      0|    object = self->_objects[key];
   83|      0|  });
   84|      0|  return object;
   85|      0|}
   86|       |
   87|      0|- (void)setObject:(id)obj forKeyedSubscript:(id<NSCopying>)key {
   88|      0|  dispatch_async(_queue, ^{
   89|      0|    self->_objects[key] = obj;
   90|      0|  });
   91|      0|}
   92|       |
   93|      0|- (NSDictionary *)dictionary {
   94|      0|  __block NSDictionary *dictionary;
   95|      0|  dispatch_sync(_queue, ^{
   96|      0|    dictionary = [self->_objects copy];
   97|      0|  });
   98|      0|  return dictionary;
   99|      0|}
  100|       |
  101|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/Network/GULNetwork.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/Network/Public/GoogleUtilities/GULNetwork.h"
   16|       |#import "GoogleUtilities/Network/Public/GoogleUtilities/GULNetworkMessageCode.h"
   17|       |
   18|       |#import "GoogleUtilities/Logger/Public/GoogleUtilities/GULLogger.h"
   19|       |#import "GoogleUtilities/NSData+zlib/Public/GoogleUtilities/GULNSData+zlib.h"
   20|       |#import "GoogleUtilities/Network/GULNetworkInternal.h"
   21|       |#import "GoogleUtilities/Network/Public/GoogleUtilities/GULMutableDictionary.h"
   22|       |#import "GoogleUtilities/Network/Public/GoogleUtilities/GULNetworkConstants.h"
   23|       |#import "GoogleUtilities/Reachability/Public/GoogleUtilities/GULReachabilityChecker.h"
   24|       |
   25|       |/// Constant string for request header Content-Encoding.
   26|       |static NSString *const kGULNetworkContentCompressionKey = @"Content-Encoding";
   27|       |
   28|       |/// Constant string for request header Content-Encoding value.
   29|       |static NSString *const kGULNetworkContentCompressionValue = @"gzip";
   30|       |
   31|       |/// Constant string for request header Content-Length.
   32|       |static NSString *const kGULNetworkContentLengthKey = @"Content-Length";
   33|       |
   34|       |/// Constant string for request header Content-Type.
   35|       |static NSString *const kGULNetworkContentTypeKey = @"Content-Type";
   36|       |
   37|       |/// Constant string for request header Content-Type value.
   38|       |static NSString *const kGULNetworkContentTypeValue = @"application/x-www-form-urlencoded";
   39|       |
   40|       |/// Constant string for GET request method.
   41|       |static NSString *const kGULNetworkGETRequestMethod = @"GET";
   42|       |
   43|       |/// Constant string for POST request method.
   44|       |static NSString *const kGULNetworkPOSTRequestMethod = @"POST";
   45|       |
   46|       |/// Default constant string as a prefix for network logger.
   47|       |static NSString *const kGULNetworkLogTag = @"Google/Utilities/Network";
   48|       |
   49|       |@interface GULNetwork () <GULReachabilityDelegate, GULNetworkLoggerDelegate>
   50|       |@end
   51|       |
   52|       |@implementation GULNetwork {
   53|       |  /// Network reachability.
   54|       |  GULReachabilityChecker *_reachability;
   55|       |
   56|       |  /// The dictionary of requests by session IDs { NSString : id }.
   57|       |  GULMutableDictionary *_requests;
   58|       |}
   59|       |
   60|      0|- (instancetype)init {
   61|      0|  return [self initWithReachabilityHost:kGULNetworkReachabilityHost];
   62|      0|}
   63|       |
   64|      0|- (instancetype)initWithReachabilityHost:(NSString *)reachabilityHost {
   65|      0|  self = [super init];
   66|      0|  if (self) {
   67|       |    // Setup reachability.
   68|      0|    _reachability = [[GULReachabilityChecker alloc] initWithReachabilityDelegate:self
   69|      0|                                                                        withHost:reachabilityHost];
   70|      0|    if (![_reachability start]) {
   71|      0|      return nil;
   72|      0|    }
   73|       |
   74|      0|    _requests = [[GULMutableDictionary alloc] init];
   75|      0|    _timeoutInterval = kGULNetworkTimeOutInterval;
   76|      0|  }
   77|      0|  return self;
   78|      0|}
   79|       |
   80|      0|- (void)dealloc {
   81|      0|  _reachability.reachabilityDelegate = nil;
   82|      0|  [_reachability stop];
   83|      0|}
   84|       |
   85|       |#pragma mark - External Methods
   86|       |
   87|       |+ (void)handleEventsForBackgroundURLSessionID:(NSString *)sessionID
   88|      0|                            completionHandler:(GULNetworkSystemCompletionHandler)completionHandler {
   89|      0|  [GULNetworkURLSession handleEventsForBackgroundURLSessionID:sessionID
   90|      0|                                            completionHandler:completionHandler];
   91|      0|}
   92|       |
   93|       |- (NSString *)postURL:(NSURL *)url
   94|       |                   payload:(NSData *)payload
   95|       |                     queue:(dispatch_queue_t)queue
   96|       |    usingBackgroundSession:(BOOL)usingBackgroundSession
   97|      0|         completionHandler:(GULNetworkCompletionHandler)handler {
   98|      0|  if (!url.absoluteString.length) {
   99|      0|    [self handleErrorWithCode:GULErrorCodeNetworkInvalidURL queue:queue withHandler:handler];
  100|      0|    return nil;
  101|      0|  }
  102|       |
  103|      0|  NSTimeInterval timeOutInterval = _timeoutInterval ?: kGULNetworkTimeOutInterval;
  104|       |
  105|      0|  NSMutableURLRequest *request =
  106|      0|      [[NSMutableURLRequest alloc] initWithURL:url
  107|      0|                                   cachePolicy:NSURLRequestReloadIgnoringLocalCacheData
  108|      0|                               timeoutInterval:timeOutInterval];
  109|       |
  110|      0|  if (!request) {
  111|      0|    [self handleErrorWithCode:GULErrorCodeNetworkSessionTaskCreation
  112|      0|                        queue:queue
  113|      0|                  withHandler:handler];
  114|      0|    return nil;
  115|      0|  }
  116|       |
  117|      0|  NSError *compressError = nil;
  118|      0|  NSData *compressedData = [NSData gul_dataByGzippingData:payload error:&compressError];
  119|      0|  if (!compressedData || compressError) {
  120|      0|    if (compressError || payload.length > 0) {
  121|       |      // If the payload is not empty but it fails to compress the payload, something has been wrong.
  122|      0|      [self handleErrorWithCode:GULErrorCodeNetworkPayloadCompression
  123|      0|                          queue:queue
  124|      0|                    withHandler:handler];
  125|      0|      return nil;
  126|      0|    }
  127|      0|    compressedData = [[NSData alloc] init];
  128|      0|  }
  129|       |
  130|      0|  NSString *postLength = @(compressedData.length).stringValue;
  131|       |
  132|       |  // Set up the request with the compressed data.
  133|      0|  [request setValue:postLength forHTTPHeaderField:kGULNetworkContentLengthKey];
  134|      0|  request.HTTPBody = compressedData;
  135|      0|  request.HTTPMethod = kGULNetworkPOSTRequestMethod;
  136|      0|  [request setValue:kGULNetworkContentTypeValue forHTTPHeaderField:kGULNetworkContentTypeKey];
  137|      0|  [request setValue:kGULNetworkContentCompressionValue
  138|      0|      forHTTPHeaderField:kGULNetworkContentCompressionKey];
  139|       |
  140|      0|  GULNetworkURLSession *fetcher = [[GULNetworkURLSession alloc] initWithNetworkLoggerDelegate:self];
  141|      0|  fetcher.backgroundNetworkEnabled = usingBackgroundSession;
  142|       |
  143|      0|  __weak GULNetwork *weakSelf = self;
  144|      0|  NSString *requestID = [fetcher
  145|      0|      sessionIDFromAsyncPOSTRequest:request
  146|      0|                  completionHandler:^(NSHTTPURLResponse *response, NSData *data,
  147|      0|                                      NSString *sessionID, NSError *error) {
  148|      0|                    GULNetwork *strongSelf = weakSelf;
  149|      0|                    if (!strongSelf) {
  150|      0|                      return;
  151|      0|                    }
  152|      0|                    dispatch_queue_t queueToDispatch = queue ? queue : dispatch_get_main_queue();
  153|      0|                    dispatch_async(queueToDispatch, ^{
  154|      0|                      if (sessionID.length) {
  155|      0|                        [strongSelf->_requests removeObjectForKey:sessionID];
  156|      0|                      }
  157|      0|                      if (handler) {
  158|      0|                        handler(response, data, error);
  159|      0|                      }
  160|      0|                    });
  161|      0|                  }];
  162|      0|  if (!requestID) {
  163|      0|    [self handleErrorWithCode:GULErrorCodeNetworkSessionTaskCreation
  164|      0|                        queue:queue
  165|      0|                  withHandler:handler];
  166|      0|    return nil;
  167|      0|  }
  168|       |
  169|      0|  [self GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  170|      0|                    messageCode:kGULNetworkMessageCodeNetwork000
  171|      0|                        message:@"Uploading data. Host"
  172|      0|                        context:url];
  173|      0|  _requests[requestID] = fetcher;
  174|      0|  return requestID;
  175|      0|}
  176|       |
  177|       |- (NSString *)getURL:(NSURL *)url
  178|       |                   headers:(NSDictionary *)headers
  179|       |                     queue:(dispatch_queue_t)queue
  180|       |    usingBackgroundSession:(BOOL)usingBackgroundSession
  181|      0|         completionHandler:(GULNetworkCompletionHandler)handler {
  182|      0|  if (!url.absoluteString.length) {
  183|      0|    [self handleErrorWithCode:GULErrorCodeNetworkInvalidURL queue:queue withHandler:handler];
  184|      0|    return nil;
  185|      0|  }
  186|       |
  187|      0|  NSTimeInterval timeOutInterval = _timeoutInterval ?: kGULNetworkTimeOutInterval;
  188|      0|  NSMutableURLRequest *request =
  189|      0|      [[NSMutableURLRequest alloc] initWithURL:url
  190|      0|                                   cachePolicy:NSURLRequestReloadIgnoringLocalCacheData
  191|      0|                               timeoutInterval:timeOutInterval];
  192|       |
  193|      0|  if (!request) {
  194|      0|    [self handleErrorWithCode:GULErrorCodeNetworkSessionTaskCreation
  195|      0|                        queue:queue
  196|      0|                  withHandler:handler];
  197|      0|    return nil;
  198|      0|  }
  199|       |
  200|      0|  request.HTTPMethod = kGULNetworkGETRequestMethod;
  201|      0|  request.allHTTPHeaderFields = headers;
  202|       |
  203|      0|  GULNetworkURLSession *fetcher = [[GULNetworkURLSession alloc] initWithNetworkLoggerDelegate:self];
  204|      0|  fetcher.backgroundNetworkEnabled = usingBackgroundSession;
  205|       |
  206|      0|  __weak GULNetwork *weakSelf = self;
  207|      0|  NSString *requestID = [fetcher
  208|      0|      sessionIDFromAsyncGETRequest:request
  209|      0|                 completionHandler:^(NSHTTPURLResponse *response, NSData *data, NSString *sessionID,
  210|      0|                                     NSError *error) {
  211|      0|                   GULNetwork *strongSelf = weakSelf;
  212|      0|                   if (!strongSelf) {
  213|      0|                     return;
  214|      0|                   }
  215|      0|                   dispatch_queue_t queueToDispatch = queue ? queue : dispatch_get_main_queue();
  216|      0|                   dispatch_async(queueToDispatch, ^{
  217|      0|                     if (sessionID.length) {
  218|      0|                       [strongSelf->_requests removeObjectForKey:sessionID];
  219|      0|                     }
  220|      0|                     if (handler) {
  221|      0|                       handler(response, data, error);
  222|      0|                     }
  223|      0|                   });
  224|      0|                 }];
  225|       |
  226|      0|  if (!requestID) {
  227|      0|    [self handleErrorWithCode:GULErrorCodeNetworkSessionTaskCreation
  228|      0|                        queue:queue
  229|      0|                  withHandler:handler];
  230|      0|    return nil;
  231|      0|  }
  232|       |
  233|      0|  [self GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  234|      0|                    messageCode:kGULNetworkMessageCodeNetwork001
  235|      0|                        message:@"Downloading data. Host"
  236|      0|                        context:url];
  237|      0|  _requests[requestID] = fetcher;
  238|      0|  return requestID;
  239|      0|}
  240|       |
  241|      0|- (BOOL)hasUploadInProgress {
  242|      0|  return _requests.count > 0;
  243|      0|}
  244|       |
  245|       |#pragma mark - Network Reachability
  246|       |
  247|       |/// Tells reachability delegate to call reachabilityDidChangeToStatus: to notify the network
  248|       |/// reachability has changed.
  249|       |- (void)reachability:(GULReachabilityChecker *)reachability
  250|      0|       statusChanged:(GULReachabilityStatus)status {
  251|      0|  _networkConnected = (status == kGULReachabilityViaCellular || status == kGULReachabilityViaWifi);
  252|      0|  [_reachabilityDelegate reachabilityDidChange];
  253|      0|}
  254|       |
  255|       |#pragma mark - Network logger delegate
  256|       |
  257|      0|- (void)setLoggerDelegate:(id<GULNetworkLoggerDelegate>)loggerDelegate {
  258|       |  // Explicitly check whether the delegate responds to the methods because conformsToProtocol does
  259|       |  // not work correctly even though the delegate does respond to the methods.
  260|      0|  if (!loggerDelegate ||
  261|      0|      ![loggerDelegate respondsToSelector:@selector(GULNetwork_logWithLevel:
  262|      0|                                                                messageCode:message:contexts:)] ||
  263|      0|      ![loggerDelegate respondsToSelector:@selector(GULNetwork_logWithLevel:
  264|      0|                                                                messageCode:message:context:)] ||
  265|      0|      ![loggerDelegate respondsToSelector:@selector(GULNetwork_logWithLevel:
  266|      0|                                                                messageCode:message:)]) {
  267|      0|    GULLogError(kGULLoggerNetwork, NO,
  268|      0|                [NSString stringWithFormat:@"I-NET%06ld", (long)kGULNetworkMessageCodeNetwork002],
  269|      0|                @"Cannot set the network logger delegate: delegate does not conform to the network "
  270|      0|                 "logger protocol.");
  271|      0|    return;
  272|      0|  }
  273|      0|  _loggerDelegate = loggerDelegate;
  274|      0|}
  275|       |
  276|       |#pragma mark - Private methods
  277|       |
  278|       |/// Handles network error and calls completion handler with the error.
  279|       |- (void)handleErrorWithCode:(NSInteger)code
  280|       |                      queue:(dispatch_queue_t)queue
  281|      0|                withHandler:(GULNetworkCompletionHandler)handler {
  282|      0|  NSDictionary *userInfo = @{kGULNetworkErrorContext : @"Failed to create network request"};
  283|      0|  NSError *error = [[NSError alloc] initWithDomain:kGULNetworkErrorDomain
  284|      0|                                              code:code
  285|      0|                                          userInfo:userInfo];
  286|      0|  [self GULNetwork_logWithLevel:kGULNetworkLogLevelWarning
  287|      0|                    messageCode:kGULNetworkMessageCodeNetwork002
  288|      0|                        message:@"Failed to create network request. Code, error"
  289|      0|                       contexts:@[ @(code), error ]];
  290|      0|  if (handler) {
  291|      0|    dispatch_queue_t queueToDispatch = queue ? queue : dispatch_get_main_queue();
  292|      0|    dispatch_async(queueToDispatch, ^{
  293|      0|      handler(nil, nil, error);
  294|      0|    });
  295|      0|  }
  296|      0|}
  297|       |
  298|       |#pragma mark - Network logger
  299|       |
  300|       |- (void)GULNetwork_logWithLevel:(GULNetworkLogLevel)logLevel
  301|       |                    messageCode:(GULNetworkMessageCode)messageCode
  302|       |                        message:(NSString *)message
  303|      0|                       contexts:(NSArray *)contexts {
  304|       |  // Let the delegate log the message if there is a valid logger delegate. Otherwise, just log
  305|       |  // errors/warnings/info messages to the console log.
  306|      0|  if (_loggerDelegate) {
  307|      0|    [_loggerDelegate GULNetwork_logWithLevel:logLevel
  308|      0|                                 messageCode:messageCode
  309|      0|                                     message:message
  310|      0|                                    contexts:contexts];
  311|      0|    return;
  312|      0|  }
  313|      0|  if (_isDebugModeEnabled || logLevel == kGULNetworkLogLevelError ||
  314|      0|      logLevel == kGULNetworkLogLevelWarning || logLevel == kGULNetworkLogLevelInfo) {
  315|      0|    NSString *formattedMessage = GULStringWithLogMessage(message, logLevel, contexts);
  316|      0|    NSLog(@"%@", formattedMessage);
  317|      0|    GULLogBasic((GULLoggerLevel)logLevel, kGULLoggerNetwork, NO,
  318|      0|                [NSString stringWithFormat:@"I-NET%06ld", (long)messageCode], formattedMessage,
  319|      0|                NULL);
  320|      0|  }
  321|      0|}
  322|       |
  323|       |- (void)GULNetwork_logWithLevel:(GULNetworkLogLevel)logLevel
  324|       |                    messageCode:(GULNetworkMessageCode)messageCode
  325|       |                        message:(NSString *)message
  326|      0|                        context:(id)context {
  327|      0|  if (_loggerDelegate) {
  328|      0|    [_loggerDelegate GULNetwork_logWithLevel:logLevel
  329|      0|                                 messageCode:messageCode
  330|      0|                                     message:message
  331|      0|                                     context:context];
  332|      0|    return;
  333|      0|  }
  334|      0|  NSArray *contexts = context ? @[ context ] : @[];
  335|      0|  [self GULNetwork_logWithLevel:logLevel messageCode:messageCode message:message contexts:contexts];
  336|      0|}
  337|       |
  338|       |- (void)GULNetwork_logWithLevel:(GULNetworkLogLevel)logLevel
  339|       |                    messageCode:(GULNetworkMessageCode)messageCode
  340|      0|                        message:(NSString *)message {
  341|      0|  if (_loggerDelegate) {
  342|      0|    [_loggerDelegate GULNetwork_logWithLevel:logLevel messageCode:messageCode message:message];
  343|      0|    return;
  344|      0|  }
  345|      0|  [self GULNetwork_logWithLevel:logLevel messageCode:messageCode message:message contexts:@[]];
  346|      0|}
  347|       |
  348|       |/// Returns a string for the given log level (e.g. kGULNetworkLogLevelError -> @"ERROR").
  349|      0|static NSString *GULLogLevelDescriptionFromLogLevel(GULNetworkLogLevel logLevel) {
  350|      0|  static NSDictionary *levelNames = nil;
  351|      0|  static dispatch_once_t onceToken;
  352|      0|  dispatch_once(&onceToken, ^{
  353|      0|    levelNames = @{
  354|      0|      @(kGULNetworkLogLevelError) : @"ERROR",
  355|      0|      @(kGULNetworkLogLevelWarning) : @"WARNING",
  356|      0|      @(kGULNetworkLogLevelInfo) : @"INFO",
  357|      0|      @(kGULNetworkLogLevelDebug) : @"DEBUG"
  358|      0|    };
  359|      0|  });
  360|      0|  return levelNames[@(logLevel)];
  361|      0|}
  362|       |
  363|       |/// Returns a formatted string to be used for console logging.
  364|       |static NSString *GULStringWithLogMessage(NSString *message,
  365|       |                                         GULNetworkLogLevel logLevel,
  366|      0|                                         NSArray *contexts) {
  367|      0|  if (!message) {
  368|      0|    message = @"(Message was nil)";
  369|      0|  } else if (!message.length) {
  370|      0|    message = @"(Message was empty)";
  371|      0|  }
  372|      0|  NSMutableString *result = [[NSMutableString alloc]
  373|      0|      initWithFormat:@"<%@/%@> %@", kGULNetworkLogTag, GULLogLevelDescriptionFromLogLevel(logLevel),
  374|      0|                     message];
  375|       |
  376|      0|  if (!contexts.count) {
  377|      0|    return result;
  378|      0|  }
  379|       |
  380|      0|  NSMutableArray *formattedContexts = [[NSMutableArray alloc] init];
  381|      0|  for (id item in contexts) {
  382|      0|    [formattedContexts addObject:(item != [NSNull null] ? item : @"(nil)")];
  383|      0|  }
  384|       |
  385|      0|  [result appendString:@": "];
  386|      0|  [result appendString:[formattedContexts componentsJoinedByString:@", "]];
  387|      0|  return result;
  388|      0|}
  389|       |
  390|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/Network/GULNetworkURLSession.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import <Foundation/Foundation.h>
   16|       |
   17|       |#import "GoogleUtilities/Network/Public/GoogleUtilities/GULNetworkURLSession.h"
   18|       |
   19|       |#import "GoogleUtilities/Logger/Public/GoogleUtilities/GULLogger.h"
   20|       |#import "GoogleUtilities/Network/GULNetworkInternal.h"
   21|       |#import "GoogleUtilities/Network/Public/GoogleUtilities/GULMutableDictionary.h"
   22|       |#import "GoogleUtilities/Network/Public/GoogleUtilities/GULNetworkConstants.h"
   23|       |#import "GoogleUtilities/Network/Public/GoogleUtilities/GULNetworkMessageCode.h"
   24|       |
   25|       |@interface GULNetworkURLSession () <NSURLSessionDelegate,
   26|       |                                    NSURLSessionDataDelegate,
   27|       |                                    NSURLSessionDownloadDelegate,
   28|       |                                    NSURLSessionTaskDelegate>
   29|       |@end
   30|       |
   31|       |@implementation GULNetworkURLSession {
   32|       |  /// The handler to be called when the request completes or error has occurs.
   33|       |  GULNetworkURLSessionCompletionHandler _completionHandler;
   34|       |
   35|       |  /// Session ID generated randomly with a fixed prefix.
   36|       |  NSString *_sessionID;
   37|       |
   38|       |#pragma clang diagnostic push
   39|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
   40|       |  /// The session configuration. NSURLSessionConfiguration' is only available on iOS 7.0 or newer.
   41|       |  NSURLSessionConfiguration *_sessionConfig;
   42|       |
   43|       |  /// The current NSURLSession.
   44|       |  NSURLSession *__weak _Nullable _URLSession;
   45|       |#pragma clang diagnostic pop
   46|       |
   47|       |  /// The path to the directory where all temporary files are stored before uploading.
   48|       |  NSURL *_networkDirectoryURL;
   49|       |
   50|       |  /// The downloaded data from fetching.
   51|       |  NSData *_downloadedData;
   52|       |
   53|       |  /// The path to the temporary file which stores the uploading data.
   54|       |  NSURL *_uploadingFileURL;
   55|       |
   56|       |  /// The current request.
   57|       |  NSURLRequest *_request;
   58|       |}
   59|       |
   60|       |#pragma mark - Init
   61|       |
   62|      0|- (instancetype)initWithNetworkLoggerDelegate:(id<GULNetworkLoggerDelegate>)networkLoggerDelegate {
   63|      0|  self = [super init];
   64|      0|  if (self) {
   65|       |    // Create URL to the directory where all temporary files to upload have to be stored.
   66|       |#if TARGET_OS_TV
   67|       |    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
   68|       |#else
   69|      0|    NSArray *paths =
   70|      0|        NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES);
   71|      0|#endif
   72|      0|    NSString *storageDirectory = paths.firstObject;
   73|      0|    NSArray *tempPathComponents = @[
   74|      0|      storageDirectory, kGULNetworkApplicationSupportSubdirectory, kGULNetworkTempDirectoryName
   75|      0|    ];
   76|      0|    _networkDirectoryURL = [NSURL fileURLWithPathComponents:tempPathComponents];
   77|      0|    _sessionID = [NSString stringWithFormat:@"%@-%@", kGULNetworkBackgroundSessionConfigIDPrefix,
   78|      0|                                            [[NSUUID UUID] UUIDString]];
   79|      0|    _loggerDelegate = networkLoggerDelegate;
   80|      0|  }
   81|      0|  return self;
   82|      0|}
   83|       |
   84|       |#pragma mark - External Methods
   85|       |
   86|       |#pragma mark - To be called from AppDelegate
   87|       |
   88|       |+ (void)handleEventsForBackgroundURLSessionID:(NSString *)sessionID
   89|       |                            completionHandler:
   90|      0|                                (GULNetworkSystemCompletionHandler)systemCompletionHandler {
   91|       |  // The session may not be Analytics background. Ignore those that do not have the prefix.
   92|      0|  if (![sessionID hasPrefix:kGULNetworkBackgroundSessionConfigIDPrefix]) {
   93|      0|    return;
   94|      0|  }
   95|      0|  GULNetworkURLSession *fetcher = [self fetcherWithSessionIdentifier:sessionID];
   96|      0|  if (fetcher != nil) {
   97|      0|    [fetcher addSystemCompletionHandler:systemCompletionHandler forSession:sessionID];
   98|      0|  } else {
   99|      0|    GULLogError(kGULLoggerNetwork, NO,
  100|      0|                [NSString stringWithFormat:@"I-NET%06ld", (long)kGULNetworkMessageCodeNetwork003],
  101|      0|                @"Failed to retrieve background session with ID %@ after app is relaunched.",
  102|      0|                sessionID);
  103|      0|  }
  104|      0|}
  105|       |
  106|       |#pragma mark - External Methods
  107|       |
  108|       |/// Sends an async POST request using NSURLSession for iOS >= 7.0, and returns an ID of the
  109|       |/// connection.
  110|       |- (nullable NSString *)sessionIDFromAsyncPOSTRequest:(NSURLRequest *)request
  111|       |                                   completionHandler:(GULNetworkURLSessionCompletionHandler)handler
  112|      0|    API_AVAILABLE(ios(7.0)) {
  113|       |  // NSURLSessionUploadTask does not work with NSData in the background.
  114|       |  // To avoid this issue, write the data to a temporary file to upload it.
  115|       |  // Make a temporary file with the data subset.
  116|      0|  _uploadingFileURL = [self temporaryFilePathWithSessionID:_sessionID];
  117|      0|  NSError *writeError;
  118|      0|  NSURLSessionUploadTask *postRequestTask;
  119|      0|  NSURLSession *session;
  120|      0|  BOOL didWriteFile = NO;
  121|       |
  122|       |  // Clean up the entire temp folder to avoid temp files that remain in case the previous session
  123|       |  // crashed and did not clean up.
  124|      0|  [self maybeRemoveTempFilesAtURL:_networkDirectoryURL
  125|      0|                     expiringTime:kGULNetworkTempFolderExpireTime];
  126|       |
  127|       |  // If there is no background network enabled, no need to write to file. This will allow default
  128|       |  // network session which runs on the foreground.
  129|      0|  if (_backgroundNetworkEnabled && [self ensureTemporaryDirectoryExists]) {
  130|      0|    didWriteFile = [request.HTTPBody writeToFile:_uploadingFileURL.path
  131|      0|                                         options:NSDataWritingAtomic
  132|      0|                                           error:&writeError];
  133|       |
  134|      0|    if (writeError) {
  135|      0|      [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  136|      0|                                   messageCode:kGULNetworkMessageCodeURLSession000
  137|      0|                                       message:@"Failed to write request data to file"
  138|      0|                                       context:writeError];
  139|      0|    }
  140|      0|  }
  141|       |
  142|      0|  if (didWriteFile) {
  143|       |    // Exclude this file from backing up to iTunes. There are conflicting reports that excluding
  144|       |    // directory from backing up does not exclude files of that directory from backing up.
  145|      0|    [self excludeFromBackupForURL:_uploadingFileURL];
  146|       |
  147|      0|    _sessionConfig = [self backgroundSessionConfigWithSessionID:_sessionID];
  148|      0|    [self populateSessionConfig:_sessionConfig withRequest:request];
  149|      0|    session = [NSURLSession sessionWithConfiguration:_sessionConfig
  150|      0|                                            delegate:self
  151|      0|                                       delegateQueue:[NSOperationQueue mainQueue]];
  152|      0|    postRequestTask = [session uploadTaskWithRequest:request fromFile:_uploadingFileURL];
  153|      0|  } else {
  154|       |    // If we cannot write to file, just send it in the foreground.
  155|      0|    _sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];
  156|      0|    [self populateSessionConfig:_sessionConfig withRequest:request];
  157|      0|    session = [NSURLSession sessionWithConfiguration:_sessionConfig
  158|      0|                                            delegate:self
  159|      0|                                       delegateQueue:[NSOperationQueue mainQueue]];
  160|      0|    postRequestTask = [session uploadTaskWithRequest:request fromData:request.HTTPBody];
  161|      0|  }
  162|       |
  163|      0|  if (!session || !postRequestTask) {
  164|      0|    NSError *error = [[NSError alloc]
  165|      0|        initWithDomain:kGULNetworkErrorDomain
  166|      0|                  code:GULErrorCodeNetworkRequestCreation
  167|      0|              userInfo:@{kGULNetworkErrorContext : @"Cannot create network session"}];
  168|      0|    [self callCompletionHandler:handler withResponse:nil data:nil error:error];
  169|      0|    return nil;
  170|      0|  }
  171|       |
  172|      0|  _URLSession = session;
  173|       |
  174|       |  // Save the session into memory.
  175|      0|  [[self class] setSessionInFetcherMap:self forSessionID:_sessionID];
  176|       |
  177|      0|  _request = [request copy];
  178|       |
  179|       |  // Store completion handler because background session does not accept handler block but custom
  180|       |  // delegate.
  181|      0|  _completionHandler = [handler copy];
  182|      0|  [postRequestTask resume];
  183|       |
  184|      0|  return _sessionID;
  185|      0|}
  186|       |
  187|       |/// Sends an async GET request using NSURLSession for iOS >= 7.0, and returns an ID of the session.
  188|       |- (nullable NSString *)sessionIDFromAsyncGETRequest:(NSURLRequest *)request
  189|       |                                  completionHandler:(GULNetworkURLSessionCompletionHandler)handler
  190|      0|    API_AVAILABLE(ios(7.0)) {
  191|      0|  if (_backgroundNetworkEnabled) {
  192|      0|    _sessionConfig = [self backgroundSessionConfigWithSessionID:_sessionID];
  193|      0|  } else {
  194|      0|    _sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];
  195|      0|  }
  196|       |
  197|      0|  [self populateSessionConfig:_sessionConfig withRequest:request];
  198|       |
  199|       |  // Do not cache the GET request.
  200|      0|  _sessionConfig.URLCache = nil;
  201|       |
  202|      0|  NSURLSession *session = [NSURLSession sessionWithConfiguration:_sessionConfig
  203|      0|                                                        delegate:self
  204|      0|                                                   delegateQueue:[NSOperationQueue mainQueue]];
  205|      0|  NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:request];
  206|       |
  207|      0|  if (!session || !downloadTask) {
  208|      0|    NSError *error = [[NSError alloc]
  209|      0|        initWithDomain:kGULNetworkErrorDomain
  210|      0|                  code:GULErrorCodeNetworkRequestCreation
  211|      0|              userInfo:@{kGULNetworkErrorContext : @"Cannot create network session"}];
  212|      0|    [self callCompletionHandler:handler withResponse:nil data:nil error:error];
  213|      0|    return nil;
  214|      0|  }
  215|       |
  216|      0|  _URLSession = session;
  217|       |
  218|       |  // Save the session into memory.
  219|      0|  [[self class] setSessionInFetcherMap:self forSessionID:_sessionID];
  220|       |
  221|      0|  _request = [request copy];
  222|       |
  223|      0|  _completionHandler = [handler copy];
  224|      0|  [downloadTask resume];
  225|       |
  226|      0|  return _sessionID;
  227|      0|}
  228|       |
  229|       |#pragma mark - NSURLSessionDataDelegate
  230|       |
  231|       |/// Called by the NSURLSession when the data task has received some of the expected data.
  232|       |/// Once the session is completed, URLSession:task:didCompleteWithError will be called and the
  233|       |/// completion handler will be called with the downloaded data.
  234|       |- (void)URLSession:(NSURLSession *)session
  235|       |          dataTask:(NSURLSessionDataTask *)dataTask
  236|      0|    didReceiveData:(NSData *)data {
  237|      0|  @synchronized(self) {
  238|      0|    NSMutableData *mutableData = [[NSMutableData alloc] init];
  239|      0|    if (_downloadedData) {
  240|      0|      mutableData = _downloadedData.mutableCopy;
  241|      0|    }
  242|      0|    [mutableData appendData:data];
  243|      0|    _downloadedData = mutableData;
  244|      0|  }
  245|      0|}
  246|       |
  247|       |#pragma mark - NSURLSessionTaskDelegate
  248|       |
  249|       |/// Called by the NSURLSession once the download task is completed. The file is saved in the
  250|       |/// provided URL so we need to read the data and store into _downloadedData. Once the session is
  251|       |/// completed, URLSession:task:didCompleteWithError will be called and the completion handler will
  252|       |/// be called with the downloaded data.
  253|       |- (void)URLSession:(NSURLSession *)session
  254|       |                 downloadTask:(NSURLSessionDownloadTask *)task
  255|      0|    didFinishDownloadingToURL:(NSURL *)url API_AVAILABLE(ios(7.0)) {
  256|      0|  if (!url.path) {
  257|      0|    [_loggerDelegate
  258|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelError
  259|      0|                    messageCode:kGULNetworkMessageCodeURLSession001
  260|      0|                        message:@"Unable to read downloaded data from empty temp path"];
  261|      0|    _downloadedData = nil;
  262|      0|    return;
  263|      0|  }
  264|       |
  265|      0|  NSError *error;
  266|      0|  _downloadedData = [NSData dataWithContentsOfFile:url.path options:0 error:&error];
  267|       |
  268|      0|  if (error) {
  269|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  270|      0|                                 messageCode:kGULNetworkMessageCodeURLSession002
  271|      0|                                     message:@"Cannot read the content of downloaded data"
  272|      0|                                     context:error];
  273|      0|    _downloadedData = nil;
  274|      0|  }
  275|      0|}
  276|       |
  277|       |#if TARGET_OS_IOS || TARGET_OS_TV
  278|       |- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session
  279|      0|    API_AVAILABLE(ios(7.0)) {
  280|      0|  [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  281|      0|                               messageCode:kGULNetworkMessageCodeURLSession003
  282|      0|                                   message:@"Background session finished"
  283|      0|                                   context:session.configuration.identifier];
  284|      0|  [self callSystemCompletionHandler:session.configuration.identifier];
  285|      0|}
  286|       |#endif
  287|       |
  288|       |- (void)URLSession:(NSURLSession *)session
  289|       |                    task:(NSURLSessionTask *)task
  290|      0|    didCompleteWithError:(NSError *)error API_AVAILABLE(ios(7.0)) {
  291|       |  // Avoid any chance of recursive behavior leading to it being used repeatedly.
  292|      0|  GULNetworkURLSessionCompletionHandler handler = _completionHandler;
  293|      0|  _completionHandler = nil;
  294|       |
  295|      0|  if (task.response) {
  296|       |    // The following assertion should always be true for HTTP requests, see https://goo.gl/gVLxT7.
  297|      0|    NSAssert([task.response isKindOfClass:[NSHTTPURLResponse class]], @"URL response must be HTTP");
  298|       |
  299|       |    // The server responded so ignore the error created by the system.
  300|      0|    error = nil;
  301|      0|  } else if (!error) {
  302|      0|    error = [[NSError alloc]
  303|      0|        initWithDomain:kGULNetworkErrorDomain
  304|      0|                  code:GULErrorCodeNetworkInvalidResponse
  305|      0|              userInfo:@{kGULNetworkErrorContext : @"Network Error: Empty network response"}];
  306|      0|  }
  307|       |
  308|      0|  [self callCompletionHandler:handler
  309|      0|                 withResponse:(NSHTTPURLResponse *)task.response
  310|      0|                         data:_downloadedData
  311|      0|                        error:error];
  312|       |
  313|       |  // Remove the temp file to avoid trashing devices with lots of temp files.
  314|      0|  [self removeTempItemAtURL:_uploadingFileURL];
  315|       |
  316|       |  // Try to clean up stale files again.
  317|      0|  [self maybeRemoveTempFilesAtURL:_networkDirectoryURL
  318|      0|                     expiringTime:kGULNetworkTempFolderExpireTime];
  319|       |
  320|       |  // This is called without checking the sessionID here since non-background sessions
  321|       |  // won't have an ID.
  322|      0|  [session finishTasksAndInvalidate];
  323|       |
  324|       |  // Explicitly remove the session so it won't be reused. The weak map table should
  325|       |  // remove the session on deallocation, but dealloc may not happen immediately after
  326|       |  // calling `finishTasksAndInvalidate`.
  327|      0|  NSString *sessionID = session.configuration.identifier;
  328|      0|  [[self class] setSessionInFetcherMap:nil forSessionID:sessionID];
  329|      0|}
  330|       |
  331|       |- (void)URLSession:(NSURLSession *)session
  332|       |                   task:(NSURLSessionTask *)task
  333|       |    didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
  334|       |      completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition,
  335|       |                                  NSURLCredential *credential))completionHandler
  336|      0|    API_AVAILABLE(ios(7.0)) {
  337|       |  // The handling is modeled after GTMSessionFetcher.
  338|      0|  if ([challenge.protectionSpace.authenticationMethod
  339|      0|          isEqualToString:NSURLAuthenticationMethodServerTrust]) {
  340|      0|    SecTrustRef serverTrust = challenge.protectionSpace.serverTrust;
  341|      0|    if (serverTrust == NULL) {
  342|      0|      [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  343|      0|                                   messageCode:kGULNetworkMessageCodeURLSession004
  344|      0|                                       message:@"Received empty server trust for host. Host"
  345|      0|                                       context:_request.URL];
  346|      0|      completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil);
  347|      0|      return;
  348|      0|    }
  349|      0|    NSURLCredential *credential = [NSURLCredential credentialForTrust:serverTrust];
  350|      0|    if (!credential) {
  351|      0|      [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelWarning
  352|      0|                                   messageCode:kGULNetworkMessageCodeURLSession005
  353|      0|                                       message:@"Unable to verify server identity. Host"
  354|      0|                                       context:_request.URL];
  355|      0|      completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);
  356|      0|      return;
  357|      0|    }
  358|       |
  359|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  360|      0|                                 messageCode:kGULNetworkMessageCodeURLSession006
  361|      0|                                     message:@"Received SSL challenge for host. Host"
  362|      0|                                     context:_request.URL];
  363|       |
  364|      0|    void (^callback)(BOOL) = ^(BOOL allow) {
  365|      0|      if (allow) {
  366|      0|        completionHandler(NSURLSessionAuthChallengeUseCredential, credential);
  367|      0|      } else {
  368|      0|        [self->_loggerDelegate
  369|      0|            GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  370|      0|                        messageCode:kGULNetworkMessageCodeURLSession007
  371|      0|                            message:@"Cancelling authentication challenge for host. Host"
  372|      0|                            context:self->_request.URL];
  373|      0|        completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);
  374|      0|      }
  375|      0|    };
  376|       |
  377|       |    // Retain the trust object to avoid a SecTrustEvaluate() crash on iOS 7.
  378|      0|    CFRetain(serverTrust);
  379|       |
  380|       |    // Evaluate the certificate chain.
  381|       |    //
  382|       |    // The delegate queue may be the main thread. Trust evaluation could cause some
  383|       |    // blocking network activity, so we must evaluate async, as documented at
  384|       |    // https://developer.apple.com/library/ios/technotes/tn2232/
  385|      0|    dispatch_queue_t evaluateBackgroundQueue =
  386|      0|        dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
  387|       |
  388|      0|    dispatch_async(evaluateBackgroundQueue, ^{
  389|      0|      SecTrustResultType trustEval = kSecTrustResultInvalid;
  390|      0|      BOOL shouldAllow;
  391|      0|      OSStatus trustError;
  392|       |
  393|      0|      @synchronized([GULNetworkURLSession class]) {
  394|      0|#pragma clang diagnostic push
  395|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  396|      0|        trustError = SecTrustEvaluate(serverTrust, &trustEval);
  397|      0|#pragma clang dianostic pop
  398|      0|      }
  399|       |
  400|      0|      if (trustError != errSecSuccess) {
  401|      0|        [self->_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  402|      0|                                           messageCode:kGULNetworkMessageCodeURLSession008
  403|      0|                                               message:@"Cannot evaluate server trust. Error, host"
  404|      0|                                              contexts:@[ @(trustError), self->_request.URL ]];
  405|      0|        shouldAllow = NO;
  406|      0|      } else {
  407|       |        // Having a trust level "unspecified" by the user is the usual result, described at
  408|       |        // https://developer.apple.com/library/mac/qa/qa1360
  409|      0|        shouldAllow =
  410|      0|            (trustEval == kSecTrustResultUnspecified || trustEval == kSecTrustResultProceed);
  411|      0|      }
  412|       |
  413|       |      // Call the call back with the permission.
  414|      0|      callback(shouldAllow);
  415|       |
  416|      0|      CFRelease(serverTrust);
  417|      0|    });
  418|      0|    return;
  419|      0|  }
  420|       |
  421|       |  // Default handling for other Auth Challenges.
  422|      0|  completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil);
  423|      0|}
  424|       |
  425|       |#pragma mark - Internal Methods
  426|       |
  427|       |/// Stores system completion handler with session ID as key.
  428|       |- (void)addSystemCompletionHandler:(GULNetworkSystemCompletionHandler)handler
  429|      0|                        forSession:(NSString *)identifier {
  430|      0|  if (!handler) {
  431|      0|    [_loggerDelegate
  432|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelError
  433|      0|                    messageCode:kGULNetworkMessageCodeURLSession009
  434|      0|                        message:@"Cannot store nil system completion handler in network"];
  435|      0|    return;
  436|      0|  }
  437|       |
  438|      0|  if (!identifier.length) {
  439|      0|    [_loggerDelegate
  440|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelError
  441|      0|                    messageCode:kGULNetworkMessageCodeURLSession010
  442|      0|                        message:@"Cannot store system completion handler with empty network "
  443|      0|                                 "session identifier"];
  444|      0|    return;
  445|      0|  }
  446|       |
  447|      0|  GULMutableDictionary *systemCompletionHandlers =
  448|      0|      [[self class] sessionIDToSystemCompletionHandlerDictionary];
  449|      0|  if (systemCompletionHandlers[identifier]) {
  450|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelWarning
  451|      0|                                 messageCode:kGULNetworkMessageCodeURLSession011
  452|      0|                                     message:@"Got multiple system handlers for a single session ID"
  453|      0|                                     context:identifier];
  454|      0|  }
  455|       |
  456|      0|  systemCompletionHandlers[identifier] = handler;
  457|      0|}
  458|       |
  459|       |/// Calls the system provided completion handler with the session ID stored in the dictionary.
  460|       |/// The handler will be removed from the dictionary after being called.
  461|      0|- (void)callSystemCompletionHandler:(NSString *)identifier {
  462|      0|  GULMutableDictionary *systemCompletionHandlers =
  463|      0|      [[self class] sessionIDToSystemCompletionHandlerDictionary];
  464|      0|  GULNetworkSystemCompletionHandler handler = [systemCompletionHandlers objectForKey:identifier];
  465|       |
  466|      0|  if (handler) {
  467|      0|    [systemCompletionHandlers removeObjectForKey:identifier];
  468|       |
  469|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  470|      0|      handler();
  471|      0|    });
  472|      0|  }
  473|      0|}
  474|       |
  475|       |/// Sets or updates the session ID of this session.
  476|      0|- (void)setSessionID:(NSString *)sessionID {
  477|      0|  _sessionID = [sessionID copy];
  478|      0|}
  479|       |
  480|       |/// Creates a background session configuration with the session ID using the supported method.
  481|       |- (NSURLSessionConfiguration *)backgroundSessionConfigWithSessionID:(NSString *)sessionID
  482|      0|    API_AVAILABLE(ios(7.0)) {
  483|      0|#if (TARGET_OS_OSX && defined(MAC_OS_X_VERSION_10_10) &&         \
  484|      0|     MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_10) || \
  485|      0|    TARGET_OS_TV ||                                              \
  486|      0|    (TARGET_OS_IOS && defined(__IPHONE_8_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_8_0)
  487|       |
  488|       |  // iOS 8/10.10 builds require the new backgroundSessionConfiguration method name.
  489|      0|  return [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:sessionID];
  490|       |
  491|       |#elif (TARGET_OS_OSX && defined(MAC_OS_X_VERSION_10_10) &&        \
  492|       |       MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_10) || \
  493|       |    (TARGET_OS_IOS && defined(__IPHONE_8_0) && __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_8_0)
  494|       |
  495|       |  // Do a runtime check to avoid a deprecation warning about using
  496|       |  // +backgroundSessionConfiguration: on iOS 8.
  497|       |  if ([NSURLSessionConfiguration
  498|       |          respondsToSelector:@selector(backgroundSessionConfigurationWithIdentifier:)]) {
  499|       |    // Running on iOS 8+/OS X 10.10+.
  500|       |#pragma clang diagnostic push
  501|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
  502|       |    return [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:sessionID];
  503|       |#pragma clang diagnostic pop
  504|       |  } else {
  505|       |    // Running on iOS 7/OS X 10.9.
  506|       |    return [NSURLSessionConfiguration backgroundSessionConfiguration:sessionID];
  507|       |  }
  508|       |
  509|       |#else
  510|       |  // Building with an SDK earlier than iOS 8/OS X 10.10.
  511|       |  return [NSURLSessionConfiguration backgroundSessionConfiguration:sessionID];
  512|       |#endif
  513|      0|}
  514|       |
  515|      0|- (void)maybeRemoveTempFilesAtURL:(NSURL *)folderURL expiringTime:(NSTimeInterval)staleTime {
  516|      0|  if (!folderURL.absoluteString.length) {
  517|      0|    return;
  518|      0|  }
  519|       |
  520|      0|  NSFileManager *fileManager = [NSFileManager defaultManager];
  521|      0|  NSError *error = nil;
  522|       |
  523|      0|  NSArray *properties = @[ NSURLCreationDateKey ];
  524|      0|  NSArray *directoryContent =
  525|      0|      [fileManager contentsOfDirectoryAtURL:folderURL
  526|      0|                 includingPropertiesForKeys:properties
  527|      0|                                    options:NSDirectoryEnumerationSkipsSubdirectoryDescendants
  528|      0|                                      error:&error];
  529|      0|  if (error && error.code != NSFileReadNoSuchFileError) {
  530|      0|    [_loggerDelegate
  531|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  532|      0|                    messageCode:kGULNetworkMessageCodeURLSession012
  533|      0|                        message:@"Cannot get files from the temporary network folder. Error"
  534|      0|                        context:error];
  535|      0|    return;
  536|      0|  }
  537|       |
  538|      0|  if (!directoryContent.count) {
  539|      0|    return;
  540|      0|  }
  541|       |
  542|      0|  NSTimeInterval now = [NSDate date].timeIntervalSince1970;
  543|      0|  for (NSURL *tempFile in directoryContent) {
  544|      0|    NSDate *creationDate;
  545|      0|    BOOL getCreationDate = [tempFile getResourceValue:&creationDate
  546|      0|                                               forKey:NSURLCreationDateKey
  547|      0|                                                error:NULL];
  548|      0|    if (!getCreationDate) {
  549|      0|      continue;
  550|      0|    }
  551|      0|    NSTimeInterval creationTimeInterval = creationDate.timeIntervalSince1970;
  552|      0|    if (fabs(now - creationTimeInterval) > staleTime) {
  553|      0|      [self removeTempItemAtURL:tempFile];
  554|      0|    }
  555|      0|  }
  556|      0|}
  557|       |
  558|       |/// Removes the temporary file written to disk for sending the request. It has to be cleaned up
  559|       |/// after the session is done.
  560|      0|- (void)removeTempItemAtURL:(NSURL *)fileURL {
  561|      0|  if (!fileURL.absoluteString.length) {
  562|      0|    return;
  563|      0|  }
  564|       |
  565|      0|  NSFileManager *fileManager = [NSFileManager defaultManager];
  566|      0|  NSError *error = nil;
  567|       |
  568|      0|  if (![fileManager removeItemAtURL:fileURL error:&error] && error.code != NSFileNoSuchFileError) {
  569|      0|    [_loggerDelegate
  570|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelError
  571|      0|                    messageCode:kGULNetworkMessageCodeURLSession013
  572|      0|                        message:@"Failed to remove temporary uploading data file. Error"
  573|      0|                        context:error.localizedDescription];
  574|      0|  }
  575|      0|}
  576|       |
  577|       |/// Gets the fetcher with the session ID.
  578|      0|+ (instancetype)fetcherWithSessionIdentifier:(NSString *)sessionIdentifier {
  579|      0|  GULNetworkURLSession *session = [self sessionFromFetcherMapForSessionID:sessionIdentifier];
  580|      0|  if (!session && [sessionIdentifier hasPrefix:kGULNetworkBackgroundSessionConfigIDPrefix]) {
  581|      0|    session = [[GULNetworkURLSession alloc] initWithNetworkLoggerDelegate:nil];
  582|      0|    [session setSessionID:sessionIdentifier];
  583|      0|    [self setSessionInFetcherMap:session forSessionID:sessionIdentifier];
  584|      0|  }
  585|      0|  return session;
  586|      0|}
  587|       |
  588|       |/// Returns a map of the fetcher by session ID. Creates a map if it is not created.
  589|       |/// When reading and writing from/to the session map, don't use this method directly.
  590|       |/// To avoid thread safety issues, use one of the helper methods at the bottom of the
  591|       |/// file: setSessionInFetcherMap:forSessionID:, sessionFromFetcherMapForSessionID:
  592|      0|+ (NSMapTable<NSString *, GULNetworkURLSession *> *)sessionIDToFetcherMap {
  593|      0|  static NSMapTable *sessionIDToFetcherMap;
  594|       |
  595|      0|  static dispatch_once_t sessionMapOnceToken;
  596|      0|  dispatch_once(&sessionMapOnceToken, ^{
  597|      0|    sessionIDToFetcherMap = [NSMapTable strongToWeakObjectsMapTable];
  598|      0|  });
  599|      0|  return sessionIDToFetcherMap;
  600|      0|}
  601|       |
  602|      0|+ (NSLock *)sessionIDToFetcherMapReadWriteLock {
  603|      0|  static NSLock *lock;
  604|       |
  605|      0|  static dispatch_once_t onceToken;
  606|      0|  dispatch_once(&onceToken, ^{
  607|      0|    lock = [[NSLock alloc] init];
  608|      0|  });
  609|      0|  return lock;
  610|      0|}
  611|       |
  612|       |/// Returns a map of system provided completion handler by session ID. Creates a map if it is not
  613|       |/// created.
  614|      0|+ (GULMutableDictionary *)sessionIDToSystemCompletionHandlerDictionary {
  615|      0|  static GULMutableDictionary *systemCompletionHandlers;
  616|       |
  617|      0|  static dispatch_once_t systemCompletionHandlerOnceToken;
  618|      0|  dispatch_once(&systemCompletionHandlerOnceToken, ^{
  619|      0|    systemCompletionHandlers = [[GULMutableDictionary alloc] init];
  620|      0|  });
  621|      0|  return systemCompletionHandlers;
  622|      0|}
  623|       |
  624|      0|- (NSURL *)temporaryFilePathWithSessionID:(NSString *)sessionID {
  625|      0|  NSString *tempName = [NSString stringWithFormat:@"GULUpload_temp_%@", sessionID];
  626|      0|  return [_networkDirectoryURL URLByAppendingPathComponent:tempName];
  627|      0|}
  628|       |
  629|       |/// Makes sure that the directory to store temp files exists. If not, tries to create it and returns
  630|       |/// YES. If there is anything wrong, returns NO.
  631|      0|- (BOOL)ensureTemporaryDirectoryExists {
  632|      0|  NSFileManager *fileManager = [NSFileManager defaultManager];
  633|      0|  NSError *error = nil;
  634|       |
  635|       |  // Create a temporary directory if it does not exist or was deleted.
  636|      0|  if ([_networkDirectoryURL checkResourceIsReachableAndReturnError:&error]) {
  637|      0|    return YES;
  638|      0|  }
  639|       |
  640|      0|  if (error && error.code != NSFileReadNoSuchFileError) {
  641|      0|    [_loggerDelegate
  642|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelWarning
  643|      0|                    messageCode:kGULNetworkMessageCodeURLSession014
  644|      0|                        message:@"Error while trying to access Network temp folder. Error"
  645|      0|                        context:error];
  646|      0|  }
  647|       |
  648|      0|  NSError *writeError = nil;
  649|       |
  650|      0|  [fileManager createDirectoryAtURL:_networkDirectoryURL
  651|      0|        withIntermediateDirectories:YES
  652|      0|                         attributes:nil
  653|      0|                              error:&writeError];
  654|      0|  if (writeError) {
  655|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  656|      0|                                 messageCode:kGULNetworkMessageCodeURLSession015
  657|      0|                                     message:@"Cannot create temporary directory. Error"
  658|      0|                                     context:writeError];
  659|      0|    return NO;
  660|      0|  }
  661|       |
  662|       |  // Set the iCloud exclusion attribute on the Documents URL.
  663|      0|  [self excludeFromBackupForURL:_networkDirectoryURL];
  664|       |
  665|      0|  return YES;
  666|      0|}
  667|       |
  668|      0|- (void)excludeFromBackupForURL:(NSURL *)url {
  669|      0|  if (!url.path) {
  670|      0|    return;
  671|      0|  }
  672|       |
  673|       |  // Set the iCloud exclusion attribute on the Documents URL.
  674|      0|  NSError *preventBackupError = nil;
  675|      0|  [url setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:&preventBackupError];
  676|      0|  if (preventBackupError) {
  677|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  678|      0|                                 messageCode:kGULNetworkMessageCodeURLSession016
  679|      0|                                     message:@"Cannot exclude temporary folder from iTunes backup"];
  680|      0|  }
  681|      0|}
  682|       |
  683|       |- (void)URLSession:(NSURLSession *)session
  684|       |                          task:(NSURLSessionTask *)task
  685|       |    willPerformHTTPRedirection:(NSHTTPURLResponse *)response
  686|       |                    newRequest:(NSURLRequest *)request
  687|      0|             completionHandler:(void (^)(NSURLRequest *))completionHandler API_AVAILABLE(ios(7.0)) {
  688|      0|  NSArray *nonAllowedRedirectionCodes = @[
  689|      0|    @(kGULNetworkHTTPStatusCodeFound), @(kGULNetworkHTTPStatusCodeMovedPermanently),
  690|      0|    @(kGULNetworkHTTPStatusCodeMovedTemporarily), @(kGULNetworkHTTPStatusCodeMultipleChoices)
  691|      0|  ];
  692|       |
  693|       |  // Allow those not in the non allowed list to be followed.
  694|      0|  if (![nonAllowedRedirectionCodes containsObject:@(response.statusCode)]) {
  695|      0|    completionHandler(request);
  696|      0|    return;
  697|      0|  }
  698|       |
  699|       |  // Do not allow redirection if the response code is in the non-allowed list.
  700|      0|  NSURLRequest *newRequest = request;
  701|       |
  702|      0|  if (response) {
  703|      0|    newRequest = nil;
  704|      0|  }
  705|       |
  706|      0|  completionHandler(newRequest);
  707|      0|}
  708|       |
  709|       |#pragma mark - Helper Methods
  710|       |
  711|      0|+ (void)setSessionInFetcherMap:(GULNetworkURLSession *)session forSessionID:(NSString *)sessionID {
  712|      0|  [[self sessionIDToFetcherMapReadWriteLock] lock];
  713|      0|  GULNetworkURLSession *existingSession =
  714|      0|      [[[self class] sessionIDToFetcherMap] objectForKey:sessionID];
  715|      0|  if (existingSession) {
  716|      0|    if (session) {
  717|      0|      NSString *message = [NSString stringWithFormat:@"Discarding session: %@", existingSession];
  718|      0|      [existingSession->_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelInfo
  719|      0|                                                    messageCode:kGULNetworkMessageCodeURLSession019
  720|      0|                                                        message:message];
  721|      0|    }
  722|      0|    [existingSession->_URLSession finishTasksAndInvalidate];
  723|      0|  }
  724|      0|  if (session) {
  725|      0|    [[[self class] sessionIDToFetcherMap] setObject:session forKey:sessionID];
  726|      0|  } else {
  727|      0|    [[[self class] sessionIDToFetcherMap] removeObjectForKey:sessionID];
  728|      0|  }
  729|      0|  [[self sessionIDToFetcherMapReadWriteLock] unlock];
  730|      0|}
  731|       |
  732|      0|+ (nullable GULNetworkURLSession *)sessionFromFetcherMapForSessionID:(NSString *)sessionID {
  733|      0|  [[self sessionIDToFetcherMapReadWriteLock] lock];
  734|      0|  GULNetworkURLSession *session = [[[self class] sessionIDToFetcherMap] objectForKey:sessionID];
  735|      0|  [[self sessionIDToFetcherMapReadWriteLock] unlock];
  736|      0|  return session;
  737|      0|}
  738|       |
  739|       |- (void)callCompletionHandler:(GULNetworkURLSessionCompletionHandler)handler
  740|       |                 withResponse:(NSHTTPURLResponse *)response
  741|       |                         data:(NSData *)data
  742|      0|                        error:(NSError *)error {
  743|      0|  if (error) {
  744|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  745|      0|                                 messageCode:kGULNetworkMessageCodeURLSession017
  746|      0|                                     message:@"Encounter network error. Code, error"
  747|      0|                                    contexts:@[ @(error.code), error ]];
  748|      0|  }
  749|       |
  750|      0|  if (handler) {
  751|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  752|      0|      handler(response, data, self->_sessionID, error);
  753|      0|    });
  754|      0|  }
  755|      0|}
  756|       |
  757|       |// Always use the request parameters even if the default session configuration is more restrictive.
  758|       |- (void)populateSessionConfig:(NSURLSessionConfiguration *)sessionConfig
  759|      0|                  withRequest:(NSURLRequest *)request API_AVAILABLE(ios(7.0)) {
  760|      0|  sessionConfig.HTTPAdditionalHeaders = request.allHTTPHeaderFields;
  761|      0|  sessionConfig.timeoutIntervalForRequest = request.timeoutInterval;
  762|      0|  sessionConfig.timeoutIntervalForResource = request.timeoutInterval;
  763|      0|  sessionConfig.requestCachePolicy = request.cachePolicy;
  764|      0|}
  765|       |
  766|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/Reachability/GULReachabilityChecker.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import <Foundation/Foundation.h>
   16|       |
   17|       |#import "GoogleUtilities/Reachability/Public/GoogleUtilities/GULReachabilityChecker.h"
   18|       |
   19|       |#import "GoogleUtilities/Reachability/GULReachabilityChecker+Internal.h"
   20|       |#import "GoogleUtilities/Reachability/GULReachabilityMessageCode.h"
   21|       |
   22|       |#import "GoogleUtilities/Logger/Public/GoogleUtilities/GULLogger.h"
   23|       |
   24|       |static GULLoggerService kGULLoggerReachability = @"[GULReachability]";
   25|       |#if !TARGET_OS_WATCH
   26|       |static void ReachabilityCallback(SCNetworkReachabilityRef reachability,
   27|       |                                 SCNetworkReachabilityFlags flags,
   28|       |                                 void *info);
   29|       |
   30|       |static const struct GULReachabilityApi kGULDefaultReachabilityApi = {
   31|       |    SCNetworkReachabilityCreateWithName,
   32|       |    SCNetworkReachabilitySetCallback,
   33|       |    SCNetworkReachabilityScheduleWithRunLoop,
   34|       |    SCNetworkReachabilityUnscheduleFromRunLoop,
   35|       |    CFRelease,
   36|       |};
   37|       |
   38|       |static NSString *const kGULReachabilityUnknownStatus = @"Unknown";
   39|       |static NSString *const kGULReachabilityConnectedStatus = @"Connected";
   40|       |static NSString *const kGULReachabilityDisconnectedStatus = @"Disconnected";
   41|       |#endif
   42|       |@interface GULReachabilityChecker ()
   43|       |
   44|       |@property(nonatomic, assign) const struct GULReachabilityApi *reachabilityApi;
   45|       |@property(nonatomic, assign) GULReachabilityStatus reachabilityStatus;
   46|       |@property(nonatomic, copy) NSString *host;
   47|       |#if !TARGET_OS_WATCH
   48|       |@property(nonatomic, assign) SCNetworkReachabilityRef reachability;
   49|       |#endif
   50|       |
   51|       |@end
   52|       |
   53|       |@implementation GULReachabilityChecker
   54|       |
   55|       |@synthesize reachabilityApi = reachabilityApi_;
   56|       |#if !TARGET_OS_WATCH
   57|       |@synthesize reachability = reachability_;
   58|       |#endif
   59|       |
   60|      0|- (const struct GULReachabilityApi *)reachabilityApi {
   61|      0|  return reachabilityApi_;
   62|      0|}
   63|       |
   64|      0|- (void)setReachabilityApi:(const struct GULReachabilityApi *)reachabilityApi {
   65|      0|#if !TARGET_OS_WATCH
   66|      0|  if (reachability_) {
   67|      0|    GULLogError(kGULLoggerReachability, NO,
   68|      0|                [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode000],
   69|      0|                @"Cannot change reachability API while reachability is running. "
   70|      0|                @"Call stop first.");
   71|      0|    return;
   72|      0|  }
   73|      0|  reachabilityApi_ = reachabilityApi;
   74|      0|#endif
   75|      0|}
   76|       |
   77|       |@synthesize reachabilityStatus = reachabilityStatus_;
   78|       |@synthesize host = host_;
   79|       |@synthesize reachabilityDelegate = reachabilityDelegate_;
   80|       |
   81|      0|- (BOOL)isActive {
   82|      0|#if !TARGET_OS_WATCH
   83|      0|  return reachability_ != nil;
   84|       |#else
   85|       |  return NO;
   86|       |#endif
   87|      0|}
   88|       |
   89|      0|- (void)setReachabilityDelegate:(id<GULReachabilityDelegate>)reachabilityDelegate {
   90|      0|  if (reachabilityDelegate &&
   91|      0|      (![(NSObject *)reachabilityDelegate conformsToProtocol:@protocol(GULReachabilityDelegate)])) {
   92|      0|    GULLogError(kGULLoggerReachability, NO,
   93|      0|                [NSString stringWithFormat:@"I-NET%06ld", (long)kGULReachabilityMessageCode005],
   94|      0|                @"Reachability delegate doesn't conform to Reachability protocol.");
   95|      0|    return;
   96|      0|  }
   97|      0|  reachabilityDelegate_ = reachabilityDelegate;
   98|      0|}
   99|       |
  100|       |- (instancetype)initWithReachabilityDelegate:(id<GULReachabilityDelegate>)reachabilityDelegate
  101|      0|                                    withHost:(NSString *)host {
  102|      0|  self = [super init];
  103|       |
  104|      0|  if (!host || !host.length) {
  105|      0|    GULLogError(kGULLoggerReachability, NO,
  106|      0|                [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode001],
  107|      0|                @"Invalid host specified");
  108|      0|    return nil;
  109|      0|  }
  110|      0|  if (self) {
  111|      0|#if !TARGET_OS_WATCH
  112|      0|    [self setReachabilityDelegate:reachabilityDelegate];
  113|      0|    reachabilityApi_ = &kGULDefaultReachabilityApi;
  114|      0|    reachabilityStatus_ = kGULReachabilityUnknown;
  115|      0|    host_ = [host copy];
  116|      0|    reachability_ = nil;
  117|      0|#endif
  118|      0|  }
  119|      0|  return self;
  120|      0|}
  121|       |
  122|      0|- (void)dealloc {
  123|      0|  reachabilityDelegate_ = nil;
  124|      0|  [self stop];
  125|      0|}
  126|       |
  127|      0|- (BOOL)start {
  128|       |#if TARGET_OS_WATCH
  129|       |  return NO;
  130|       |#else
  131|       |
  132|      0|  if (!reachability_) {
  133|      0|    reachability_ = reachabilityApi_->createWithNameFn(kCFAllocatorDefault, [host_ UTF8String]);
  134|      0|    if (!reachability_) {
  135|      0|      return NO;
  136|      0|    }
  137|      0|    SCNetworkReachabilityContext context = {
  138|      0|        0,                       /* version */
  139|      0|        (__bridge void *)(self), /* info (passed as last parameter to reachability callback) */
  140|      0|        NULL,                    /* retain */
  141|      0|        NULL,                    /* release */
  142|       |        NULL                     /* copyDescription */
  143|      0|    };
  144|      0|    if (!reachabilityApi_->setCallbackFn(reachability_, ReachabilityCallback, &context) ||
  145|      0|        !reachabilityApi_->scheduleWithRunLoopFn(reachability_, CFRunLoopGetMain(),
  146|      0|                                                 kCFRunLoopCommonModes)) {
  147|      0|      reachabilityApi_->releaseFn(reachability_);
  148|      0|      reachability_ = nil;
  149|       |
  150|      0|      GULLogError(kGULLoggerReachability, NO,
  151|      0|                  [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode002],
  152|      0|                  @"Failed to start reachability handle");
  153|      0|      return NO;
  154|      0|    }
  155|      0|  }
  156|      0|  GULLogDebug(kGULLoggerReachability, NO,
  157|      0|              [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode003],
  158|      0|              @"Monitoring the network status");
  159|      0|  return YES;
  160|      0|#endif
  161|      0|}
  162|       |
  163|      0|- (void)stop {
  164|      0|#if !TARGET_OS_WATCH
  165|      0|  if (reachability_) {
  166|      0|    reachabilityStatus_ = kGULReachabilityUnknown;
  167|      0|    reachabilityApi_->unscheduleFromRunLoopFn(reachability_, CFRunLoopGetMain(),
  168|      0|                                              kCFRunLoopCommonModes);
  169|      0|    reachabilityApi_->releaseFn(reachability_);
  170|      0|    reachability_ = nil;
  171|      0|  }
  172|      0|#endif
  173|      0|}
  174|       |
  175|       |#if !TARGET_OS_WATCH
  176|      0|- (GULReachabilityStatus)statusForFlags:(SCNetworkReachabilityFlags)flags {
  177|      0|  GULReachabilityStatus status = kGULReachabilityNotReachable;
  178|       |  // If the Reachable flag is not set, we definitely don't have connectivity.
  179|      0|  if (flags & kSCNetworkReachabilityFlagsReachable) {
  180|       |    // Reachable flag is set. Check further flags.
  181|      0|    if (!(flags & kSCNetworkReachabilityFlagsConnectionRequired)) {
  182|       |// Connection required flag is not set, so we have connectivity.
  183|      0|#if TARGET_OS_IOS || TARGET_OS_TV
  184|      0|      status = (flags & kSCNetworkReachabilityFlagsIsWWAN) ? kGULReachabilityViaCellular
  185|      0|                                                           : kGULReachabilityViaWifi;
  186|       |#elif TARGET_OS_OSX
  187|       |      status = kGULReachabilityViaWifi;
  188|       |#endif
  189|      0|    } else if ((flags & (kSCNetworkReachabilityFlagsConnectionOnDemand |
  190|      0|                         kSCNetworkReachabilityFlagsConnectionOnTraffic)) &&
  191|      0|               !(flags & kSCNetworkReachabilityFlagsInterventionRequired)) {
  192|       |// If the connection on demand or connection on traffic flag is set, and user intervention
  193|       |// is not required, we have connectivity.
  194|      0|#if TARGET_OS_IOS || TARGET_OS_TV
  195|      0|      status = (flags & kSCNetworkReachabilityFlagsIsWWAN) ? kGULReachabilityViaCellular
  196|      0|                                                           : kGULReachabilityViaWifi;
  197|       |#elif TARGET_OS_OSX
  198|       |      status = kGULReachabilityViaWifi;
  199|       |#endif
  200|      0|    }
  201|      0|  }
  202|      0|  return status;
  203|      0|}
  204|       |
  205|      0|- (void)reachabilityFlagsChanged:(SCNetworkReachabilityFlags)flags {
  206|      0|  GULReachabilityStatus status = [self statusForFlags:flags];
  207|      0|  if (reachabilityStatus_ != status) {
  208|      0|    NSString *reachabilityStatusString;
  209|      0|    if (status == kGULReachabilityUnknown) {
  210|      0|      reachabilityStatusString = kGULReachabilityUnknownStatus;
  211|      0|    } else {
  212|      0|      reachabilityStatusString = (status == kGULReachabilityNotReachable)
  213|      0|                                     ? kGULReachabilityDisconnectedStatus
  214|      0|                                     : kGULReachabilityConnectedStatus;
  215|      0|    }
  216|       |
  217|      0|    GULLogDebug(kGULLoggerReachability, NO,
  218|      0|                [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode004],
  219|      0|                @"Network status has changed. Code:%@, status:%@", @(status),
  220|      0|                reachabilityStatusString);
  221|      0|    reachabilityStatus_ = status;
  222|      0|    [reachabilityDelegate_ reachability:self statusChanged:reachabilityStatus_];
  223|      0|  }
  224|      0|}
  225|       |
  226|       |#endif
  227|       |@end
  228|       |
  229|       |#if !TARGET_OS_WATCH
  230|       |static void ReachabilityCallback(SCNetworkReachabilityRef reachability,
  231|       |                                 SCNetworkReachabilityFlags flags,
  232|      0|                                 void *info) {
  233|      0|  GULReachabilityChecker *checker = (__bridge GULReachabilityChecker *)info;
  234|      0|  [checker reachabilityFlagsChanged:flags];
  235|      0|}
  236|       |#endif
  237|       |
  238|       |// This function used to be at the top of the file, but it was moved here
  239|       |// as a workaround for a suspected compiler bug. When compiled in Release mode
  240|       |// and run on an iOS device with WiFi disabled, the reachability code crashed
  241|       |// when calling SCNetworkReachabilityScheduleWithRunLoop, or shortly thereafter.
  242|       |// After unsuccessfully trying to diagnose the cause of the crash, it was
  243|       |// discovered that moving this function to the end of the file magically fixed
  244|       |// the crash. If you are going to edit this file, exercise caution and make sure
  245|       |// to test thoroughly with an iOS device under various network conditions.
  246|      0|const NSString *GULReachabilityStatusString(GULReachabilityStatus status) {
  247|      0|  switch (status) {
  248|      0|    case kGULReachabilityUnknown:
  249|      0|      return @"Reachability Unknown";
  250|       |
  251|      0|    case kGULReachabilityNotReachable:
  252|      0|      return @"Not reachable";
  253|       |
  254|      0|    case kGULReachabilityViaWifi:
  255|      0|      return @"Reachable via Wifi";
  256|       |
  257|      0|    case kGULReachabilityViaCellular:
  258|      0|      return @"Reachable via Cellular Data";
  259|       |
  260|      0|    default:
  261|      0|      return [NSString stringWithFormat:@"Invalid reachability status %d", (int)status];
  262|      0|  }
  263|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleUtilities/GoogleUtilities/UserDefaults/GULUserDefaults.m:
    1|       |// Copyright 2018 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/UserDefaults/Public/GoogleUtilities/GULUserDefaults.h"
   16|       |
   17|       |#import "GoogleUtilities/Logger/Public/GoogleUtilities/GULLogger.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |static NSTimeInterval const kGULSynchronizeInterval = 1.0;
   22|       |
   23|       |static NSString *const kGULLogFormat = @"I-GUL%06ld";
   24|       |
   25|       |static GULLoggerService kGULLogUserDefaultsService = @"[GoogleUtilities/UserDefaults]";
   26|       |
   27|       |typedef NS_ENUM(NSInteger, GULUDMessageCode) {
   28|       |  GULUDMessageCodeInvalidKeyGet = 1,
   29|       |  GULUDMessageCodeInvalidKeySet = 2,
   30|       |  GULUDMessageCodeInvalidObjectSet = 3,
   31|       |  GULUDMessageCodeSynchronizeFailed = 4,
   32|       |};
   33|       |
   34|       |@interface GULUserDefaults ()
   35|       |
   36|       |/// Equivalent to the suite name for NSUserDefaults.
   37|       |@property(readonly) CFStringRef appNameRef;
   38|       |
   39|       |@property(atomic) BOOL isPreferenceFileExcluded;
   40|       |
   41|       |@end
   42|       |
   43|       |@implementation GULUserDefaults {
   44|       |  // The application name is the same with the suite name of the NSUserDefaults, and it is used for
   45|       |  // preferences.
   46|       |  CFStringRef _appNameRef;
   47|       |}
   48|       |
   49|      0|+ (GULUserDefaults *)standardUserDefaults {
   50|      0|  static GULUserDefaults *standardUserDefaults;
   51|      0|  static dispatch_once_t onceToken;
   52|      0|  dispatch_once(&onceToken, ^{
   53|      0|    standardUserDefaults = [[GULUserDefaults alloc] init];
   54|      0|  });
   55|      0|  return standardUserDefaults;
   56|      0|}
   57|       |
   58|      0|- (instancetype)init {
   59|      0|  return [self initWithSuiteName:nil];
   60|      0|}
   61|       |
   62|      0|- (instancetype)initWithSuiteName:(nullable NSString *)suiteName {
   63|      0|  self = [super init];
   64|       |
   65|      0|  NSString *name = [suiteName copy];
   66|       |
   67|      0|  if (self) {
   68|       |    // `kCFPreferencesCurrentApplication` maps to the same defaults database as
   69|       |    // `[NSUserDefaults standardUserDefaults]`.
   70|      0|    _appNameRef =
   71|      0|        name.length ? (__bridge_retained CFStringRef)name : kCFPreferencesCurrentApplication;
   72|      0|  }
   73|       |
   74|      0|  return self;
   75|      0|}
   76|       |
   77|      0|- (void)dealloc {
   78|       |  // If we're using a custom `_appNameRef` it needs to be released. If it's a constant, it shouldn't
   79|       |  // need to be released since we don't own it.
   80|      0|  if (CFStringCompare(_appNameRef, kCFPreferencesCurrentApplication, 0) != kCFCompareEqualTo) {
   81|      0|    CFRelease(_appNameRef);
   82|      0|  }
   83|       |
   84|      0|  [NSObject cancelPreviousPerformRequestsWithTarget:self
   85|      0|                                           selector:@selector(synchronize)
   86|      0|                                             object:nil];
   87|      0|}
   88|       |
   89|      0|- (nullable id)objectForKey:(NSString *)defaultName {
   90|      0|  NSString *key = [defaultName copy];
   91|      0|  if (![key isKindOfClass:[NSString class]] || !key.length) {
   92|      0|    GULLogWarning(@"<GoogleUtilities>", NO,
   93|      0|                  [NSString stringWithFormat:kGULLogFormat, (long)GULUDMessageCodeInvalidKeyGet],
   94|      0|                  @"Cannot get object for invalid user default key.");
   95|      0|    return nil;
   96|      0|  }
   97|      0|  return (__bridge_transfer id)CFPreferencesCopyAppValue((__bridge CFStringRef)key, _appNameRef);
   98|      0|}
   99|       |
  100|      0|- (void)setObject:(nullable id)value forKey:(NSString *)defaultName {
  101|      0|  NSString *key = [defaultName copy];
  102|      0|  if (![key isKindOfClass:[NSString class]] || !key.length) {
  103|      0|    GULLogWarning(kGULLogUserDefaultsService, NO,
  104|      0|                  [NSString stringWithFormat:kGULLogFormat, (long)GULUDMessageCodeInvalidKeySet],
  105|      0|                  @"Cannot set object for invalid user default key.");
  106|      0|    return;
  107|      0|  }
  108|      0|  if (!value) {
  109|      0|    CFPreferencesSetAppValue((__bridge CFStringRef)key, NULL, _appNameRef);
  110|      0|    [self scheduleSynchronize];
  111|      0|    return;
  112|      0|  }
  113|      0|  BOOL isAcceptableValue =
  114|      0|      [value isKindOfClass:[NSString class]] || [value isKindOfClass:[NSNumber class]] ||
  115|      0|      [value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]] ||
  116|      0|      [value isKindOfClass:[NSDate class]] || [value isKindOfClass:[NSData class]];
  117|      0|  if (!isAcceptableValue) {
  118|      0|    GULLogWarning(kGULLogUserDefaultsService, NO,
  119|      0|                  [NSString stringWithFormat:kGULLogFormat, (long)GULUDMessageCodeInvalidObjectSet],
  120|      0|                  @"Cannot set invalid object to user defaults. Must be a string, number, array, "
  121|      0|                  @"dictionary, date, or data. Value: %@",
  122|      0|                  value);
  123|      0|    return;
  124|      0|  }
  125|       |
  126|      0|  CFPreferencesSetAppValue((__bridge CFStringRef)key, (__bridge CFStringRef)value, _appNameRef);
  127|      0|  [self scheduleSynchronize];
  128|      0|}
  129|       |
  130|      0|- (void)removeObjectForKey:(NSString *)key {
  131|      0|  [self setObject:nil forKey:key];
  132|      0|}
  133|       |
  134|       |#pragma mark - Getters
  135|       |
  136|      0|- (NSInteger)integerForKey:(NSString *)defaultName {
  137|      0|  NSNumber *object = [self objectForKey:defaultName];
  138|      0|  return object.integerValue;
  139|      0|}
  140|       |
  141|      0|- (float)floatForKey:(NSString *)defaultName {
  142|      0|  NSNumber *object = [self objectForKey:defaultName];
  143|      0|  return object.floatValue;
  144|      0|}
  145|       |
  146|      0|- (double)doubleForKey:(NSString *)defaultName {
  147|      0|  NSNumber *object = [self objectForKey:defaultName];
  148|      0|  return object.doubleValue;
  149|      0|}
  150|       |
  151|      0|- (BOOL)boolForKey:(NSString *)defaultName {
  152|      0|  NSNumber *object = [self objectForKey:defaultName];
  153|      0|  return object.boolValue;
  154|      0|}
  155|       |
  156|      0|- (nullable NSString *)stringForKey:(NSString *)defaultName {
  157|      0|  return [self objectForKey:defaultName];
  158|      0|}
  159|       |
  160|      0|- (nullable NSArray *)arrayForKey:(NSString *)defaultName {
  161|      0|  return [self objectForKey:defaultName];
  162|      0|}
  163|       |
  164|      0|- (nullable NSDictionary<NSString *, id> *)dictionaryForKey:(NSString *)defaultName {
  165|      0|  return [self objectForKey:defaultName];
  166|      0|}
  167|       |
  168|       |#pragma mark - Setters
  169|       |
  170|      0|- (void)setInteger:(NSInteger)integer forKey:(NSString *)defaultName {
  171|      0|  [self setObject:@(integer) forKey:defaultName];
  172|      0|}
  173|       |
  174|      0|- (void)setFloat:(float)value forKey:(NSString *)defaultName {
  175|      0|  [self setObject:@(value) forKey:defaultName];
  176|      0|}
  177|       |
  178|      0|- (void)setDouble:(double)doubleNumber forKey:(NSString *)defaultName {
  179|      0|  [self setObject:@(doubleNumber) forKey:defaultName];
  180|      0|}
  181|       |
  182|      0|- (void)setBool:(BOOL)boolValue forKey:(NSString *)defaultName {
  183|      0|  [self setObject:@(boolValue) forKey:defaultName];
  184|      0|}
  185|       |
  186|       |#pragma mark - Save data
  187|       |
  188|      0|- (void)synchronize {
  189|      0|  if (!CFPreferencesAppSynchronize(_appNameRef)) {
  190|      0|    GULLogError(kGULLogUserDefaultsService, NO,
  191|      0|                [NSString stringWithFormat:kGULLogFormat, (long)GULUDMessageCodeSynchronizeFailed],
  192|      0|                @"Cannot synchronize user defaults to disk");
  193|      0|  }
  194|      0|}
  195|       |
  196|       |#pragma mark - Private methods
  197|       |
  198|      0|- (void)scheduleSynchronize {
  199|       |  // Synchronize data using a timer so that multiple set... calls can be coalesced under one
  200|       |  // synchronize.
  201|      0|  [NSObject cancelPreviousPerformRequestsWithTarget:self
  202|      0|                                           selector:@selector(synchronize)
  203|      0|                                             object:nil];
  204|       |  // This method may be called on multiple queues (due to set... methods can be called on any queue)
  205|       |  // synchronize can be scheduled on different queues, so make sure that it does not crash. If this
  206|       |  // instance goes away, self will be released also, no one will retain it and the schedule won't be
  207|       |  // called.
  208|      0|  [self performSelector:@selector(synchronize) withObject:nil afterDelay:kGULSynchronizeInterval];
  209|      0|}
  210|       |
  211|       |@end
  212|       |
  213|       |NS_ASSUME_NONNULL_END

