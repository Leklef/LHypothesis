/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Carthage/Checkouts/CwlCatchException/Sources/CwlCatchException/CwlCatchException.swift:
    1|       |//
    2|       |//  CwlCatchException.swift
    3|       |//  CwlAssertionTesting
    4|       |//
    5|       |//  Created by Matt Gallagher on 2016/01/10.
    6|       |//  Copyright © 2016 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
    7|       |//
    8|       |//  Permission to use, copy, modify, and/or distribute this software for any
    9|       |//  purpose with or without fee is hereby granted, provided that the above
   10|       |//  copyright notice and this permission notice appear in all copies.
   11|       |//
   12|       |//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   13|       |//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   14|       |//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
   15|       |//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   16|       |//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   17|       |//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
   18|       |//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   19|       |//
   20|       |
   21|       |import Foundation
   22|       |
   23|       |#if SWIFT_PACKAGE
   24|       |import CwlCatchExceptionSupport
   25|       |#endif
   26|       |
   27|      0|private func catchReturnTypeConverter<T: NSException>(_ type: T.Type, block: @escaping () -> Void) -> T? {
   28|      0|	return catchExceptionOfKind(type, block) as? T
   29|      0|}
   30|       |
   31|       |extension NSException {
   32|      0|	public static func catchException(in block: @escaping () -> Void) -> Self? {
   33|      0|		return catchReturnTypeConverter(self, block: block)
   34|      0|	}
   35|       |}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Carthage/Checkouts/CwlCatchException/Sources/CwlCatchExceptionSupport/CwlCatchException.m:
    1|       |//
    2|       |//  CwlCatchException.m
    3|       |//  CwlAssertionTesting
    4|       |//
    5|       |//  Created by Matt Gallagher on 2016/01/10.
    6|       |//  Copyright © 2016 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
    7|       |//
    8|       |//  Permission to use, copy, modify, and/or distribute this software for any
    9|       |//  purpose with or without fee is hereby granted, provided that the above
   10|       |//  copyright notice and this permission notice appear in all copies.
   11|       |//
   12|       |//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   13|       |//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   14|       |//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
   15|       |//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   16|       |//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   17|       |//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
   18|       |//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   19|       |//
   20|       |
   21|       |#import "CwlCatchException.h"
   22|       |
   23|      0|NSException* __nullable catchExceptionOfKind(Class __nonnull type, void (^ __nonnull inBlock)(void)) {
   24|      0|	@try {
   25|      0|		inBlock();
   26|      0|	} @catch (NSException *exception) {
   27|      0|		if ([exception isKindOfClass:type]) {
   28|      0|			return exception;
   29|      0|		} else {
   30|      0|			@throw;
   31|      0|		}
   32|      0|	}
   33|      0|	return nil;
   34|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Carthage/Checkouts/CwlPreconditionTesting/Sources/CwlMachBadInstructionHandler/CwlMachBadInstructionHandler.m:
    1|       |//
    2|       |//  CwlMachBadExceptionHandler.m
    3|       |//  CwlPreconditionTesting
    4|       |//
    5|       |//  Created by Matt Gallagher on 2016/01/10.
    6|       |//  Copyright © 2016 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
    7|       |//
    8|       |//  Permission to use, copy, modify, and/or distribute this software for any
    9|       |//  purpose with or without fee is hereby granted, provided that the above
   10|       |//  copyright notice and this permission notice appear in all copies.
   11|       |//
   12|       |//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   13|       |//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   14|       |//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
   15|       |//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   16|       |//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   17|       |//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
   18|       |//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   19|       |//
   20|       |
   21|       |#ifdef __APPLE__
   22|       |#import "TargetConditionals.h"
   23|       |#if TARGET_OS_OSX || TARGET_OS_IOS
   24|       |
   25|       |#import "mach_excServer.h"
   26|       |#import "CwlMachBadInstructionHandler.h"
   27|       |
   28|       |@protocol BadInstructionReply <NSObject>
   29|       |+(NSNumber *)receiveReply:(NSValue *)value;
   30|       |@end
   31|       |
   32|       |/// A basic function that receives callbacks from mach_exc_server and relays them to the Swift implemented BadInstructionException.catch_mach_exception_raise_state.
   33|      0|kern_return_t catch_mach_exception_raise_state(mach_port_t exception_port, exception_type_t exception, const mach_exception_data_t code, mach_msg_type_number_t codeCnt, int *flavor, const thread_state_t old_state, mach_msg_type_number_t old_stateCnt, thread_state_t new_state, mach_msg_type_number_t *new_stateCnt) {
   34|      0|	bad_instruction_exception_reply_t reply = { exception_port, exception, code, codeCnt, flavor, old_state, old_stateCnt, new_state, new_stateCnt };
   35|      0|	Class badInstructionClass = NSClassFromString(@"BadInstructionException");
   36|      0|	NSValue *value = [NSValue valueWithBytes: &reply objCType: @encode(bad_instruction_exception_reply_t)];
   37|      0|	return [[badInstructionClass performSelector: @selector(receiveReply:) withObject: value] intValue];
   38|      0|}
   39|       |
   40|       |// The mach port should be configured so that this function is never used.
   41|      0|kern_return_t catch_mach_exception_raise(mach_port_t exception_port, mach_port_t thread, mach_port_t task, exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt) {
   42|      0|	assert(false);
   43|      0|	return KERN_FAILURE;
   44|      0|}
   45|       |
   46|       |// The mach port should be configured so that this function is never used.
   47|      0|kern_return_t catch_mach_exception_raise_state_identity(mach_port_t exception_port, mach_port_t thread, mach_port_t task, exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt, int *flavor, thread_state_t old_state, mach_msg_type_number_t old_stateCnt, thread_state_t new_state, mach_msg_type_number_t *new_stateCnt) {
   48|      0|	assert(false);
   49|      0|	return KERN_FAILURE;
   50|      0|}
   51|       |
   52|      0|NDR_record_t mach_ndr_record(void) {
   53|      0|	return NDR_record;
   54|      0|}
   55|       |
   56|       |#endif /* TARGET_OS_OSX || TARGET_OS_IOS */
   57|       |#endif /* __APPLE__ */

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Carthage/Checkouts/CwlPreconditionTesting/Sources/CwlMachBadInstructionHandler/mach_excServer.c:
    1|       |/*
    2|       | * IDENTIFICATION:
    3|       | * stub generated Sun Jan 29 19:05:29 2017
    4|       | * with a MiG generated by bootstrap_cmds-96.20.2
    5|       | * OPTIONS: 
    6|       | */
    7|       |
    8|       |/* Module mach_exc */
    9|       |
   10|       |#define	__MIG_check__Request__mach_exc_subsystem__ 1
   11|       |
   12|       |#import "mach_excServer.h"
   13|       |#if TARGET_OS_OSX || TARGET_OS_IOS
   14|       |
   15|       |#ifndef	mig_internal
   16|       |#define	mig_internal	static __inline__
   17|       |#endif	/* mig_internal */
   18|       |
   19|       |#ifndef	mig_external
   20|       |#define mig_external
   21|       |#endif	/* mig_external */
   22|       |
   23|       |#if	!defined(__MigTypeCheck) && defined(TypeCheck)
   24|       |#define	__MigTypeCheck		TypeCheck	/* Legacy setting */
   25|       |#endif	/* !defined(__MigTypeCheck) */
   26|       |
   27|       |#if	!defined(__MigKernelSpecificCode) && defined(_MIG_KERNEL_SPECIFIC_CODE_)
   28|       |#define	__MigKernelSpecificCode	_MIG_KERNEL_SPECIFIC_CODE_	/* Legacy setting */
   29|       |#endif	/* !defined(__MigKernelSpecificCode) */
   30|       |
   31|       |#ifndef	LimitCheck
   32|       |#define	LimitCheck 0
   33|       |#endif	/* LimitCheck */
   34|       |
   35|       |#ifndef	min
   36|       |#define	min(a,b)  ( ((a) < (b))? (a): (b) )
   37|       |#endif	/* min */
   38|       |
   39|       |#if !defined(_WALIGN_)
   40|       |#define _WALIGN_(x) (((x) + 3) & ~3)
   41|       |#endif /* !defined(_WALIGN_) */
   42|       |
   43|       |#if !defined(_WALIGNSZ_)
   44|       |#define _WALIGNSZ_(x) _WALIGN_(sizeof(x))
   45|       |#endif /* !defined(_WALIGNSZ_) */
   46|       |
   47|       |#ifndef	UseStaticTemplates
   48|       |#define	UseStaticTemplates	0
   49|       |#endif	/* UseStaticTemplates */
   50|       |
   51|       |#ifndef	__DeclareRcvRpc
   52|       |#define	__DeclareRcvRpc(_NUM_, _NAME_)
   53|       |#endif	/* __DeclareRcvRpc */
   54|       |
   55|       |#ifndef	__BeforeRcvRpc
   56|       |#define	__BeforeRcvRpc(_NUM_, _NAME_)
   57|       |#endif	/* __BeforeRcvRpc */
   58|       |
   59|       |#ifndef	__AfterRcvRpc
   60|       |#define	__AfterRcvRpc(_NUM_, _NAME_)
   61|       |#endif	/* __AfterRcvRpc */
   62|       |
   63|       |#ifndef	__DeclareRcvSimple
   64|       |#define	__DeclareRcvSimple(_NUM_, _NAME_)
   65|       |#endif	/* __DeclareRcvSimple */
   66|       |
   67|       |#ifndef	__BeforeRcvSimple
   68|       |#define	__BeforeRcvSimple(_NUM_, _NAME_)
   69|       |#endif	/* __BeforeRcvSimple */
   70|       |
   71|       |#ifndef	__AfterRcvSimple
   72|       |#define	__AfterRcvSimple(_NUM_, _NAME_)
   73|       |#endif	/* __AfterRcvSimple */
   74|       |
   75|       |#define novalue void
   76|       |
   77|      0|#define msgh_request_port	msgh_local_port
   78|       |#define MACH_MSGH_BITS_REQUEST(bits)	MACH_MSGH_BITS_LOCAL(bits)
   79|      0|#define msgh_reply_port		msgh_remote_port
   80|       |#define MACH_MSGH_BITS_REPLY(bits)	MACH_MSGH_BITS_REMOTE(bits)
   81|       |
   82|      0|#define MIG_RETURN_ERROR(X, code)	{\
   83|      0|				((mig_reply_error_t *)X)->RetCode = code;\
   84|      0|				((mig_reply_error_t *)X)->NDR = NDR_record;\
   85|      0|				return;\
   86|      0|				}
   87|       |
   88|       |/* Forward Declarations */
   89|       |
   90|       |
   91|       |mig_internal novalue _Xmach_exception_raise
   92|       |	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);
   93|       |
   94|       |mig_internal novalue _Xmach_exception_raise_state
   95|       |	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);
   96|       |
   97|       |mig_internal novalue _Xmach_exception_raise_state_identity
   98|       |	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);
   99|       |
  100|       |
  101|       |#if ( __MigTypeCheck )
  102|       |#if __MIG_check__Request__mach_exc_subsystem__
  103|       |#if !defined(__MIG_check__Request__mach_exception_raise_t__defined)
  104|       |#define __MIG_check__Request__mach_exception_raise_t__defined
  105|       |
  106|       |mig_internal kern_return_t __MIG_check__Request__mach_exception_raise_t(__attribute__((__unused__)) __Request__mach_exception_raise_t *In0P)
  107|      0|{
  108|       |
  109|      0|	typedef __Request__mach_exception_raise_t __Request;
  110|      0|#if	__MigTypeCheck
  111|      0|	unsigned int msgh_size;
  112|      0|#endif	/* __MigTypeCheck */
  113|       |
  114|      0|#if	__MigTypeCheck
  115|      0|	msgh_size = In0P->Head.msgh_size;
  116|      0|	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
  117|      0|	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
  118|      0|	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 16)) ||  (msgh_size > (mach_msg_size_t)sizeof(__Request)))
  119|      0|		return MIG_BAD_ARGUMENTS;
  120|      0|#endif	/* __MigTypeCheck */
  121|       |
  122|      0|#if	__MigTypeCheck
  123|      0|	if (In0P->thread.type != MACH_MSG_PORT_DESCRIPTOR ||
  124|      0|	    In0P->thread.disposition != 17)
  125|      0|		return MIG_TYPE_ERROR;
  126|      0|#endif	/* __MigTypeCheck */
  127|       |
  128|      0|#if	__MigTypeCheck
  129|      0|	if (In0P->task.type != MACH_MSG_PORT_DESCRIPTOR ||
  130|      0|	    In0P->task.disposition != 17)
  131|      0|		return MIG_TYPE_ERROR;
  132|      0|#endif	/* __MigTypeCheck */
  133|       |
  134|       |#if defined(__NDR_convert__int_rep__Request__mach_exception_raise_t__codeCnt__defined)
  135|       |	if (In0P->NDR.int_rep != NDR_record.int_rep)
  136|       |		__NDR_convert__int_rep__Request__mach_exception_raise_t__codeCnt(&In0P->codeCnt, In0P->NDR.int_rep);
  137|       |#endif	/* __NDR_convert__int_rep__Request__mach_exception_raise_t__codeCnt__defined */
  138|      0|#if	__MigTypeCheck
  139|      0|	if ( In0P->codeCnt > 2 )
  140|      0|		return MIG_BAD_ARGUMENTS;
  141|      0|	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 16)) / 8 < In0P->codeCnt) ||
  142|      0|	    (msgh_size != (mach_msg_size_t)(sizeof(__Request) - 16) + (8 * In0P->codeCnt)))
  143|      0|		return MIG_BAD_ARGUMENTS;
  144|      0|#endif	/* __MigTypeCheck */
  145|       |
  146|      0|	return MACH_MSG_SUCCESS;
  147|      0|}
  148|       |#endif /* !defined(__MIG_check__Request__mach_exception_raise_t__defined) */
  149|       |#endif /* __MIG_check__Request__mach_exc_subsystem__ */
  150|       |#endif /* ( __MigTypeCheck ) */
  151|       |
  152|       |
  153|       |/* Routine mach_exception_raise */
  154|       |mig_internal novalue _Xmach_exception_raise
  155|       |	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
  156|      0|{
  157|       |
  158|      0|#ifdef  __MigPackStructs
  159|      0|#pragma pack(4)
  160|      0|#endif
  161|      0|	typedef struct {
  162|      0|		mach_msg_header_t Head;
  163|       |		/* start of the kernel processed data */
  164|      0|		mach_msg_body_t msgh_body;
  165|      0|		mach_msg_port_descriptor_t thread;
  166|      0|		mach_msg_port_descriptor_t task;
  167|       |		/* end of the kernel processed data */
  168|      0|		NDR_record_t NDR;
  169|      0|		exception_type_t exception;
  170|      0|		mach_msg_type_number_t codeCnt;
  171|      0|		int64_t code[2];
  172|      0|		mach_msg_trailer_t trailer;
  173|      0|	} Request __attribute__((unused));
  174|      0|#ifdef  __MigPackStructs
  175|      0|#pragma pack()
  176|      0|#endif
  177|      0|	typedef __Request__mach_exception_raise_t __Request;
  178|      0|	typedef __Reply__mach_exception_raise_t Reply __attribute__((unused));
  179|       |
  180|       |	/*
  181|       |	 * typedef struct {
  182|       |	 * 	mach_msg_header_t Head;
  183|       |	 * 	NDR_record_t NDR;
  184|       |	 * 	kern_return_t RetCode;
  185|       |	 * } mig_reply_error_t;
  186|       |	 */
  187|       |
  188|      0|	Request *In0P = (Request *) InHeadP;
  189|      0|	Reply *OutP = (Reply *) OutHeadP;
  190|      0|#ifdef	__MIG_check__Request__mach_exception_raise_t__defined
  191|      0|	kern_return_t check_result;
  192|      0|#endif	/* __MIG_check__Request__mach_exception_raise_t__defined */
  193|       |
  194|      0|	__DeclareRcvRpc(2405, "mach_exception_raise")
  195|      0|	__BeforeRcvRpc(2405, "mach_exception_raise")
  196|       |
  197|      0|#if	defined(__MIG_check__Request__mach_exception_raise_t__defined)
  198|      0|	check_result = __MIG_check__Request__mach_exception_raise_t((__Request *)In0P);
  199|      0|	if (check_result != MACH_MSG_SUCCESS)
  200|      0|		{ MIG_RETURN_ERROR(OutP, check_result); }
  201|      0|#endif	/* defined(__MIG_check__Request__mach_exception_raise_t__defined) */
  202|       |
  203|      0|	OutP->RetCode = catch_mach_exception_raise(In0P->Head.msgh_request_port, In0P->thread.name, In0P->task.name, In0P->exception, In0P->code, In0P->codeCnt);
  204|       |
  205|      0|	OutP->NDR = NDR_record;
  206|       |
  207|       |
  208|      0|	__AfterRcvRpc(2405, "mach_exception_raise")
  209|      0|}
  210|       |
  211|       |#if ( __MigTypeCheck )
  212|       |#if __MIG_check__Request__mach_exc_subsystem__
  213|       |#if !defined(__MIG_check__Request__mach_exception_raise_state_t__defined)
  214|       |#define __MIG_check__Request__mach_exception_raise_state_t__defined
  215|       |
  216|       |mig_internal kern_return_t __MIG_check__Request__mach_exception_raise_state_t(__attribute__((__unused__)) __Request__mach_exception_raise_state_t *In0P, __attribute__((__unused__)) __Request__mach_exception_raise_state_t **In1PP)
  217|      0|{
  218|       |
  219|      0|	typedef __Request__mach_exception_raise_state_t __Request;
  220|      0|	__Request *In1P;
  221|      0|#if	__MigTypeCheck
  222|      0|	unsigned int msgh_size;
  223|      0|#endif	/* __MigTypeCheck */
  224|      0|	unsigned int msgh_size_delta;
  225|       |
  226|      0|#if	__MigTypeCheck
  227|      0|	msgh_size = In0P->Head.msgh_size;
  228|      0|	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
  229|      0|	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 912)) ||  (msgh_size > (mach_msg_size_t)sizeof(__Request)))
  230|      0|		return MIG_BAD_ARGUMENTS;
  231|      0|#endif	/* __MigTypeCheck */
  232|       |
  233|       |#if defined(__NDR_convert__int_rep__Request__mach_exception_raise_state_t__codeCnt__defined)
  234|       |	if (In0P->NDR.int_rep != NDR_record.int_rep)
  235|       |		__NDR_convert__int_rep__Request__mach_exception_raise_state_t__codeCnt(&In0P->codeCnt, In0P->NDR.int_rep);
  236|       |#endif	/* __NDR_convert__int_rep__Request__mach_exception_raise_state_t__codeCnt__defined */
  237|      0|	msgh_size_delta = (8 * In0P->codeCnt);
  238|      0|#if	__MigTypeCheck
  239|      0|	if ( In0P->codeCnt > 2 )
  240|      0|		return MIG_BAD_ARGUMENTS;
  241|      0|	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 912)) / 8 < In0P->codeCnt) ||
  242|      0|	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 912) + (8 * In0P->codeCnt)))
  243|      0|		return MIG_BAD_ARGUMENTS;
  244|      0|	msgh_size -= msgh_size_delta;
  245|      0|#endif	/* __MigTypeCheck */
  246|       |
  247|      0|	*In1PP = In1P = (__Request *) ((pointer_t) In0P + msgh_size_delta - 16);
  248|       |
  249|       |#if defined(__NDR_convert__int_rep__Request__mach_exception_raise_state_t__old_stateCnt__defined)
  250|       |	if (In0P->NDR.int_rep != NDR_record.int_rep)
  251|       |		__NDR_convert__int_rep__Request__mach_exception_raise_state_t__old_stateCnt(&In1P->old_stateCnt, In1P->NDR.int_rep);
  252|       |#endif	/* __NDR_convert__int_rep__Request__mach_exception_raise_state_t__old_stateCnt__defined */
  253|      0|#if	__MigTypeCheck
  254|      0|	if ( In1P->old_stateCnt > 224 )
  255|      0|		return MIG_BAD_ARGUMENTS;
  256|      0|	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 912)) / 4 < In1P->old_stateCnt) ||
  257|      0|	    (msgh_size != (mach_msg_size_t)(sizeof(__Request) - 912) + (4 * In1P->old_stateCnt)))
  258|      0|		return MIG_BAD_ARGUMENTS;
  259|      0|#endif	/* __MigTypeCheck */
  260|       |
  261|      0|	return MACH_MSG_SUCCESS;
  262|      0|}
  263|       |#endif /* !defined(__MIG_check__Request__mach_exception_raise_state_t__defined) */
  264|       |#endif /* __MIG_check__Request__mach_exc_subsystem__ */
  265|       |#endif /* ( __MigTypeCheck ) */
  266|       |
  267|       |
  268|       |/* Routine mach_exception_raise_state */
  269|       |mig_internal novalue _Xmach_exception_raise_state
  270|       |	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
  271|      0|{
  272|       |
  273|      0|#ifdef  __MigPackStructs
  274|      0|#pragma pack(4)
  275|      0|#endif
  276|      0|	typedef struct {
  277|      0|		mach_msg_header_t Head;
  278|      0|		NDR_record_t NDR;
  279|      0|		exception_type_t exception;
  280|      0|		mach_msg_type_number_t codeCnt;
  281|      0|		int64_t code[2];
  282|      0|		int flavor;
  283|      0|		mach_msg_type_number_t old_stateCnt;
  284|      0|		natural_t old_state[224];
  285|      0|		mach_msg_trailer_t trailer;
  286|      0|	} Request __attribute__((unused));
  287|      0|#ifdef  __MigPackStructs
  288|      0|#pragma pack()
  289|      0|#endif
  290|      0|	typedef __Request__mach_exception_raise_state_t __Request;
  291|      0|	typedef __Reply__mach_exception_raise_state_t Reply __attribute__((unused));
  292|       |
  293|       |	/*
  294|       |	 * typedef struct {
  295|       |	 * 	mach_msg_header_t Head;
  296|       |	 * 	NDR_record_t NDR;
  297|       |	 * 	kern_return_t RetCode;
  298|       |	 * } mig_reply_error_t;
  299|       |	 */
  300|       |
  301|      0|	Request *In0P = (Request *) InHeadP;
  302|      0|	Request *In1P;
  303|      0|	Reply *OutP = (Reply *) OutHeadP;
  304|      0|#ifdef	__MIG_check__Request__mach_exception_raise_state_t__defined
  305|      0|	kern_return_t check_result;
  306|      0|#endif	/* __MIG_check__Request__mach_exception_raise_state_t__defined */
  307|       |
  308|      0|	__DeclareRcvRpc(2406, "mach_exception_raise_state")
  309|      0|	__BeforeRcvRpc(2406, "mach_exception_raise_state")
  310|       |
  311|      0|#if	defined(__MIG_check__Request__mach_exception_raise_state_t__defined)
  312|      0|	check_result = __MIG_check__Request__mach_exception_raise_state_t((__Request *)In0P, (__Request **)&In1P);
  313|      0|	if (check_result != MACH_MSG_SUCCESS)
  314|      0|		{ MIG_RETURN_ERROR(OutP, check_result); }
  315|      0|#endif	/* defined(__MIG_check__Request__mach_exception_raise_state_t__defined) */
  316|       |
  317|      0|	OutP->new_stateCnt = 224;
  318|       |
  319|      0|	OutP->RetCode = catch_mach_exception_raise_state(In0P->Head.msgh_request_port, In0P->exception, In0P->code, In0P->codeCnt, &In1P->flavor, In1P->old_state, In1P->old_stateCnt, OutP->new_state, &OutP->new_stateCnt);
  320|      0|	if (OutP->RetCode != KERN_SUCCESS) {
  321|      0|		MIG_RETURN_ERROR(OutP, OutP->RetCode);
  322|      0|	}
  323|       |
  324|      0|	OutP->NDR = NDR_record;
  325|       |
  326|       |
  327|      0|	OutP->flavor = In1P->flavor;
  328|      0|	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply) - 896) + (((4 * OutP->new_stateCnt)));
  329|       |
  330|      0|	__AfterRcvRpc(2406, "mach_exception_raise_state")
  331|      0|}
  332|       |
  333|       |#if ( __MigTypeCheck )
  334|       |#if __MIG_check__Request__mach_exc_subsystem__
  335|       |#if !defined(__MIG_check__Request__mach_exception_raise_state_identity_t__defined)
  336|       |#define __MIG_check__Request__mach_exception_raise_state_identity_t__defined
  337|       |
  338|       |mig_internal kern_return_t __MIG_check__Request__mach_exception_raise_state_identity_t(__attribute__((__unused__)) __Request__mach_exception_raise_state_identity_t *In0P, __attribute__((__unused__)) __Request__mach_exception_raise_state_identity_t **In1PP)
  339|      0|{
  340|       |
  341|      0|	typedef __Request__mach_exception_raise_state_identity_t __Request;
  342|      0|	__Request *In1P;
  343|      0|#if	__MigTypeCheck
  344|      0|	unsigned int msgh_size;
  345|      0|#endif	/* __MigTypeCheck */
  346|      0|	unsigned int msgh_size_delta;
  347|       |
  348|      0|#if	__MigTypeCheck
  349|      0|	msgh_size = In0P->Head.msgh_size;
  350|      0|	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
  351|      0|	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
  352|      0|	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 912)) ||  (msgh_size > (mach_msg_size_t)sizeof(__Request)))
  353|      0|		return MIG_BAD_ARGUMENTS;
  354|      0|#endif	/* __MigTypeCheck */
  355|       |
  356|      0|#if	__MigTypeCheck
  357|      0|	if (In0P->thread.type != MACH_MSG_PORT_DESCRIPTOR ||
  358|      0|	    In0P->thread.disposition != 17)
  359|      0|		return MIG_TYPE_ERROR;
  360|      0|#endif	/* __MigTypeCheck */
  361|       |
  362|      0|#if	__MigTypeCheck
  363|      0|	if (In0P->task.type != MACH_MSG_PORT_DESCRIPTOR ||
  364|      0|	    In0P->task.disposition != 17)
  365|      0|		return MIG_TYPE_ERROR;
  366|      0|#endif	/* __MigTypeCheck */
  367|       |
  368|       |#if defined(__NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__codeCnt__defined)
  369|       |	if (In0P->NDR.int_rep != NDR_record.int_rep)
  370|       |		__NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__codeCnt(&In0P->codeCnt, In0P->NDR.int_rep);
  371|       |#endif	/* __NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__codeCnt__defined */
  372|      0|	msgh_size_delta = (8 * In0P->codeCnt);
  373|      0|#if	__MigTypeCheck
  374|      0|	if ( In0P->codeCnt > 2 )
  375|      0|		return MIG_BAD_ARGUMENTS;
  376|      0|	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 912)) / 8 < In0P->codeCnt) ||
  377|      0|	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 912) + (8 * In0P->codeCnt)))
  378|      0|		return MIG_BAD_ARGUMENTS;
  379|      0|	msgh_size -= msgh_size_delta;
  380|      0|#endif	/* __MigTypeCheck */
  381|       |
  382|      0|	*In1PP = In1P = (__Request *) ((pointer_t) In0P + msgh_size_delta - 16);
  383|       |
  384|       |#if defined(__NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__old_stateCnt__defined)
  385|       |	if (In0P->NDR.int_rep != NDR_record.int_rep)
  386|       |		__NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__old_stateCnt(&In1P->old_stateCnt, In1P->NDR.int_rep);
  387|       |#endif	/* __NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__old_stateCnt__defined */
  388|      0|#if	__MigTypeCheck
  389|      0|	if ( In1P->old_stateCnt > 224 )
  390|      0|		return MIG_BAD_ARGUMENTS;
  391|      0|	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 912)) / 4 < In1P->old_stateCnt) ||
  392|      0|	    (msgh_size != (mach_msg_size_t)(sizeof(__Request) - 912) + (4 * In1P->old_stateCnt)))
  393|      0|		return MIG_BAD_ARGUMENTS;
  394|      0|#endif	/* __MigTypeCheck */
  395|       |
  396|      0|	return MACH_MSG_SUCCESS;
  397|      0|}
  398|       |#endif /* !defined(__MIG_check__Request__mach_exception_raise_state_identity_t__defined) */
  399|       |#endif /* __MIG_check__Request__mach_exc_subsystem__ */
  400|       |#endif /* ( __MigTypeCheck ) */
  401|       |
  402|       |
  403|       |/* Routine mach_exception_raise_state_identity */
  404|       |mig_internal novalue _Xmach_exception_raise_state_identity
  405|       |	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
  406|      0|{
  407|       |
  408|      0|#ifdef  __MigPackStructs
  409|      0|#pragma pack(4)
  410|      0|#endif
  411|      0|	typedef struct {
  412|      0|		mach_msg_header_t Head;
  413|       |		/* start of the kernel processed data */
  414|      0|		mach_msg_body_t msgh_body;
  415|      0|		mach_msg_port_descriptor_t thread;
  416|      0|		mach_msg_port_descriptor_t task;
  417|       |		/* end of the kernel processed data */
  418|      0|		NDR_record_t NDR;
  419|      0|		exception_type_t exception;
  420|      0|		mach_msg_type_number_t codeCnt;
  421|      0|		int64_t code[2];
  422|      0|		int flavor;
  423|      0|		mach_msg_type_number_t old_stateCnt;
  424|      0|		natural_t old_state[224];
  425|      0|		mach_msg_trailer_t trailer;
  426|      0|	} Request __attribute__((unused));
  427|      0|#ifdef  __MigPackStructs
  428|      0|#pragma pack()
  429|      0|#endif
  430|      0|	typedef __Request__mach_exception_raise_state_identity_t __Request;
  431|      0|	typedef __Reply__mach_exception_raise_state_identity_t Reply __attribute__((unused));
  432|       |
  433|       |	/*
  434|       |	 * typedef struct {
  435|       |	 * 	mach_msg_header_t Head;
  436|       |	 * 	NDR_record_t NDR;
  437|       |	 * 	kern_return_t RetCode;
  438|       |	 * } mig_reply_error_t;
  439|       |	 */
  440|       |
  441|      0|	Request *In0P = (Request *) InHeadP;
  442|      0|	Request *In1P;
  443|      0|	Reply *OutP = (Reply *) OutHeadP;
  444|      0|#ifdef	__MIG_check__Request__mach_exception_raise_state_identity_t__defined
  445|      0|	kern_return_t check_result;
  446|      0|#endif	/* __MIG_check__Request__mach_exception_raise_state_identity_t__defined */
  447|       |
  448|      0|	__DeclareRcvRpc(2407, "mach_exception_raise_state_identity")
  449|      0|	__BeforeRcvRpc(2407, "mach_exception_raise_state_identity")
  450|       |
  451|      0|#if	defined(__MIG_check__Request__mach_exception_raise_state_identity_t__defined)
  452|      0|	check_result = __MIG_check__Request__mach_exception_raise_state_identity_t((__Request *)In0P, (__Request **)&In1P);
  453|      0|	if (check_result != MACH_MSG_SUCCESS)
  454|      0|		{ MIG_RETURN_ERROR(OutP, check_result); }
  455|      0|#endif	/* defined(__MIG_check__Request__mach_exception_raise_state_identity_t__defined) */
  456|       |
  457|      0|	OutP->new_stateCnt = 224;
  458|       |
  459|      0|	OutP->RetCode = catch_mach_exception_raise_state_identity(In0P->Head.msgh_request_port, In0P->thread.name, In0P->task.name, In0P->exception, In0P->code, In0P->codeCnt, &In1P->flavor, In1P->old_state, In1P->old_stateCnt, OutP->new_state, &OutP->new_stateCnt);
  460|      0|	if (OutP->RetCode != KERN_SUCCESS) {
  461|      0|		MIG_RETURN_ERROR(OutP, OutP->RetCode);
  462|      0|	}
  463|       |
  464|      0|	OutP->NDR = NDR_record;
  465|       |
  466|       |
  467|      0|	OutP->flavor = In1P->flavor;
  468|      0|	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply) - 896) + (((4 * OutP->new_stateCnt)));
  469|       |
  470|      0|	__AfterRcvRpc(2407, "mach_exception_raise_state_identity")
  471|      0|}
  472|       |
  473|       |
  474|       |
  475|       |/* Description of this subsystem, for use in direct RPC */
  476|       |const struct catch_mach_exc_subsystem catch_mach_exc_subsystem = {
  477|       |	mach_exc_server_routine,
  478|       |	2405,
  479|       |	2408,
  480|       |	(mach_msg_size_t)sizeof(union __ReplyUnion__catch_mach_exc_subsystem),
  481|       |	(vm_address_t)0,
  482|       |	{
  483|       |          { (mig_impl_routine_t) 0,
  484|       |          (mig_stub_routine_t) _Xmach_exception_raise, 6, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__mach_exception_raise_t)},
  485|       |          { (mig_impl_routine_t) 0,
  486|       |          (mig_stub_routine_t) _Xmach_exception_raise_state, 9, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__mach_exception_raise_state_t)},
  487|       |          { (mig_impl_routine_t) 0,
  488|       |          (mig_stub_routine_t) _Xmach_exception_raise_state_identity, 11, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__mach_exception_raise_state_identity_t)},
  489|       |	}
  490|       |};
  491|       |
  492|       |mig_external boolean_t mach_exc_server
  493|       |	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
  494|      0|{
  495|       |	/*
  496|       |	 * typedef struct {
  497|       |	 * 	mach_msg_header_t Head;
  498|       |	 * 	NDR_record_t NDR;
  499|       |	 * 	kern_return_t RetCode;
  500|       |	 * } mig_reply_error_t;
  501|       |	 */
  502|       |
  503|      0|	register mig_routine_t routine;
  504|       |
  505|      0|	OutHeadP->msgh_bits = MACH_MSGH_BITS(MACH_MSGH_BITS_REPLY(InHeadP->msgh_bits), 0);
  506|      0|	OutHeadP->msgh_remote_port = InHeadP->msgh_reply_port;
  507|       |	/* Minimal size: routine() will update it if different */
  508|      0|	OutHeadP->msgh_size = (mach_msg_size_t)sizeof(mig_reply_error_t);
  509|      0|	OutHeadP->msgh_local_port = MACH_PORT_NULL;
  510|      0|	OutHeadP->msgh_id = InHeadP->msgh_id + 100;
  511|      0|	OutHeadP->msgh_reserved = 0;
  512|       |
  513|      0|	if ((InHeadP->msgh_id > 2407) || (InHeadP->msgh_id < 2405) ||
  514|      0|	    ((routine = catch_mach_exc_subsystem.routine[InHeadP->msgh_id - 2405].stub_routine) == 0)) {
  515|      0|		((mig_reply_error_t *)OutHeadP)->NDR = NDR_record;
  516|      0|		((mig_reply_error_t *)OutHeadP)->RetCode = MIG_BAD_ID;
  517|      0|		return FALSE;
  518|      0|	}
  519|      0|	(*routine) (InHeadP, OutHeadP);
  520|      0|	return TRUE;
  521|      0|}
  522|       |
  523|       |mig_external mig_routine_t mach_exc_server_routine
  524|       |	(mach_msg_header_t *InHeadP)
  525|      0|{
  526|      0|	register int msgh_id;
  527|       |
  528|      0|	msgh_id = InHeadP->msgh_id - 2405;
  529|       |
  530|      0|	if ((msgh_id > 2) || (msgh_id < 0))
  531|      0|		return 0;
  532|       |
  533|      0|	return catch_mach_exc_subsystem.routine[msgh_id].stub_routine;
  534|      0|}
  535|       |
  536|       |#endif /* TARGET_OS_OSX || TARGET_OS_IOS */

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Carthage/Checkouts/CwlPreconditionTesting/Sources/CwlPreconditionTesting/CwlBadInstructionException.swift:
    1|       |//
    2|       |//  CwlBadInstructionException.swift
    3|       |//  CwlPreconditionTesting
    4|       |//
    5|       |//  Created by Matt Gallagher on 2016/01/10.
    6|       |//  Copyright © 2016 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
    7|       |//
    8|       |//  Permission to use, copy, modify, and/or distribute this software for any
    9|       |//  purpose with or without fee is hereby granted, provided that the above
   10|       |//  copyright notice and this permission notice appear in all copies.
   11|       |//
   12|       |//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   13|       |//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   14|       |//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
   15|       |//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   16|       |//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   17|       |//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
   18|       |//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   19|       |//
   20|       |
   21|       |#if (os(macOS) || os(iOS)) && arch(x86_64)
   22|       |
   23|       |import Foundation
   24|       |
   25|       |#if SWIFT_PACKAGE
   26|       |	import CwlMachBadInstructionHandler
   27|       |#endif
   28|       |
   29|      0|private func raiseBadInstructionException() {
   30|      0|	BadInstructionException().raise()
   31|      0|}
   32|       |
   33|       |/// A simple NSException subclass. It's not required to subclass NSException (since the exception type is represented in the name) but this helps for identifying the exception through runtime type.
   34|       |@objc(BadInstructionException)
   35|       |public class BadInstructionException: NSException {
   36|       |	static var name: String = "com.cocoawithlove.BadInstruction"
   37|       |	
   38|      0|	init() {
   39|      0|		super.init(name: NSExceptionName(rawValue: BadInstructionException.name), reason: nil, userInfo: nil)
   40|      0|	}
   41|       |	
   42|      0|	required public init?(coder aDecoder: NSCoder) {
   43|      0|		super.init(coder: aDecoder)
   44|      0|	}
   45|       |	
   46|       |	/// An Objective-C callable function, invoked from the `mach_exc_server` callback function `catch_mach_exception_raise_state` to push the `raiseBadInstructionException` function onto the stack.
   47|       |	@objc(receiveReply:)
   48|      0|	public class func receiveReply(_ value: NSValue) -> NSNumber {
   49|      0|		var reply = bad_instruction_exception_reply_t(exception_port: 0, exception: 0, code: nil, codeCnt: 0, flavor: nil, old_state: nil, old_stateCnt: 0, new_state: nil, new_stateCnt: nil)
   50|      0|		withUnsafeMutablePointer(to: &reply) { value.getValue(UnsafeMutableRawPointer($0)) }
   51|      0|		
   52|      0|		let old_state: UnsafePointer<natural_t> = reply.old_state!
   53|      0|		let old_stateCnt: mach_msg_type_number_t = reply.old_stateCnt
   54|      0|		let new_state: thread_state_t = reply.new_state!
   55|      0|		let new_stateCnt: UnsafeMutablePointer<mach_msg_type_number_t> = reply.new_stateCnt!
   56|      0|		
   57|      0|		// Make sure we've been given enough memory
   58|      0|		if old_stateCnt != x86_THREAD_STATE64_COUNT || new_stateCnt.pointee < x86_THREAD_STATE64_COUNT {
   59|      0|			return NSNumber(value: KERN_INVALID_ARGUMENT)
   60|      0|		}
   61|      0|		
   62|      0|		// Read the old thread state
   63|      0|		var state = old_state.withMemoryRebound(to: x86_thread_state64_t.self, capacity: 1) { return $0.pointee }
   64|      0|		
   65|      0|		// 1. Decrement the stack pointer
   66|      0|		state.__rsp -= __uint64_t(MemoryLayout<Int>.size)
   67|      0|		
   68|      0|		// 2. Save the old Instruction Pointer to the stack.
   69|      0|		if let pointer = UnsafeMutablePointer<__uint64_t>(bitPattern: UInt(state.__rsp)) {
   70|      0|			pointer.pointee = state.__rip
   71|      0|		} else {
   72|      0|			return NSNumber(value: KERN_INVALID_ARGUMENT)
   73|      0|		}
   74|      0|		
   75|      0|		// 3. Set the Instruction Pointer to the new function's address
   76|      0|		var f: @convention(c) () -> Void = raiseBadInstructionException
   77|      0|		withUnsafePointer(to: &f) {
   78|      0|			state.__rip = $0.withMemoryRebound(to: __uint64_t.self, capacity: 1) { return $0.pointee }
   79|      0|		}
   80|      0|		
   81|      0|		// Write the new thread state
   82|      0|		new_state.withMemoryRebound(to: x86_thread_state64_t.self, capacity: 1) { $0.pointee = state }
   83|      0|		new_stateCnt.pointee = x86_THREAD_STATE64_COUNT
   84|      0|		
   85|      0|		return NSNumber(value: KERN_SUCCESS)
   86|      0|	}
   87|       |}
   88|       |
   89|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Carthage/Checkouts/CwlPreconditionTesting/Sources/CwlPreconditionTesting/CwlCatchBadInstruction.swift:
    1|       |//
    2|       |//  CwlCatchBadInstruction.swift
    3|       |//  CwlPreconditionTesting
    4|       |//
    5|       |//  Created by Matt Gallagher on 2016/01/10.
    6|       |//  Copyright © 2016 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
    7|       |//
    8|       |//  Permission to use, copy, modify, and/or distribute this software for any
    9|       |//  purpose with or without fee is hereby granted, provided that the above
   10|       |//  copyright notice and this permission notice appear in all copies.
   11|       |//
   12|       |//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   13|       |//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   14|       |//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
   15|       |//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   16|       |//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   17|       |//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
   18|       |//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   19|       |//
   20|       |
   21|       |#if (os(macOS) || os(iOS)) && arch(x86_64)
   22|       |
   23|       |import Foundation
   24|       |import Swift
   25|       |
   26|       |#if SWIFT_PACKAGE
   27|       |	import CwlMachBadInstructionHandler
   28|       |#endif
   29|       |
   30|       |private enum PthreadError: Error { case code(Int32) }
   31|       |private enum MachExcServer: Error { case code(kern_return_t) }
   32|       |
   33|       |/// A quick function for converting Mach error results into Swift errors
   34|      0|private func kernCheck(_ f: () -> Int32) throws {
   35|      0|	let r = f()
   36|      0|	guard r == KERN_SUCCESS else {
   37|      0|		throw NSError(domain: NSMachErrorDomain, code: Int(r), userInfo: nil)
   38|      0|	}
   39|      0|}
   40|       |
   41|       |extension request_mach_exception_raise_t {
   42|      0|	mutating func withMsgHeaderPointer<R>(in block: (UnsafeMutablePointer<mach_msg_header_t>) -> R) -> R {
   43|      0|		return withUnsafeMutablePointer(to: &self) { p -> R in
   44|      0|			return p.withMemoryRebound(to: mach_msg_header_t.self, capacity: 1) { ptr -> R in
   45|      0|				return block(ptr)
   46|      0|			}
   47|      0|		}
   48|      0|	}
   49|       |}
   50|       |
   51|       |extension reply_mach_exception_raise_state_t {
   52|      0|	mutating func withMsgHeaderPointer<R>(in block: (UnsafeMutablePointer<mach_msg_header_t>) -> R) -> R {
   53|      0|		return withUnsafeMutablePointer(to: &self) { p -> R in
   54|      0|			return p.withMemoryRebound(to: mach_msg_header_t.self, capacity: 1) { ptr -> R in
   55|      0|				return block(ptr)
   56|      0|			}
   57|      0|		}
   58|      0|	}
   59|       |}
   60|       |
   61|       |/// A structure used to store context associated with the Mach message port
   62|       |private struct MachContext {
   63|      0|	var masks = execTypesCountTuple<exception_mask_t>()
   64|       |	var count: mach_msg_type_number_t = 0
   65|      0|	var ports = execTypesCountTuple<mach_port_t>()
   66|      0|	var behaviors = execTypesCountTuple<exception_behavior_t>()
   67|      0|	var flavors = execTypesCountTuple<thread_state_flavor_t>()
   68|       |	var currentExceptionPort: mach_port_t = 0
   69|       |	var handlerThread: pthread_t? = nil
   70|       |	
   71|      0|	static func internalMutablePointers<R>(_ m: UnsafeMutablePointer<execTypesCountTuple<exception_mask_t>>, _ c: UnsafeMutablePointer<mach_msg_type_number_t>, _ p: UnsafeMutablePointer<execTypesCountTuple<mach_port_t>>, _ b: UnsafeMutablePointer<execTypesCountTuple<exception_behavior_t>>, _ f: UnsafeMutablePointer<execTypesCountTuple<thread_state_flavor_t>>, _ block: (UnsafeMutablePointer<exception_mask_t>, UnsafeMutablePointer<mach_msg_type_number_t>,  UnsafeMutablePointer<mach_port_t>, UnsafeMutablePointer<exception_behavior_t>, UnsafeMutablePointer<thread_state_flavor_t>) -> R) -> R {
   72|      0|		return m.withMemoryRebound(to: exception_mask_t.self, capacity: 1) { masksPtr in
   73|      0|			return c.withMemoryRebound(to: mach_msg_type_number_t.self, capacity: 1) { countPtr in
   74|      0|				return p.withMemoryRebound(to: mach_port_t.self, capacity: 1) { portsPtr in
   75|      0|					return b.withMemoryRebound(to: exception_behavior_t.self, capacity: 1) { behaviorsPtr in
   76|      0|						return f.withMemoryRebound(to: thread_state_flavor_t.self, capacity: 1) { flavorsPtr in
   77|      0|							return block(masksPtr, countPtr, portsPtr, behaviorsPtr, flavorsPtr)
   78|      0|						}
   79|      0|					}
   80|      0|				}
   81|      0|			}
   82|      0|		}
   83|      0|	}
   84|       |	
   85|      0|	mutating func withUnsafeMutablePointers<R>(in block: @escaping (UnsafeMutablePointer<exception_mask_t>, UnsafeMutablePointer<mach_msg_type_number_t>, UnsafeMutablePointer<mach_port_t>, UnsafeMutablePointer<exception_behavior_t>, UnsafeMutablePointer<thread_state_flavor_t>) -> R) -> R {
   86|      0|		return MachContext.internalMutablePointers(&masks, &count, &ports, &behaviors, &flavors, block)
   87|      0|	}
   88|       |}
   89|       |
   90|       |/// A function for receiving mach messages and parsing the first with mach_exc_server (and if any others are received, throwing them away).
   91|      0|private func machMessageHandler(_ arg: UnsafeMutableRawPointer) -> UnsafeMutableRawPointer? {
   92|      0|	let context = arg.assumingMemoryBound(to: MachContext.self).pointee
   93|      0|	var request = request_mach_exception_raise_t()
   94|      0|	var reply = reply_mach_exception_raise_state_t()
   95|      0|	
   96|      0|	var handledfirstException = false
   97|      0|	repeat { do {
   98|      0|		// Request the next mach message from the port
   99|      0|		request.Head.msgh_local_port = context.currentExceptionPort
  100|      0|		request.Head.msgh_size = UInt32(MemoryLayout<request_mach_exception_raise_t>.size)
  101|      0|		let requestSize = request.Head.msgh_size
  102|      0|		try kernCheck { request.withMsgHeaderPointer { requestPtr in
  103|      0|			mach_msg(requestPtr, MACH_RCV_MSG | MACH_RCV_INTERRUPT, 0, requestSize, context.currentExceptionPort, 0, UInt32(MACH_PORT_NULL))
  104|      0|		} }
  105|      0|		
  106|      0|		// Prepare the reply structure
  107|      0|		reply.Head.msgh_bits = MACH_MSGH_BITS(MACH_MSGH_BITS_REMOTE(request.Head.msgh_bits), 0)
  108|      0|		reply.Head.msgh_local_port = UInt32(MACH_PORT_NULL)
  109|      0|		reply.Head.msgh_remote_port = request.Head.msgh_remote_port
  110|      0|		reply.Head.msgh_size = UInt32(MemoryLayout<reply_mach_exception_raise_state_t>.size)
  111|      0|        reply.NDR = mach_ndr_record()
  112|      0|
  113|      0|		if !handledfirstException {
  114|      0|			// Use the MiG generated server to invoke our handler for the request and fill in the rest of the reply structure
  115|      0|			guard request.withMsgHeaderPointer(in: { requestPtr in reply.withMsgHeaderPointer { replyPtr in
  116|      0|				mach_exc_server(requestPtr, replyPtr)
  117|      0|			} }) != 0 else { throw MachExcServer.code(reply.RetCode) }
  118|      0|			
  119|      0|			handledfirstException = true
  120|      0|		} else {
  121|      0|			// If multiple fatal errors occur, don't handle subsquent errors (let the program crash)
  122|      0|			reply.RetCode = KERN_FAILURE
  123|      0|		}
  124|      0|		
  125|      0|		// Send the reply
  126|      0|		let replySize = reply.Head.msgh_size
  127|      0|		try kernCheck { reply.withMsgHeaderPointer { replyPtr in
  128|      0|			mach_msg(replyPtr, MACH_SEND_MSG, replySize, 0, UInt32(MACH_PORT_NULL), 0, UInt32(MACH_PORT_NULL))
  129|      0|		} }
  130|      0|	} catch let error as NSError where (error.domain == NSMachErrorDomain && (error.code == Int(MACH_RCV_PORT_CHANGED) || error.code == Int(MACH_RCV_INVALID_NAME))) {
  131|      0|		// Port was already closed before we started or closed while we were listening.
  132|      0|		// This means the controlling thread shut down.
  133|      0|		return nil
  134|      0|	} catch {
  135|      0|		// Should never be reached but this is testing code, don't try to recover, just abort
  136|      0|		fatalError("Mach message error: \(error)")
  137|      0|	} } while true
  138|      0|}
  139|       |
  140|       |/// Run the provided block. If a mach "BAD_INSTRUCTION" exception is raised, catch it and return a BadInstructionException (which captures stack information about the throw site, if desired). Otherwise return nil.
  141|       |/// NOTE: This function is only intended for use in test harnesses – use in a distributed build is almost certainly a bad choice. If a "BAD_INSTRUCTION" exception is raised, the block will be exited before completion via Objective-C exception. The risks associated with an Objective-C exception apply here: most Swift/Objective-C functions are *not* exception-safe. Memory may be leaked and the program will not necessarily be left in a safe state.
  142|       |/// - parameter block: a function without parameters that will be run
  143|       |/// - returns: if an EXC_BAD_INSTRUCTION is raised during the execution of `block` then a BadInstructionException will be returned, otherwise `nil`.
  144|      0|public func catchBadInstruction(in block: @escaping () -> Void) -> BadInstructionException? {
  145|      0|	// Suppress Swift runtime's direct triggering of the debugger and exclusivity checking which crashes when we throw past it
  146|      0|	let previousExclusivity = _swift_disableExclusivityChecking
  147|      0|	let previousReporting = _swift_reportFatalErrorsToDebugger
  148|      0|	_swift_disableExclusivityChecking = true
  149|      0|	_swift_reportFatalErrorsToDebugger = false
  150|      0|	defer {
  151|      0|		_swift_reportFatalErrorsToDebugger = previousReporting
  152|      0|		_swift_disableExclusivityChecking = previousExclusivity
  153|      0|	}
  154|      0|	
  155|      0|	var context = MachContext()
  156|      0|	var result: BadInstructionException? = nil
  157|      0|	do {
  158|      0|		var handlerThread: pthread_t? = nil
  159|      0|		defer {
  160|      0|			// 8. Wait for the thread to terminate *if* we actually made it to the creation point
  161|      0|			// The mach port should be destroyed *before* calling pthread_join to avoid a deadlock.
  162|      0|			if handlerThread != nil {
  163|      0|				pthread_join(handlerThread!, nil)
  164|      0|			}
  165|      0|		}
  166|      0|		
  167|      0|		try kernCheck {
  168|      0|			// 1. Create the mach port
  169|      0|			mach_port_allocate(mach_task_self_, MACH_PORT_RIGHT_RECEIVE, &context.currentExceptionPort)
  170|      0|		}
  171|      0|		defer {
  172|      0|			// 7. Cleanup the mach port
  173|      0|			mach_port_destroy(mach_task_self_, context.currentExceptionPort)
  174|      0|		}
  175|      0|		
  176|      0|		try kernCheck {
  177|      0|			// 2. Configure the mach port
  178|      0|			mach_port_insert_right(mach_task_self_, context.currentExceptionPort, context.currentExceptionPort, MACH_MSG_TYPE_MAKE_SEND)
  179|      0|		}
  180|      0|		
  181|      0|		let currentExceptionPtr = context.currentExceptionPort
  182|      0|		try kernCheck { context.withUnsafeMutablePointers { masksPtr, countPtr, portsPtr, behaviorsPtr, flavorsPtr in
  183|      0|			// 3. Apply the mach port as the handler for this thread
  184|      0|			thread_swap_exception_ports(mach_thread_self(), EXC_MASK_BAD_INSTRUCTION, currentExceptionPtr, Int32(bitPattern: UInt32(EXCEPTION_STATE) | MACH_EXCEPTION_CODES), x86_THREAD_STATE64, masksPtr, countPtr, portsPtr, behaviorsPtr, flavorsPtr)
  185|      0|		} }
  186|      0|		
  187|      0|		defer { context.withUnsafeMutablePointers { masksPtr, countPtr, portsPtr, behaviorsPtr, flavorsPtr in
  188|      0|			// 6. Unapply the mach port
  189|      0|			_ = thread_swap_exception_ports(mach_thread_self(), EXC_MASK_BAD_INSTRUCTION, 0, EXCEPTION_DEFAULT, THREAD_STATE_NONE, masksPtr, countPtr, portsPtr, behaviorsPtr, flavorsPtr)
  190|      0|		} }
  191|      0|		
  192|      0|		try withUnsafeMutablePointer(to: &context) { c throws in
  193|      0|			// 4. Create the thread
  194|      0|			let e = pthread_create(&handlerThread, nil, machMessageHandler, c)
  195|      0|			guard e == 0 else { throw PthreadError.code(e) }
  196|      0|			
  197|      0|			// 5. Run the block
  198|      0|			result = BadInstructionException.catchException(in: block)
  199|      0|		}
  200|      0|	} catch {
  201|      0|		// Should never be reached but this is testing code, don't try to recover, just abort
  202|      0|		fatalError("Mach port error: \(error)")
  203|      0|	}
  204|      0|
  205|      0|	return result
  206|      0|}
  207|       |	
  208|       |#endif
  209|       |

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Carthage/Checkouts/CwlPreconditionTesting/Sources/CwlPreconditionTesting/CwlDarwinDefinitions.swift:
    1|       |//
    2|       |//  CwlDarwinDefinitions.swift
    3|       |//  CwlPreconditionTesting
    4|       |//
    5|       |//  Created by Matt Gallagher on 2016/01/10.
    6|       |//  Copyright © 2016 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
    7|       |//
    8|       |//  Permission to use, copy, modify, and/or distribute this software for any
    9|       |//  purpose with or without fee is hereby granted, provided that the above
   10|       |//  copyright notice and this permission notice appear in all copies.
   11|       |//
   12|       |//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   13|       |//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   14|       |//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
   15|       |//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   16|       |//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   17|       |//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
   18|       |//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   19|       |//
   20|       |
   21|       |#if (os(macOS) || os(iOS)) && arch(x86_64)
   22|       |
   23|       |import Darwin
   24|       |
   25|       |// From /usr/include/mach/message.h
   26|       |// #define MACH_MSG_TYPE_MAKE_SEND		20	/* Must hold receive right */
   27|       |// #define	MACH_MSGH_BITS_REMOTE(bits)				\
   28|       |// 		((bits) & MACH_MSGH_BITS_REMOTE_MASK)
   29|       |// #define MACH_MSGH_BITS(remote, local)  /* legacy */		\
   30|       |// 		((remote) | ((local) << 8))
   31|       |public let MACH_MSG_TYPE_MAKE_SEND: UInt32 = 20
   32|      0|public func MACH_MSGH_BITS_REMOTE(_ bits: UInt32) -> UInt32 { return bits & UInt32(MACH_MSGH_BITS_REMOTE_MASK) }
   33|      0|public func MACH_MSGH_BITS(_ remote: UInt32, _ local: UInt32) -> UInt32 { return ((remote) | ((local) << 8)) }
   34|       |
   35|       |// From /usr/include/mach/exception_types.h
   36|       |// #define EXC_BAD_INSTRUCTION	2	/* Instruction failed */
   37|       |// #define EXC_MASK_BAD_INSTRUCTION	(1 << EXC_BAD_INSTRUCTION)
   38|       |public let EXC_BAD_INSTRUCTION: UInt32 = 2
   39|       |public let EXC_MASK_BAD_INSTRUCTION: UInt32 = 1 << EXC_BAD_INSTRUCTION
   40|       |
   41|       |// From /usr/include/mach/i386/thread_status.h
   42|       |// #define x86_THREAD_STATE64_COUNT	((mach_msg_type_number_t) \
   43|       |//		( sizeof (x86_thread_state64_t) / sizeof (int) ))
   44|       |public let x86_THREAD_STATE64_COUNT = UInt32(MemoryLayout<x86_thread_state64_t>.size / MemoryLayout<Int32>.size)
   45|       |
   46|       |public let EXC_TYPES_COUNT = 14
   47|       |public struct execTypesCountTuple<T: ExpressibleByIntegerLiteral> {
   48|       |	// From /usr/include/mach/i386/exception.h
   49|       |	// #define EXC_TYPES_COUNT 14 /* incl. illegal exception 0 */
   50|      0|	public var value: (T, T, T, T, T, T, T, T, T, T, T, T, T, T) = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
   51|      0|	public init() {
   52|      0|	}
   53|       |}
   54|       |	
   55|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Adapters/AdapterProtocols.swift:
    1|       |/// Protocol for the assertion handler that Nimble uses for all expectations.
    2|       |public protocol AssertionHandler {
    3|       |    func assert(_ assertion: Bool, message: FailureMessage, location: SourceLocation)
    4|       |}
    5|       |
    6|       |/// Global backing interface for assertions that Nimble creates.
    7|       |/// Defaults to a private test handler that passes through to XCTest.
    8|       |///
    9|       |/// If XCTest is not available, you must assign your own assertion handler
   10|       |/// before using any matchers, otherwise Nimble will abort the program.
   11|       |///
   12|       |/// @see AssertionHandler
   13|      1|public var NimbleAssertionHandler: AssertionHandler = { () -> AssertionHandler in
   14|      1|    // swiftlint:disable:previous identifier_name
   15|      1|    return isXCTestAvailable() ? NimbleXCTestHandler() : NimbleXCTestUnavailableHandler()
   16|      1|}()

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Adapters/AssertionDispatcher.swift:
    1|       |/// AssertionDispatcher allows multiple AssertionHandlers to receive
    2|       |/// assertion messages.
    3|       |///
    4|       |/// @warning Does not fully dispatch if one of the handlers raises an exception.
    5|       |///          This is possible with XCTest-based assertion handlers.
    6|       |///
    7|       |public class AssertionDispatcher: AssertionHandler {
    8|       |    let handlers: [AssertionHandler]
    9|       |
   10|      0|    public init(handlers: [AssertionHandler]) {
   11|      0|        self.handlers = handlers
   12|      0|    }
   13|       |
   14|      0|    public func assert(_ assertion: Bool, message: FailureMessage, location: SourceLocation) {
   15|      0|        for handler in handlers {
   16|      0|            handler.assert(assertion, message: message, location: location)
   17|      0|        }
   18|      0|    }
   19|       |}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Adapters/AssertionRecorder.swift:
    1|       |/// A data structure that stores information about an assertion when
    2|       |/// AssertionRecorder is set as the Nimble assertion handler.
    3|       |///
    4|       |/// @see AssertionRecorder
    5|       |/// @see AssertionHandler
    6|       |public struct AssertionRecord: CustomStringConvertible {
    7|       |    /// Whether the assertion succeeded or failed
    8|       |    public let success: Bool
    9|       |    /// The failure message the assertion would display on failure.
   10|       |    public let message: FailureMessage
   11|       |    /// The source location the expectation occurred on.
   12|       |    public let location: SourceLocation
   13|       |
   14|      0|    public var description: String {
   15|      0|        return "AssertionRecord { success=\(success), message='\(message.stringValue)', location=\(location) }"
   16|      0|    }
   17|       |}
   18|       |
   19|       |/// An AssertionHandler that silently records assertions that Nimble makes.
   20|       |/// This is useful for testing failure messages for matchers.
   21|       |///
   22|       |/// @see AssertionHandler
   23|       |public class AssertionRecorder: AssertionHandler {
   24|       |    /// All the assertions that were captured by this recorder
   25|      0|    public var assertions = [AssertionRecord]()
   26|       |
   27|      0|    public init() {}
   28|       |
   29|      0|    public func assert(_ assertion: Bool, message: FailureMessage, location: SourceLocation) {
   30|      0|        assertions.append(
   31|      0|            AssertionRecord(
   32|      0|                success: assertion,
   33|      0|                message: message,
   34|      0|                location: location))
   35|      0|    }
   36|       |}
   37|       |
   38|       |extension NMBExceptionCapture {
   39|      0|    internal func tryBlockThrows(_ unsafeBlock: () throws -> Void) throws {
   40|      0|        var catchedError: Error?
   41|      0|        tryBlock {
   42|      0|            do {
   43|      0|                try unsafeBlock()
   44|      0|            } catch {
   45|      0|                catchedError = error
   46|      0|            }
   47|      0|        }
   48|      0|        if let error = catchedError {
   49|      0|            throw error
   50|      0|        }
   51|      0|    }
   52|       |}
   53|       |
   54|       |/// Allows you to temporarily replace the current Nimble assertion handler with
   55|       |/// the one provided for the scope of the closure.
   56|       |///
   57|       |/// Once the closure finishes, then the original Nimble assertion handler is restored.
   58|       |///
   59|       |/// @see AssertionHandler
   60|       |public func withAssertionHandler(_ tempAssertionHandler: AssertionHandler,
   61|       |                                 file: FileString = #file,
   62|       |                                 line: UInt = #line,
   63|      0|                                 closure: () throws -> Void) {
   64|      0|    let environment = NimbleEnvironment.activeInstance
   65|      0|    let oldRecorder = environment.assertionHandler
   66|      0|    let capturer = NMBExceptionCapture(handler: nil, finally: ({
   67|      0|        environment.assertionHandler = oldRecorder
   68|      0|    }))
   69|      0|    environment.assertionHandler = tempAssertionHandler
   70|      0|
   71|      0|    do {
   72|      0|        try capturer.tryBlockThrows {
   73|      0|            try closure()
   74|      0|        }
   75|      0|    } catch {
   76|      0|        let failureMessage = FailureMessage()
   77|      0|        failureMessage.stringValue = "unexpected error thrown: <\(error)>"
   78|      0|        let location = SourceLocation(file: file, line: line)
   79|      0|        tempAssertionHandler.assert(false, message: failureMessage, location: location)
   80|      0|    }
   81|      0|}
   82|       |
   83|       |/// Captures expectations that occur in the given closure. Note that all
   84|       |/// expectations will still go through to the default Nimble handler.
   85|       |///
   86|       |/// This can be useful if you want to gather information about expectations
   87|       |/// that occur within a closure.
   88|       |///
   89|       |/// @param silently expectations are no longer send to the default Nimble 
   90|       |///                 assertion handler when this is true. Defaults to false.
   91|       |///
   92|       |/// @see gatherFailingExpectations
   93|      0|public func gatherExpectations(silently: Bool = false, closure: () -> Void) -> [AssertionRecord] {
   94|      0|    let previousRecorder = NimbleEnvironment.activeInstance.assertionHandler
   95|      0|    let recorder = AssertionRecorder()
   96|      0|    let handlers: [AssertionHandler]
   97|      0|
   98|      0|    if silently {
   99|      0|        handlers = [recorder]
  100|      0|    } else {
  101|      0|        handlers = [recorder, previousRecorder]
  102|      0|    }
  103|      0|
  104|      0|    let dispatcher = AssertionDispatcher(handlers: handlers)
  105|      0|    withAssertionHandler(dispatcher, closure: closure)
  106|      0|    return recorder.assertions
  107|      0|}
  108|       |
  109|       |/// Captures failed expectations that occur in the given closure. Note that all
  110|       |/// expectations will still go through to the default Nimble handler.
  111|       |///
  112|       |/// This can be useful if you want to gather information about failed
  113|       |/// expectations that occur within a closure.
  114|       |///
  115|       |/// @param silently expectations are no longer send to the default Nimble
  116|       |///                 assertion handler when this is true. Defaults to false.
  117|       |///
  118|       |/// @see gatherExpectations
  119|       |/// @see raiseException source for an example use case.
  120|      0|public func gatherFailingExpectations(silently: Bool = false, closure: () -> Void) -> [AssertionRecord] {
  121|      0|    let assertions = gatherExpectations(silently: silently, closure: closure)
  122|      0|    return assertions.filter { assertion in
  123|      0|        !assertion.success
  124|      0|    }
  125|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Adapters/NMBExpectation.swift:
    1|       |#if canImport(Darwin) && !SWIFT_PACKAGE
    2|       |import class Foundation.NSObject
    3|       |import typealias Foundation.TimeInterval
    4|       |import enum Dispatch.DispatchTimeInterval
    5|       |
    6|      0|private func from(objcPredicate: NMBPredicate) -> Predicate<NSObject> {
    7|      0|    return Predicate { actualExpression in
    8|      0|        let result = objcPredicate.satisfies(({ try actualExpression.evaluate() }),
    9|      0|                                             location: actualExpression.location)
   10|      0|        return result.toSwift()
   11|      0|    }
   12|      0|}
   13|       |
   14|      0|private func from(matcher: NMBMatcher, style: ExpectationStyle) -> Predicate<NSObject> {
   15|      0|    // Almost same as `Matcher.toClosure`
   16|      0|    let closure: (Expression<NSObject>, FailureMessage) throws -> Bool = { expr, msg in
   17|      0|        switch style {
   18|      0|        case .toMatch:
   19|      0|            return matcher.matches(
   20|      0|                // swiftlint:disable:next force_try
   21|      0|                ({ try! expr.evaluate() }),
   22|      0|                failureMessage: msg,
   23|      0|                location: expr.location
   24|      0|            )
   25|      0|        case .toNotMatch:
   26|      0|            return !matcher.doesNotMatch(
   27|      0|                // swiftlint:disable:next force_try
   28|      0|                ({ try! expr.evaluate() }),
   29|      0|                failureMessage: msg,
   30|      0|                location: expr.location
   31|      0|            )
   32|      0|        }
   33|      0|    }
   34|      0|    return Predicate._fromDeprecatedClosure(closure)
   35|      0|}
   36|       |
   37|       |// Equivalent to Expectation, but for Nimble's Objective-C interface
   38|       |public class NMBExpectation: NSObject {
   39|       |    internal let _actualBlock: () -> NSObject?
   40|       |    internal var _negative: Bool
   41|       |    internal let _file: FileString
   42|       |    internal let _line: UInt
   43|      0|    internal var _timeout: DispatchTimeInterval = .seconds(1)
   44|       |
   45|      0|    @objc public init(actualBlock: @escaping () -> NSObject?, negative: Bool, file: FileString, line: UInt) {
   46|      0|        self._actualBlock = actualBlock
   47|      0|        self._negative = negative
   48|      0|        self._file = file
   49|      0|        self._line = line
   50|      0|    }
   51|       |
   52|      0|    private var expectValue: Expectation<NSObject> {
   53|      0|        return expect(file: _file, line: _line, self._actualBlock() as NSObject?)
   54|      0|    }
   55|       |
   56|      0|    @objc public var withTimeout: (TimeInterval) -> NMBExpectation {
   57|      0|        return { timeout in self._timeout = timeout.dispatchInterval
   58|      0|            return self
   59|      0|        }
   60|      0|    }
   61|       |
   62|      0|    @objc public var to: (NMBMatcher) -> NMBExpectation {
   63|      0|        return { matcher in
   64|      0|            if let pred = matcher as? NMBPredicate {
   65|      0|                self.expectValue.to(from(objcPredicate: pred))
   66|      0|            } else {
   67|      0|                self.expectValue.to(from(matcher: matcher, style: .toMatch))
   68|      0|            }
   69|      0|            return self
   70|      0|        }
   71|      0|    }
   72|       |
   73|      0|    @objc public var toWithDescription: (NMBMatcher, String) -> NMBExpectation {
   74|      0|        return { matcher, description in
   75|      0|            if let pred = matcher as? NMBPredicate {
   76|      0|                self.expectValue.to(from(objcPredicate: pred), description: description)
   77|      0|            } else {
   78|      0|                self.expectValue.to(from(matcher: matcher, style: .toMatch), description: description)
   79|      0|            }
   80|      0|            return self
   81|      0|        }
   82|      0|    }
   83|       |
   84|      0|    @objc public var toNot: (NMBMatcher) -> NMBExpectation {
   85|      0|        return { matcher in
   86|      0|            if let pred = matcher as? NMBPredicate {
   87|      0|                self.expectValue.toNot(from(objcPredicate: pred))
   88|      0|            } else {
   89|      0|                self.expectValue.toNot(from(matcher: matcher, style: .toNotMatch))
   90|      0|            }
   91|      0|            return self
   92|      0|        }
   93|      0|    }
   94|       |
   95|      0|    @objc public var toNotWithDescription: (NMBMatcher, String) -> NMBExpectation {
   96|      0|        return { matcher, description in
   97|      0|            if let pred = matcher as? NMBPredicate {
   98|      0|                self.expectValue.toNot(from(objcPredicate: pred), description: description)
   99|      0|            } else {
  100|      0|                self.expectValue.toNot(from(matcher: matcher, style: .toNotMatch), description: description)
  101|      0|            }
  102|      0|            return self
  103|      0|        }
  104|      0|    }
  105|       |
  106|      0|    @objc public var notTo: (NMBMatcher) -> NMBExpectation { return toNot }
  107|       |
  108|      0|    @objc public var notToWithDescription: (NMBMatcher, String) -> NMBExpectation { return toNotWithDescription }
  109|       |
  110|      0|    @objc public var toEventually: (NMBMatcher) -> Void {
  111|      0|        return { matcher in
  112|      0|            if let pred = matcher as? NMBPredicate {
  113|      0|                self.expectValue.toEventually(
  114|      0|                    from(objcPredicate: pred),
  115|      0|                    timeout: self._timeout,
  116|      0|                    description: nil
  117|      0|                )
  118|      0|            } else {
  119|      0|                self.expectValue.toEventually(
  120|      0|                    from(matcher: matcher, style: .toMatch),
  121|      0|                    timeout: self._timeout,
  122|      0|                    description: nil
  123|      0|                )
  124|      0|            }
  125|      0|        }
  126|      0|    }
  127|       |
  128|      0|    @objc public var toEventuallyWithDescription: (NMBMatcher, String) -> Void {
  129|      0|        return { matcher, description in
  130|      0|            if let pred = matcher as? NMBPredicate {
  131|      0|                self.expectValue.toEventually(
  132|      0|                    from(objcPredicate: pred),
  133|      0|                    timeout: self._timeout,
  134|      0|                    description: description
  135|      0|                )
  136|      0|            } else {
  137|      0|                self.expectValue.toEventually(
  138|      0|                    from(matcher: matcher, style: .toMatch),
  139|      0|                    timeout: self._timeout,
  140|      0|                    description: description
  141|      0|                )
  142|      0|            }
  143|      0|        }
  144|      0|    }
  145|       |
  146|      0|    @objc public var toEventuallyNot: (NMBMatcher) -> Void {
  147|      0|        return { matcher in
  148|      0|            if let pred = matcher as? NMBPredicate {
  149|      0|                self.expectValue.toEventuallyNot(
  150|      0|                    from(objcPredicate: pred),
  151|      0|                    timeout: self._timeout,
  152|      0|                    description: nil
  153|      0|                )
  154|      0|            } else {
  155|      0|                self.expectValue.toEventuallyNot(
  156|      0|                    from(matcher: matcher, style: .toNotMatch),
  157|      0|                    timeout: self._timeout,
  158|      0|                    description: nil
  159|      0|                )
  160|      0|            }
  161|      0|        }
  162|      0|    }
  163|       |
  164|      0|    @objc public var toEventuallyNotWithDescription: (NMBMatcher, String) -> Void {
  165|      0|        return { matcher, description in
  166|      0|            if let pred = matcher as? NMBPredicate {
  167|      0|                self.expectValue.toEventuallyNot(
  168|      0|                    from(objcPredicate: pred),
  169|      0|                    timeout: self._timeout,
  170|      0|                    description: description
  171|      0|                )
  172|      0|            } else {
  173|      0|                self.expectValue.toEventuallyNot(
  174|      0|                    from(matcher: matcher, style: .toNotMatch),
  175|      0|                    timeout: self._timeout,
  176|      0|                    description: description
  177|      0|                )
  178|      0|            }
  179|      0|        }
  180|      0|    }
  181|       |
  182|      0|    @objc public var toNotEventually: (NMBMatcher) -> Void {
  183|      0|        return toEventuallyNot
  184|      0|    }
  185|       |
  186|      0|    @objc public var toNotEventuallyWithDescription: (NMBMatcher, String) -> Void {
  187|      0|        return toEventuallyNotWithDescription
  188|      0|    }
  189|       |
  190|      0|    @objc public class func failWithMessage(_ message: String, file: FileString, line: UInt) {
  191|      0|        fail(message, location: SourceLocation(file: file, line: line))
  192|      0|    }
  193|       |}
  194|       |
  195|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Adapters/NMBObjCMatcher.swift:
    1|       |#if canImport(Darwin)
    2|       |import class Foundation.NSObject
    3|       |
    4|       |public typealias MatcherBlock = (_ actualExpression: Expression<NSObject>, _ failureMessage: FailureMessage) throws -> Bool
    5|       |public typealias FullMatcherBlock = (_ actualExpression: Expression<NSObject>, _ failureMessage: FailureMessage, _ shouldNotMatch: Bool) throws -> Bool
    6|       |
    7|       |@available(*, deprecated, message: "Use NMBPredicate instead")
    8|       |public class NMBObjCMatcher: NSObject, NMBMatcher {
    9|       |    let _match: MatcherBlock
   10|       |    let _doesNotMatch: MatcherBlock
   11|       |    let canMatchNil: Bool
   12|       |
   13|      0|    public init(canMatchNil: Bool, matcher: @escaping MatcherBlock, notMatcher: @escaping MatcherBlock) {
   14|      0|        self.canMatchNil = canMatchNil
   15|      0|        self._match = matcher
   16|      0|        self._doesNotMatch = notMatcher
   17|      0|    }
   18|       |
   19|      0|    public convenience init(matcher: @escaping MatcherBlock) {
   20|      0|        self.init(canMatchNil: true, matcher: matcher)
   21|      0|    }
   22|       |
   23|      0|    public convenience init(canMatchNil: Bool, matcher: @escaping MatcherBlock) {
   24|      0|        self.init(canMatchNil: canMatchNil, matcher: matcher, notMatcher: ({ actualExpression, failureMessage in
   25|      0|            return try !matcher(actualExpression, failureMessage)
   26|      0|        }))
   27|      0|    }
   28|       |
   29|      0|    public convenience init(matcher: @escaping FullMatcherBlock) {
   30|      0|        self.init(canMatchNil: true, matcher: matcher)
   31|      0|    }
   32|       |
   33|      0|    public convenience init(canMatchNil: Bool, matcher: @escaping FullMatcherBlock) {
   34|      0|        self.init(canMatchNil: canMatchNil, matcher: ({ actualExpression, failureMessage in
   35|      0|            return try matcher(actualExpression, failureMessage, false)
   36|      0|        }), notMatcher: ({ actualExpression, failureMessage in
   37|      0|            return try matcher(actualExpression, failureMessage, true)
   38|      0|        }))
   39|      0|    }
   40|       |
   41|      0|    private func canMatch(_ actualExpression: Expression<NSObject>, failureMessage: FailureMessage) -> Bool {
   42|      0|        do {
   43|      0|            if !canMatchNil {
   44|      0|                if try actualExpression.evaluate() == nil {
   45|      0|                    failureMessage.postfixActual = " (use beNil() to match nils)"
   46|      0|                    return false
   47|      0|                }
   48|      0|            }
   49|      0|        } catch let error {
   50|      0|            failureMessage.actualValue = "an unexpected error thrown: \(error)"
   51|      0|            return false
   52|      0|        }
   53|      0|        return true
   54|      0|    }
   55|       |
   56|      0|    public func matches(_ actualBlock: @escaping () -> NSObject?, failureMessage: FailureMessage, location: SourceLocation) -> Bool {
   57|      0|        let expr = Expression(expression: actualBlock, location: location)
   58|      0|        let result: Bool
   59|      0|        do {
   60|      0|            result = try _match(expr, failureMessage)
   61|      0|        } catch let error {
   62|      0|            failureMessage.stringValue = "unexpected error thrown: <\(error)>"
   63|      0|            return false
   64|      0|        }
   65|      0|
   66|      0|        if self.canMatch(Expression(expression: actualBlock, location: location), failureMessage: failureMessage) {
   67|      0|            return result
   68|      0|        } else {
   69|      0|            return false
   70|      0|        }
   71|      0|    }
   72|       |
   73|      0|    public func doesNotMatch(_ actualBlock: @escaping () -> NSObject?, failureMessage: FailureMessage, location: SourceLocation) -> Bool {
   74|      0|        let expr = Expression(expression: actualBlock, location: location)
   75|      0|        let result: Bool
   76|      0|        do {
   77|      0|            result = try _doesNotMatch(expr, failureMessage)
   78|      0|        } catch let error {
   79|      0|            failureMessage.stringValue = "unexpected error thrown: <\(error)>"
   80|      0|            return false
   81|      0|        }
   82|      0|
   83|      0|        if self.canMatch(Expression(expression: actualBlock, location: location), failureMessage: failureMessage) {
   84|      0|            return result
   85|      0|        } else {
   86|      0|            return false
   87|      0|        }
   88|      0|    }
   89|       |}
   90|       |
   91|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Adapters/NimbleEnvironment.swift:
    1|       |import Dispatch
    2|       |import class Foundation.NSObject
    3|       |import class Foundation.Thread
    4|       |
    5|       |/// "Global" state of Nimble is stored here. Only DSL functions should access / be aware of this
    6|       |/// class' existence
    7|       |internal class NimbleEnvironment: NSObject {
    8|       |    static var activeInstance: NimbleEnvironment {
    9|     19|        get {
   10|     19|            let env = Thread.current.threadDictionary["NimbleEnvironment"]
   11|     18|            if let env = env as? NimbleEnvironment {
   12|     18|                return env
   13|      1|            } else {
   14|      1|                let newEnv = NimbleEnvironment()
   15|      1|                self.activeInstance = newEnv
   16|      1|                return newEnv
   17|      0|            }
   18|      0|        }
   19|      1|        set {
   20|      1|            Thread.current.threadDictionary["NimbleEnvironment"] = newValue
   21|      1|        }
   22|       |    }
   23|       |
   24|       |    // swiftlint:disable:next todo
   25|       |    // TODO: eventually migrate the global to this environment value
   26|       |    var assertionHandler: AssertionHandler {
   27|     19|        get { return NimbleAssertionHandler }
   28|      0|        set { NimbleAssertionHandler = newValue }
   29|       |    }
   30|       |
   31|       |    var suppressTVOSAssertionWarning: Bool = false
   32|       |    var awaiter: Awaiter
   33|       |
   34|      1|    override init() {
   35|      1|        let timeoutQueue = DispatchQueue.global(qos: .userInitiated)
   36|      1|        awaiter = Awaiter(
   37|      1|            waitLock: AssertionWaitLock(),
   38|      1|            asyncQueue: .main,
   39|      1|            timeoutQueue: timeoutQueue
   40|      1|        )
   41|      1|
   42|      1|        super.init()
   43|      1|    }
   44|       |}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Adapters/NimbleXCTestHandler.swift:
    1|       |import Foundation
    2|       |import XCTest
    3|       |
    4|       |/// Default handler for Nimble. This assertion handler passes failures along to
    5|       |/// XCTest.
    6|       |public class NimbleXCTestHandler: AssertionHandler {
    7|     19|    public func assert(_ assertion: Bool, message: FailureMessage, location: SourceLocation) {
    8|     19|        if !assertion {
    9|      0|            recordFailure("\(message.stringValue)\n", location: location)
   10|     19|        }
   11|     19|    }
   12|       |}
   13|       |
   14|       |/// Alternative handler for Nimble. This assertion handler passes failures along
   15|       |/// to XCTest by attempting to reduce the failure message size.
   16|       |public class NimbleShortXCTestHandler: AssertionHandler {
   17|      0|    public func assert(_ assertion: Bool, message: FailureMessage, location: SourceLocation) {
   18|      0|        if !assertion {
   19|      0|            let msg: String
   20|      0|            if let actual = message.actualValue {
   21|      0|                msg = "got: \(actual) \(message.postfixActual)"
   22|      0|            } else {
   23|      0|                msg = "expected \(message.to) \(message.postfixMessage)"
   24|      0|            }
   25|      0|            recordFailure("\(msg)\n", location: location)
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |/// Fallback handler in case XCTest is unavailable. This assertion handler will abort
   31|       |/// the program if it is invoked.
   32|       |class NimbleXCTestUnavailableHandler: AssertionHandler {
   33|      0|    func assert(_ assertion: Bool, message: FailureMessage, location: SourceLocation) {
   34|      0|        fatalError("XCTest is not available and no custom assertion handler was configured. Aborting.")
   35|      0|    }
   36|       |}
   37|       |
   38|       |#if !SWIFT_PACKAGE
   39|       |/// Helper class providing access to the currently executing XCTestCase instance, if any
   40|       |@objc final internal class CurrentTestCaseTracker: NSObject, XCTestObservation {
   41|       |    @objc static let sharedInstance = CurrentTestCaseTracker()
   42|       |
   43|       |    private(set) var currentTestCase: XCTestCase?
   44|       |
   45|       |    private var stashed_swift_reportFatalErrorsToDebugger: Bool = false
   46|       |
   47|      9|    @objc func testCaseWillStart(_ testCase: XCTestCase) {
   48|      9|        #if os(macOS) || os(iOS)
   49|      9|        stashed_swift_reportFatalErrorsToDebugger = _swift_reportFatalErrorsToDebugger
   50|      9|        _swift_reportFatalErrorsToDebugger = false
   51|      9|        #endif
   52|      9|
   53|      9|        currentTestCase = testCase
   54|      9|    }
   55|       |
   56|      9|    @objc func testCaseDidFinish(_ testCase: XCTestCase) {
   57|      9|        currentTestCase = nil
   58|      9|
   59|      9|        #if os(macOS) || os(iOS)
   60|      9|        _swift_reportFatalErrorsToDebugger = stashed_swift_reportFatalErrorsToDebugger
   61|      9|        #endif
   62|      9|    }
   63|       |}
   64|       |#endif
   65|       |
   66|      1|func isXCTestAvailable() -> Bool {
   67|      1|#if canImport(Darwin)
   68|      1|    // XCTest is weakly linked and so may not be present
   69|      1|    return NSClassFromString("XCTestCase") != nil
   70|      1|#else
   71|      1|    return true
   72|      1|#endif
   73|      1|}
   74|       |
   75|      0|public func recordFailure(_ message: String, location: SourceLocation) {
   76|      0|#if SWIFT_PACKAGE
   77|      0|    XCTFail("\(message)", file: location.file, line: location.line)
   78|      0|#else
   79|      0|    if let testCase = CurrentTestCaseTracker.sharedInstance.currentTestCase {
   80|      0|        let line = Int(location.line)
   81|      0|#if swift(>=5.3)
   82|      0|        let location = XCTSourceCodeLocation(filePath: location.file, lineNumber: line)
   83|      0|        let sourceCodeContext = XCTSourceCodeContext(location: location)
   84|      0|        let issue = XCTIssue(type: .assertionFailure, compactDescription: message, sourceCodeContext: sourceCodeContext)
   85|      0|        testCase.record(issue)
   86|      0|#else
   87|      0|        testCase.recordFailure(withDescription: message, inFile: location.file, atLine: line, expected: true)
   88|      0|#endif
   89|      0|    } else {
   90|      0|        let msg = """
   91|      0|            Attempted to report a test failure to XCTest while no test case was running. The failure was:
   92|      0|            \"\(message)\"
   93|      0|            It occurred at: \(location.file):\(location.line)
   94|      0|            """
   95|      0|        NSException(name: .internalInconsistencyException, reason: msg, userInfo: nil).raise()
   96|      0|    }
   97|      0|#endif
   98|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/DSL+Wait.swift:
    1|       |import Dispatch
    2|       |import Foundation
    3|       |
    4|       |private enum ErrorResult {
    5|       |    case exception(NSException)
    6|       |    case error(Error)
    7|       |    case none
    8|       |}
    9|       |
   10|       |/// Only classes, protocols, methods, properties, and subscript declarations can be
   11|       |/// bridges to Objective-C via the @objc keyword. This class encapsulates callback-style
   12|       |/// asynchronous waiting logic so that it may be called from Objective-C and Swift.
   13|       |internal class NMBWait: NSObject {
   14|       |// About these kind of lines, `@objc` attributes are only required for Objective-C
   15|       |// support, so that should be conditional on Darwin platforms and normal Xcode builds
   16|       |// (non-SwiftPM builds).
   17|       |#if canImport(Darwin) && !SWIFT_PACKAGE
   18|       |    @objc
   19|       |    internal class func until(
   20|       |        timeout: TimeInterval,
   21|       |        file: FileString = #file,
   22|       |        line: UInt = #line,
   23|      0|        action: @escaping (@escaping () -> Void) -> Void) {
   24|      0|            // Convert TimeInterval to DispatchTimeInterval
   25|      0|            until(timeout: timeout.dispatchInterval, file: file, line: line, action: action)
   26|      0|    }
   27|       |#endif
   28|       |
   29|       |    internal class func until(
   30|       |        timeout: DispatchTimeInterval,
   31|       |        file: FileString = #file,
   32|       |        line: UInt = #line,
   33|      0|        action: @escaping (@escaping () -> Void) -> Void) {
   34|      0|            return throwableUntil(timeout: timeout, file: file, line: line) { done in
   35|      0|                action(done)
   36|      0|            }
   37|      0|    }
   38|       |
   39|       |    // Using a throwable closure makes this method not objc compatible.
   40|       |    internal class func throwableUntil(
   41|       |        timeout: DispatchTimeInterval,
   42|       |        file: FileString = #file,
   43|       |        line: UInt = #line,
   44|      0|        action: @escaping (@escaping () -> Void) throws -> Void) {
   45|      0|            let awaiter = NimbleEnvironment.activeInstance.awaiter
   46|      0|            let leeway = timeout.divided
   47|      0|            let result = awaiter.performBlock(file: file, line: line) { (done: @escaping (ErrorResult) -> Void) throws -> Void in
   48|      0|                DispatchQueue.main.async {
   49|      0|                    let capture = NMBExceptionCapture(
   50|      0|                        handler: ({ exception in
   51|      0|                            done(.exception(exception))
   52|      0|                        }),
   53|      0|                        finally: ({ })
   54|      0|                    )
   55|      0|                    capture.tryBlock {
   56|      0|                        do {
   57|      0|                            try action {
   58|      0|                                done(.none)
   59|      0|                            }
   60|      0|                        } catch let e {
   61|      0|                            done(.error(e))
   62|      0|                        }
   63|      0|                    }
   64|      0|                }
   65|      0|            }.timeout(timeout, forcefullyAbortTimeout: leeway).wait("waitUntil(...)", file: file, line: line)
   66|      0|
   67|      0|            switch result {
   68|      0|            case .incomplete: internalError("Reached .incomplete state for waitUntil(...).")
   69|      0|            case .blockedRunLoop:
   70|      0|                fail(blockedRunLoopErrorMessageFor("-waitUntil()", leeway: leeway),
   71|      0|                    file: file, line: line)
   72|      0|            case .timedOut:
   73|      0|                fail("Waited more than \(timeout.description)", file: file, line: line)
   74|      0|            case let .raisedException(exception):
   75|      0|                fail("Unexpected exception raised: \(exception)")
   76|      0|            case let .errorThrown(error):
   77|      0|                fail("Unexpected error thrown: \(error)")
   78|      0|            case .completed(.exception(let exception)):
   79|      0|                fail("Unexpected exception raised: \(exception)")
   80|      0|            case .completed(.error(let error)):
   81|      0|                fail("Unexpected error thrown: \(error)")
   82|      0|            case .completed(.none): // success
   83|      0|                break
   84|      0|            }
   85|      0|    }
   86|       |
   87|       |#if canImport(Darwin) && !SWIFT_PACKAGE
   88|       |    @objc(untilFile:line:action:)
   89|       |    internal class func until(
   90|       |        _ file: FileString = #file,
   91|       |        line: UInt = #line,
   92|      0|        action: @escaping (@escaping () -> Void) -> Void) {
   93|      0|        until(timeout: .seconds(1), file: file, line: line, action: action)
   94|      0|    }
   95|       |#else
   96|       |    internal class func until(
   97|       |        _ file: FileString = #file,
   98|       |        line: UInt = #line,
   99|       |        action: @escaping (@escaping () -> Void) -> Void) {
  100|       |        until(timeout: .seconds(1), file: file, line: line, action: action)
  101|       |    }
  102|       |#endif
  103|       |}
  104|       |
  105|      0|internal func blockedRunLoopErrorMessageFor(_ fnName: String, leeway: DispatchTimeInterval) -> String {
  106|      0|    // swiftlint:disable:next line_length
  107|      0|    return "\(fnName) timed out but was unable to run the timeout handler because the main thread is unresponsive (\(leeway.description) is allow after the wait times out). Conditions that may cause this include processing blocking IO on the main thread, calls to sleep(), deadlocks, and synchronous IPC. Nimble forcefully stopped run loop which may cause future failures in test run."
  108|      0|}
  109|       |
  110|       |/// Wait asynchronously until the done closure is called or the timeout has been reached.
  111|       |///
  112|       |/// @discussion
  113|       |/// Call the done() closure to indicate the waiting has completed.
  114|       |/// 
  115|       |/// This function manages the main run loop (`NSRunLoop.mainRunLoop()`) while this function
  116|       |/// is executing. Any attempts to touch the run loop may cause non-deterministic behavior.
  117|      0|public func waitUntil(timeout: DispatchTimeInterval = AsyncDefaults.timeout, file: FileString = #file, line: UInt = #line, action: @escaping (@escaping () -> Void) -> Void) {
  118|      0|    NMBWait.until(timeout: timeout, file: file, line: line, action: action)
  119|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/DSL.swift:
    1|       |/// Make an expectation on a given actual value. The value given is lazily evaluated.
    2|     19|public func expect<T>(file: FileString = #file, line: UInt = #line, _ expression: @autoclosure @escaping () throws -> T?) -> Expectation<T> {
    3|     19|    return Expectation(
    4|     19|        expression: Expression(
    5|     19|            expression: expression,
    6|     19|            location: SourceLocation(file: file, line: line),
    7|     19|            isClosure: true))
    8|     19|}
    9|       |
   10|       |/// Make an expectation on a given actual value. The closure is lazily invoked.
   11|      0|public func expect<T>(file: FileString = #file, line: UInt = #line, _ expression: @autoclosure () -> (() throws -> T)) -> Expectation<T> {
   12|      0|    return Expectation(
   13|      0|        expression: Expression(
   14|      0|            expression: expression(),
   15|      0|            location: SourceLocation(file: file, line: line),
   16|      0|            isClosure: true))
   17|      0|}
   18|       |
   19|       |/// Make an expectation on a given actual value. The closure is lazily invoked.
   20|      0|public func expect<T>(file: FileString = #file, line: UInt = #line, _ expression: @autoclosure () -> (() throws -> T?)) -> Expectation<T> {
   21|      0|    return Expectation(
   22|      0|        expression: Expression(
   23|      0|            expression: expression(),
   24|      0|            location: SourceLocation(file: file, line: line),
   25|      0|            isClosure: true))
   26|      0|}
   27|       |
   28|       |/// Make an expectation on a given actual value. The closure is lazily invoked.
   29|      0|public func expect(file: FileString = #file, line: UInt = #line, _ expression: @autoclosure () -> (() throws -> Void)) -> Expectation<Void> {
   30|      0|    return Expectation(
   31|      0|        expression: Expression(
   32|      0|            expression: expression(),
   33|      0|            location: SourceLocation(file: file, line: line),
   34|      0|            isClosure: true))
   35|      0|}
   36|       |
   37|       |/// Always fails the test with a message and a specified location.
   38|      0|public func fail(_ message: String, location: SourceLocation) {
   39|      0|    let handler = NimbleEnvironment.activeInstance.assertionHandler
   40|      0|    handler.assert(false, message: FailureMessage(stringValue: message), location: location)
   41|      0|}
   42|       |
   43|       |/// Always fails the test with a message.
   44|      0|public func fail(_ message: String, file: FileString = #file, line: UInt = #line) {
   45|      0|    fail(message, location: SourceLocation(file: file, line: line))
   46|      0|}
   47|       |
   48|       |/// Always fails the test.
   49|      0|public func fail(_ file: FileString = #file, line: UInt = #line) {
   50|      0|    fail("fail() always fails", file: file, line: line)
   51|      0|}
   52|       |
   53|       |/// Like Swift's precondition(), but raises NSExceptions instead of sigaborts
   54|       |internal func nimblePrecondition(
   55|       |    _ expr: @autoclosure () -> Bool,
   56|       |    _ name: @autoclosure () -> String,
   57|       |    _ message: @autoclosure () -> String,
   58|       |    file: StaticString = #file,
   59|       |    line: UInt = #line
   60|      0|) {
   61|      0|    let result = expr()
   62|      0|    if !result {
   63|      0|        _nimblePrecondition(name(), message(), file, line)
   64|      0|    }
   65|      0|}
   66|       |
   67|      0|internal func internalError(_ msg: String, file: FileString = #file, line: UInt = #line) -> Never {
   68|      0|    fatalError(
   69|      0|        """
   70|      0|        Nimble Bug Found: \(msg) at \(file):\(line).
   71|      0|        Please file a bug to Nimble: https://github.com/Quick/Nimble/issues with the code snippet that caused this error.
   72|      0|        """
   73|      0|    )
   74|      0|    // swiftlint:enable line_length
   75|      0|}
   76|       |
   77|       |#if canImport(Darwin)
   78|       |import class Foundation.NSException
   79|       |import struct Foundation.NSExceptionName
   80|       |
   81|       |private func _nimblePrecondition(
   82|       |    _ name: String,
   83|       |    _ message: String,
   84|       |    _ file: StaticString,
   85|       |    _ line: UInt
   86|      0|) {
   87|      0|    let exception = NSException(
   88|      0|        name: NSExceptionName(name),
   89|      0|        reason: message,
   90|      0|        userInfo: nil
   91|      0|    )
   92|      0|    exception.raise()
   93|      0|}
   94|       |#else
   95|       |private func _nimblePrecondition(
   96|       |    _ name: String,
   97|       |    _ message: String,
   98|       |    _ file: StaticString,
   99|       |    _ line: UInt
  100|       |) {
  101|       |    preconditionFailure("\(name) - \(message)", file: file, line: line)
  102|       |}
  103|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Expectation.swift:
    1|       |@available(*, deprecated)
    2|       |internal func expressionDoesNotMatch<T, U>(_ expression: Expression<T>, matcher: U, toNot: String, description: String?) -> (Bool, FailureMessage)
    3|      0|    where U: Matcher, U.ValueType == T {
    4|      0|    let msg = FailureMessage()
    5|      0|    msg.userDescription = description
    6|      0|    msg.to = toNot
    7|      0|    do {
    8|      0|        let pass = try matcher.doesNotMatch(expression, failureMessage: msg)
    9|      0|        if msg.actualValue == "" {
   10|      0|            msg.actualValue = "<\(stringify(try expression.evaluate()))>"
   11|      0|        }
   12|      0|        return (pass, msg)
   13|      0|    } catch let error {
   14|      0|        msg.stringValue = "unexpected error thrown: <\(error)>"
   15|      0|        return (false, msg)
   16|      0|    }
   17|      0|}
   18|       |
   19|     19|internal func execute<T>(_ expression: Expression<T>, _ style: ExpectationStyle, _ predicate: Predicate<T>, to: String, description: String?, captureExceptions: Bool = true) -> (Bool, FailureMessage) {
   20|     19|    func run() -> (Bool, FailureMessage) {
   21|     19|        let msg = FailureMessage()
   22|     19|        msg.userDescription = description
   23|     19|        msg.to = to
   24|     19|        do {
   25|     19|            let result = try predicate.satisfies(expression)
   26|     19|            result.message.update(failureMessage: msg)
   27|     19|            if msg.actualValue == "" {
   28|     19|                msg.actualValue = "<\(stringify(try expression.evaluate()))>"
   29|     19|            }
   30|     19|            return (result.toBoolean(expectation: style), msg)
   31|      0|        } catch let error {
   32|      0|            msg.stringValue = "unexpected error thrown: <\(error)>"
   33|      0|            return (false, msg)
   34|      0|        }
   35|      0|    }
   36|     19|
   37|     19|    var result: (Bool, FailureMessage) = (false, FailureMessage())
   38|     19|    if captureExceptions {
   39|      0|        let capture = NMBExceptionCapture(handler: ({ exception -> Void in
   40|      0|            let msg = FailureMessage()
   41|      0|            msg.stringValue = "unexpected exception raised: \(exception)"
   42|      0|            result = (false, msg)
   43|      0|        }), finally: nil)
   44|     19|        capture.tryBlock {
   45|     19|            result = run()
   46|     19|        }
   47|     19|    } else {
   48|      0|        result = run()
   49|     19|    }
   50|     19|
   51|     19|    return result
   52|     19|}
   53|       |
   54|       |public struct Expectation<T> {
   55|       |
   56|       |    public let expression: Expression<T>
   57|       |
   58|     19|    public init(expression: Expression<T>) {
   59|     19|        self.expression = expression
   60|     19|    }
   61|       |
   62|     19|    public func verify(_ pass: Bool, _ message: FailureMessage) {
   63|     19|        let handler = NimbleEnvironment.activeInstance.assertionHandler
   64|     19|        handler.assert(pass, message: message, location: expression.location)
   65|     19|    }
   66|       |
   67|       |    ////////////////// OLD API /////////////////////
   68|       |
   69|       |    /// DEPRECATED: Tests the actual value using a matcher to match.
   70|       |    @available(*, deprecated, message: "Use Predicate instead")
   71|       |    @discardableResult
   72|       |    public func to<U>(_ matcher: U, description: String? = nil) -> Self
   73|      0|        where U: Matcher, U.ValueType == T {
   74|      0|            let (pass, msg) = execute(
   75|      0|                expression,
   76|      0|                .toMatch,
   77|      0|                matcher.predicate,
   78|      0|                to: "to",
   79|      0|                description: description,
   80|      0|                captureExceptions: false
   81|      0|            )
   82|      0|            verify(pass, msg)
   83|      0|            return self
   84|      0|    }
   85|       |
   86|       |    /// DEPRECATED: Tests the actual value using a matcher to not match.
   87|       |    @available(*, deprecated, message: "Use Predicate instead")
   88|       |    @discardableResult
   89|       |    public func toNot<U>(_ matcher: U, description: String? = nil) -> Self
   90|      0|        where U: Matcher, U.ValueType == T {
   91|      0|        let (pass, msg) = expressionDoesNotMatch(expression, matcher: matcher, toNot: "to not", description: description)
   92|      0|        verify(pass, msg)
   93|      0|        return self
   94|      0|    }
   95|       |
   96|       |    /// DEPRECATED: Tests the actual value using a matcher to not match.
   97|       |    ///
   98|       |    /// Alias to toNot().
   99|       |    @available(*, deprecated, message: "Use Predicate instead")
  100|       |    @discardableResult
  101|       |    public func notTo<U>(_ matcher: U, description: String? = nil) -> Self
  102|      0|        where U: Matcher, U.ValueType == T {
  103|      0|        return toNot(matcher, description: description)
  104|      0|    }
  105|       |
  106|       |    ////////////////// NEW API /////////////////////
  107|       |
  108|       |    /// Tests the actual value using a matcher to match.
  109|       |    @discardableResult
  110|     19|    public func to(_ predicate: Predicate<T>, description: String? = nil) -> Self {
  111|     19|        let (pass, msg) = execute(expression, .toMatch, predicate, to: "to", description: description)
  112|     19|        verify(pass, msg)
  113|     19|        return self
  114|     19|    }
  115|       |
  116|       |    /// Tests the actual value using a matcher to not match.
  117|       |    @discardableResult
  118|      0|    public func toNot(_ predicate: Predicate<T>, description: String? = nil) -> Self {
  119|      0|        let (pass, msg) = execute(expression, .toNotMatch, predicate, to: "to not", description: description)
  120|      0|        verify(pass, msg)
  121|      0|        return self
  122|      0|    }
  123|       |
  124|       |    /// Tests the actual value using a matcher to not match.
  125|       |    ///
  126|       |    /// Alias to toNot().
  127|       |    @discardableResult
  128|      0|    public func notTo(_ predicate: Predicate<T>, description: String? = nil) -> Self {
  129|      0|        return toNot(predicate, description: description)
  130|      0|    }
  131|       |
  132|       |    // see:
  133|       |    // - `async` for extension
  134|       |    // - NMBExpectation for Objective-C interface
  135|       |}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/ExpectationMessage.swift:
    1|       |public indirect enum ExpectationMessage {
    2|       |    // --- Primary Expectations ---
    3|       |    /// includes actual value in output ("expected to <message>, got <actual>")
    4|       |    case expectedActualValueTo(/* message: */ String)
    5|       |    /// uses a custom actual value string in output ("expected to <message>, got <actual>")
    6|       |    case expectedCustomValueTo(/* message: */ String, actual: String)
    7|       |    /// excludes actual value in output ("expected to <message>")
    8|       |    case expectedTo(/* message: */ String)
    9|       |    /// allows any free-form message ("<message>")
   10|       |    case fail(/* message: */ String)
   11|       |
   12|       |    // --- Composite Expectations ---
   13|       |    // Generally, you'll want the methods, appended(message:) and appended(details:) instead.
   14|       |
   15|       |    /// Not Fully Implemented Yet.
   16|       |    case prepends(/* Prepended Message */ String, ExpectationMessage)
   17|       |
   18|       |    /// appends after an existing message ("<expectation> (use beNil() to match nils)")
   19|       |    case appends(ExpectationMessage, /* Appended Message */ String)
   20|       |
   21|       |    /// provides long-form multi-line explainations ("<expectation>\n\n<string>")
   22|       |    case details(ExpectationMessage, String)
   23|       |
   24|       |    /// Returns the smallest message after the "expected to" string that summarizes the error.
   25|       |    ///
   26|       |    /// Returns the message part from ExpectationMessage, ignoring all .appends and .details.
   27|      0|    public var expectedMessage: String {
   28|      0|        switch self {
   29|      0|        case let .fail(msg):
   30|      0|            return msg
   31|      0|        case let .expectedTo(msg):
   32|      0|            return msg
   33|      0|        case let .expectedActualValueTo(msg):
   34|      0|            return msg
   35|      0|        case let .expectedCustomValueTo(msg, _):
   36|      0|            return msg
   37|      0|        case let .prepends(_, expectation):
   38|      0|            return expectation.expectedMessage
   39|      0|        case let .appends(expectation, msg):
   40|      0|            return "\(expectation.expectedMessage)\(msg)"
   41|      0|        case let .details(expectation, _):
   42|      0|            return expectation.expectedMessage
   43|      0|        }
   44|      0|    }
   45|       |
   46|       |    /// Appends a message after the primary expectation message
   47|      0|    public func appended(message: String) -> ExpectationMessage {
   48|      0|        switch self {
   49|      0|        case .fail, .expectedTo, .expectedActualValueTo, .expectedCustomValueTo, .appends, .prepends:
   50|      0|            return .appends(self, message)
   51|      0|        case let .details(expectation, msg):
   52|      0|            return .details(expectation.appended(message: message), msg)
   53|      0|        }
   54|      0|    }
   55|       |
   56|       |    /// Appends a message hinting to use beNil() for when the actual value given was nil.
   57|      0|    public func appendedBeNilHint() -> ExpectationMessage {
   58|      0|        return appended(message: " (use beNil() to match nils)")
   59|      0|    }
   60|       |
   61|       |    /// Appends a detailed (aka - multiline) message after the primary expectation message
   62|       |    /// Detailed messages will be placed after .appended(message:) calls.
   63|      0|    public func appended(details: String) -> ExpectationMessage {
   64|      0|        return .details(self, details)
   65|      0|    }
   66|       |
   67|      0|    internal func visitLeafs(_ f: (ExpectationMessage) -> ExpectationMessage) -> ExpectationMessage {
   68|      0|        // swiftlint:disable:previous identifier_name
   69|      0|        switch self {
   70|      0|        case .fail, .expectedTo, .expectedActualValueTo, .expectedCustomValueTo:
   71|      0|            return f(self)
   72|      0|        case let .prepends(msg, expectation):
   73|      0|            return .prepends(msg, expectation.visitLeafs(f))
   74|      0|        case let .appends(expectation, msg):
   75|      0|            return .appends(expectation.visitLeafs(f), msg)
   76|      0|        case let .details(expectation, msg):
   77|      0|            return .details(expectation.visitLeafs(f), msg)
   78|      0|        }
   79|      0|    }
   80|       |
   81|       |    /// Replaces a primary expectation with one returned by f. Preserves all composite expectations
   82|       |    /// that were built upon it (aka - all appended(message:) and appended(details:).
   83|      0|    public func replacedExpectation(_ f: @escaping (ExpectationMessage) -> ExpectationMessage) -> ExpectationMessage {
   84|      0|        // swiftlint:disable:previous identifier_name
   85|      0|        func walk(_ msg: ExpectationMessage) -> ExpectationMessage {
   86|      0|            switch msg {
   87|      0|            case .fail, .expectedTo, .expectedActualValueTo, .expectedCustomValueTo:
   88|      0|                return f(msg)
   89|      0|            default:
   90|      0|                return msg
   91|      0|            }
   92|      0|        }
   93|      0|        return visitLeafs(walk)
   94|      0|    }
   95|       |
   96|       |    /// Wraps a primary expectation with text before and after it.
   97|       |    /// Alias to prepended(message: before).appended(message: after)
   98|      0|    public func wrappedExpectation(before: String, after: String) -> ExpectationMessage {
   99|      0|        return prepended(expectation: before).appended(message: after)
  100|      0|    }
  101|       |
  102|       |    /// Prepends a message by modifying the primary expectation
  103|      0|    public func prepended(expectation message: String) -> ExpectationMessage {
  104|      0|        func walk(_ msg: ExpectationMessage) -> ExpectationMessage {
  105|      0|            switch msg {
  106|      0|            case let .expectedTo(msg):
  107|      0|                return .expectedTo(message + msg)
  108|      0|            case let .expectedActualValueTo(msg):
  109|      0|                return .expectedActualValueTo(message + msg)
  110|      0|            case let .expectedCustomValueTo(msg, actual):
  111|      0|                return .expectedCustomValueTo(message + msg, actual: actual)
  112|      0|            default:
  113|      0|                return msg.visitLeafs(walk)
  114|      0|            }
  115|      0|        }
  116|      0|        return visitLeafs(walk)
  117|      0|    }
  118|       |
  119|       |    // swiftlint:disable:next todo
  120|       |    // TODO: test & verify correct behavior
  121|      0|    internal func prepended(message: String) -> ExpectationMessage {
  122|      0|        return .prepends(message, self)
  123|      0|    }
  124|       |
  125|       |    /// Converts the tree of ExpectationMessages into a final built string.
  126|      0|    public func toString(actual: String, expected: String = "expected", to: String = "to") -> String {
  127|      0|        switch self {
  128|      0|        case let .fail(msg):
  129|      0|            return msg
  130|      0|        case let .expectedTo(msg):
  131|      0|            return "\(expected) \(to) \(msg)"
  132|      0|        case let .expectedActualValueTo(msg):
  133|      0|            return "\(expected) \(to) \(msg), got \(actual)"
  134|      0|        case let .expectedCustomValueTo(msg, actual):
  135|      0|            return "\(expected) \(to) \(msg), got \(actual)"
  136|      0|        case let .prepends(msg, expectation):
  137|      0|            return "\(msg)\(expectation.toString(actual: actual, expected: expected, to: to))"
  138|      0|        case let .appends(expectation, msg):
  139|      0|            return "\(expectation.toString(actual: actual, expected: expected, to: to))\(msg)"
  140|      0|        case let .details(expectation, msg):
  141|      0|            return "\(expectation.toString(actual: actual, expected: expected, to: to))\n\n\(msg)"
  142|      0|        }
  143|      0|    }
  144|       |
  145|       |    // Backwards compatibility: converts ExpectationMessage tree to FailureMessage
  146|     19|    internal func update(failureMessage: FailureMessage) {
  147|     19|        switch self {
  148|      0|        case let .fail(msg) where !msg.isEmpty:
  149|      0|            failureMessage.stringValue = msg
  150|      0|        case .fail:
  151|      0|            break
  152|      0|        case let .expectedTo(msg):
  153|      0|            failureMessage.actualValue = nil
  154|      0|            failureMessage.postfixMessage = msg
  155|     19|        case let .expectedActualValueTo(msg):
  156|     19|            failureMessage.postfixMessage = msg
  157|      0|        case let .expectedCustomValueTo(msg, actual):
  158|      0|            failureMessage.postfixMessage = msg
  159|      0|            failureMessage.actualValue = actual
  160|      0|        case let .prepends(msg, expectation):
  161|      0|            expectation.update(failureMessage: failureMessage)
  162|      0|            if let desc = failureMessage.userDescription {
  163|      0|                failureMessage.userDescription = "\(msg)\(desc)"
  164|      0|            } else {
  165|      0|                failureMessage.userDescription = msg
  166|     19|            }
  167|      0|        case let .appends(expectation, msg):
  168|      0|            expectation.update(failureMessage: failureMessage)
  169|      0|            failureMessage.appendMessage(msg)
  170|      0|        case let .details(expectation, msg):
  171|      0|            expectation.update(failureMessage: failureMessage)
  172|      0|            failureMessage.appendDetails(msg)
  173|     19|        }
  174|     19|    }
  175|       |}
  176|       |
  177|       |extension FailureMessage {
  178|      0|    internal func toExpectationMessage() -> ExpectationMessage {
  179|      0|        let defaultMessage = FailureMessage()
  180|      0|        if expected != defaultMessage.expected || _stringValueOverride != nil {
  181|      0|            return .fail(stringValue)
  182|      0|        }
  183|      0|
  184|      0|        var message: ExpectationMessage = .fail(userDescription ?? "")
  185|      0|        if actualValue != "" && actualValue != nil {
  186|      0|            message = .expectedCustomValueTo(postfixMessage, actual: actualValue ?? "")
  187|      0|        } else if postfixMessage != defaultMessage.postfixMessage {
  188|      0|            if actualValue == nil {
  189|      0|                message = .expectedTo(postfixMessage)
  190|      0|            } else {
  191|      0|                message = .expectedActualValueTo(postfixMessage)
  192|      0|            }
  193|      0|        }
  194|      0|        if postfixActual != defaultMessage.postfixActual {
  195|      0|            message = .appends(message, postfixActual)
  196|      0|        }
  197|      0|        if let extended = extendedMessage {
  198|      0|            message = .details(message, extended)
  199|      0|        }
  200|      0|        return message
  201|      0|    }
  202|       |}
  203|       |
  204|       |#if canImport(Darwin)
  205|       |import class Foundation.NSObject
  206|       |
  207|       |public class NMBExpectationMessage: NSObject {
  208|       |    private let msg: ExpectationMessage
  209|       |
  210|      0|    internal init(swift msg: ExpectationMessage) {
  211|      0|        self.msg = msg
  212|      0|    }
  213|       |
  214|      0|    public init(expectedTo message: String) {
  215|      0|        self.msg = .expectedTo(message)
  216|      0|    }
  217|      0|    public init(expectedActualValueTo message: String) {
  218|      0|        self.msg = .expectedActualValueTo(message)
  219|      0|    }
  220|       |
  221|      0|    public init(expectedActualValueTo message: String, customActualValue actual: String) {
  222|      0|        self.msg = .expectedCustomValueTo(message, actual: actual)
  223|      0|    }
  224|       |
  225|      0|    public init(fail message: String) {
  226|      0|        self.msg = .fail(message)
  227|      0|    }
  228|       |
  229|      0|    public init(prepend message: String, child: NMBExpectationMessage) {
  230|      0|        self.msg = .prepends(message, child.msg)
  231|      0|    }
  232|       |
  233|      0|    public init(appendedMessage message: String, child: NMBExpectationMessage) {
  234|      0|        self.msg = .appends(child.msg, message)
  235|      0|    }
  236|       |
  237|      0|    public init(prependedMessage message: String, child: NMBExpectationMessage) {
  238|      0|        self.msg = .prepends(message, child.msg)
  239|      0|    }
  240|       |
  241|      0|    public init(details message: String, child: NMBExpectationMessage) {
  242|      0|        self.msg = .details(child.msg, message)
  243|      0|    }
  244|       |
  245|      0|    public func appendedBeNilHint() -> NMBExpectationMessage {
  246|      0|        return NMBExpectationMessage(swift: msg.appendedBeNilHint())
  247|      0|    }
  248|       |
  249|      0|    public func toSwift() -> ExpectationMessage { return self.msg }
  250|       |}
  251|       |
  252|       |extension ExpectationMessage {
  253|      0|    func toObjectiveC() -> NMBExpectationMessage {
  254|      0|        return NMBExpectationMessage(swift: self)
  255|      0|    }
  256|       |}
  257|       |
  258|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Expression.swift:
    1|       |// Memoizes the given closure, only calling the passed
    2|       |// closure once; even if repeat calls to the returned closure
    3|     19|internal func memoizedClosure<T>(_ closure: @escaping () throws -> T) -> (Bool) throws -> T {
    4|     19|    var cache: T?
    5|     58|    return { withoutCaching in
    6|     58|        if withoutCaching || cache == nil {
    7|     19|            cache = try closure()
    8|     58|        }
    9|     58|        return cache!
   10|     58|    }
   11|     19|}
   12|       |
   13|       |/// Expression represents the closure of the value inside expect(...).
   14|       |/// Expressions are memoized by default. This makes them safe to call
   15|       |/// evaluate() multiple times without causing a re-evaluation of the underlying
   16|       |/// closure.
   17|       |///
   18|       |/// @warning Since the closure can be any code, Objective-C code may choose
   19|       |///          to raise an exception. Currently, Expression does not memoize
   20|       |///          exception raising.
   21|       |///
   22|       |/// This provides a common consumable API for matchers to utilize to allow
   23|       |/// Nimble to change internals to how the captured closure is managed.
   24|       |public struct Expression<T> {
   25|       |    internal let _expression: (Bool) throws -> T?
   26|       |    internal let _withoutCaching: Bool
   27|       |    public let location: SourceLocation
   28|       |    public let isClosure: Bool
   29|       |
   30|       |    /// Creates a new expression struct. Normally, expect(...) will manage this
   31|       |    /// creation process. The expression is memoized.
   32|       |    ///
   33|       |    /// @param expression The closure that produces a given value.
   34|       |    /// @param location The source location that this closure originates from.
   35|       |    /// @param isClosure A bool indicating if the captured expression is a
   36|       |    ///                  closure or internally produced closure. Some matchers
   37|       |    ///                  may require closures. For example, toEventually()
   38|       |    ///                  requires an explicit closure. This gives Nimble
   39|       |    ///                  flexibility if @autoclosure behavior changes between
   40|       |    ///                  Swift versions. Nimble internals always sets this true.
   41|     19|    public init(expression: @escaping () throws -> T?, location: SourceLocation, isClosure: Bool = true) {
   42|     19|        self._expression = memoizedClosure(expression)
   43|     19|        self.location = location
   44|     19|        self._withoutCaching = false
   45|     19|        self.isClosure = isClosure
   46|     19|    }
   47|       |
   48|       |    /// Creates a new expression struct. Normally, expect(...) will manage this
   49|       |    /// creation process.
   50|       |    ///
   51|       |    /// @param expression The closure that produces a given value.
   52|       |    /// @param location The source location that this closure originates from.
   53|       |    /// @param withoutCaching Indicates if the struct should memoize the given
   54|       |    ///                       closure's result. Subsequent evaluate() calls will
   55|       |    ///                       not call the given closure if this is true.
   56|       |    /// @param isClosure A bool indicating if the captured expression is a
   57|       |    ///                  closure or internally produced closure. Some matchers
   58|       |    ///                  may require closures. For example, toEventually()
   59|       |    ///                  requires an explicit closure. This gives Nimble
   60|       |    ///                  flexibility if @autoclosure behavior changes between
   61|       |    ///                  Swift versions. Nimble internals always sets this true.
   62|      0|    public init(memoizedExpression: @escaping (Bool) throws -> T?, location: SourceLocation, withoutCaching: Bool, isClosure: Bool = true) {
   63|      0|        self._expression = memoizedExpression
   64|      0|        self.location = location
   65|      0|        self._withoutCaching = withoutCaching
   66|      0|        self.isClosure = isClosure
   67|      0|    }
   68|       |
   69|       |    /// Returns a new Expression from the given expression. Identical to a map()
   70|       |    /// on this type. This should be used only to typecast the Expression's
   71|       |    /// closure value.
   72|       |    ///
   73|       |    /// The returned expression will preserve location and isClosure.
   74|       |    ///
   75|       |    /// @param block The block that can cast the current Expression value to a
   76|       |    ///              new type.
   77|      0|    public func cast<U>(_ block: @escaping (T?) throws -> U?) -> Expression<U> {
   78|      0|        return Expression<U>(
   79|      0|            expression: ({ try block(self.evaluate()) }),
   80|      0|            location: self.location,
   81|      0|            isClosure: self.isClosure
   82|      0|        )
   83|      0|    }
   84|       |
   85|     58|    public func evaluate() throws -> T? {
   86|     58|        return try self._expression(_withoutCaching)
   87|     58|    }
   88|       |
   89|      0|    public func withoutCaching() -> Expression<T> {
   90|      0|        return Expression(
   91|      0|            memoizedExpression: self._expression,
   92|      0|            location: location,
   93|      0|            withoutCaching: true,
   94|      0|            isClosure: isClosure
   95|      0|        )
   96|      0|    }
   97|       |}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/FailureMessage.swift:
    1|       |import Foundation
    2|       |
    3|       |/// Encapsulates the failure message that matchers can report to the end user.
    4|       |///
    5|       |/// This is shared state between Nimble and matchers that mutate this value.
    6|       |public class FailureMessage: NSObject {
    7|       |    public var expected: String = "expected"
    8|     38|    public var actualValue: String? = "" // empty string -> use default; nil -> exclude
    9|       |    public var to: String = "to"
   10|       |    public var postfixMessage: String = "match"
   11|       |    public var postfixActual: String = ""
   12|       |    /// An optional message that will be appended as a new line and provides additional details
   13|       |    /// about the failure. This message will only be visible in the issue navigator / in logs but
   14|       |    /// not directly in the source editor since only a single line is presented there.
   15|       |    public var extendedMessage: String?
   16|       |    public var userDescription: String?
   17|       |
   18|       |    public var stringValue: String {
   19|      0|        get {
   20|      0|            if let value = _stringValueOverride {
   21|      0|                return value
   22|      0|            } else {
   23|      0|                return computeStringValue()
   24|      0|            }
   25|      0|        }
   26|      0|        set {
   27|      0|            _stringValueOverride = newValue
   28|      0|        }
   29|       |    }
   30|       |
   31|       |    internal var _stringValueOverride: String?
   32|      0|    internal var hasOverriddenStringValue: Bool {
   33|      0|        return _stringValueOverride != nil
   34|      0|    }
   35|       |
   36|     38|    public override init() {
   37|     38|    }
   38|       |
   39|      0|    public init(stringValue: String) {
   40|      0|        _stringValueOverride = stringValue
   41|      0|    }
   42|       |
   43|      0|    internal func stripNewlines(_ str: String) -> String {
   44|      0|        let whitespaces = CharacterSet.whitespacesAndNewlines
   45|      0|        return str
   46|      0|            .components(separatedBy: "\n")
   47|      0|            .map { line in line.trimmingCharacters(in: whitespaces) }
   48|      0|            .joined(separator: "")
   49|      0|    }
   50|       |
   51|      0|    internal func computeStringValue() -> String {
   52|      0|        var value = "\(expected) \(to) \(postfixMessage)"
   53|      0|        if let actualValue = actualValue {
   54|      0|            value = "\(expected) \(to) \(postfixMessage), got \(actualValue)\(postfixActual)"
   55|      0|        }
   56|      0|        value = stripNewlines(value)
   57|      0|
   58|      0|        if let extendedMessage = extendedMessage {
   59|      0|            value += "\n\(stripNewlines(extendedMessage))"
   60|      0|        }
   61|      0|
   62|      0|        if let userDescription = userDescription {
   63|      0|            return "\(userDescription)\n\(value)"
   64|      0|        }
   65|      0|
   66|      0|        return value
   67|      0|    }
   68|       |
   69|      0|    internal func appendMessage(_ msg: String) {
   70|      0|        if hasOverriddenStringValue {
   71|      0|            stringValue += "\(msg)"
   72|      0|        } else if actualValue != nil {
   73|      0|            postfixActual += msg
   74|      0|        } else {
   75|      0|            postfixMessage += msg
   76|      0|        }
   77|      0|    }
   78|       |
   79|      0|    internal func appendDetails(_ msg: String) {
   80|      0|        if hasOverriddenStringValue {
   81|      0|            if let desc = userDescription {
   82|      0|                stringValue = "\(desc)\n\(stringValue)"
   83|      0|            }
   84|      0|            stringValue += "\n\(msg)"
   85|      0|        } else {
   86|      0|            if let desc = userDescription {
   87|      0|                userDescription = desc
   88|      0|            }
   89|      0|            extendedMessage = msg
   90|      0|        }
   91|      0|    }
   92|       |}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/AllPass.swift:
    1|       |public func allPass<S: Sequence>(
    2|       |    _ passFunc: @escaping (S.Element?) throws -> Bool
    3|      0|) -> Predicate<S> {
    4|      0|    let matcher = Predicate.simpleNilable("pass a condition") { actualExpression in
    5|      0|        return PredicateStatus(bool: try passFunc(try actualExpression.evaluate()))
    6|      0|    }
    7|      0|    return createPredicate(matcher)
    8|      0|}
    9|       |
   10|       |public func allPass<S: Sequence>(
   11|       |    _ passName: String,
   12|       |    _ passFunc: @escaping (S.Element?) throws -> Bool
   13|      0|) -> Predicate<S> {
   14|      0|    let matcher = Predicate.simpleNilable(passName) { actualExpression in
   15|      0|        return PredicateStatus(bool: try passFunc(try actualExpression.evaluate()))
   16|      0|    }
   17|      0|    return createPredicate(matcher)
   18|      0|}
   19|       |
   20|       |@available(*, deprecated, message: "Use Predicate instead")
   21|      0|public func allPass<S: Sequence, M: Matcher>(_ elementMatcher: M) -> Predicate<S> where S.Element == M.ValueType {
   22|      0|    return createPredicate(elementMatcher.predicate)
   23|      0|}
   24|       |
   25|      0|public func allPass<S: Sequence>(_ elementPredicate: Predicate<S.Element>) -> Predicate<S> {
   26|      0|    return createPredicate(elementPredicate)
   27|      0|}
   28|       |
   29|      0|private func createPredicate<S: Sequence>(_ elementMatcher: Predicate<S.Element>) -> Predicate<S> {
   30|      0|    return Predicate { actualExpression in
   31|      0|        guard let actualValue = try actualExpression.evaluate() else {
   32|      0|            return PredicateResult(
   33|      0|                status: .fail,
   34|      0|                message: .appends(.expectedTo("all pass"), " (use beNil() to match nils)")
   35|      0|            )
   36|      0|        }
   37|      0|
   38|      0|        var failure: ExpectationMessage = .expectedTo("all pass")
   39|      0|        for currentElement in actualValue {
   40|      0|            let exp = Expression(
   41|      0|                expression: {currentElement}, location: actualExpression.location)
   42|      0|            let predicateResult = try elementMatcher.satisfies(exp)
   43|      0|            if predicateResult.status == .matches {
   44|      0|                failure = predicateResult.message.prepended(expectation: "all ")
   45|      0|            } else {
   46|      0|                failure = predicateResult.message
   47|      0|                    .replacedExpectation({ .expectedTo($0.expectedMessage) })
   48|      0|                    .wrappedExpectation(
   49|      0|                        before: "all ",
   50|      0|                        after: ", but failed first at element <\(stringify(currentElement))>"
   51|      0|                            + " in <\(stringify(actualValue))>"
   52|      0|                )
   53|      0|                return PredicateResult(status: .doesNotMatch, message: failure)
   54|      0|            }
   55|      0|        }
   56|      0|        failure = failure.replacedExpectation({ expectation in
   57|      0|            return .expectedTo(expectation.expectedMessage)
   58|      0|        })
   59|      0|        return PredicateResult(status: .matches, message: failure)
   60|      0|    }
   61|      0|}
   62|       |
   63|       |#if canImport(Darwin)
   64|       |import class Foundation.NSObject
   65|       |import struct Foundation.NSFastEnumerationIterator
   66|       |import protocol Foundation.NSFastEnumeration
   67|       |
   68|       |extension NMBPredicate {
   69|      0|    @objc public class func allPassMatcher(_ matcher: NMBMatcher) -> NMBPredicate {
   70|      0|        return NMBPredicate { actualExpression in
   71|      0|            let location = actualExpression.location
   72|      0|            let actualValue = try actualExpression.evaluate()
   73|      0|            var nsObjects = [NSObject]()
   74|      0|
   75|      0|            var collectionIsUsable = true
   76|      0|            if let value = actualValue as? NSFastEnumeration {
   77|      0|                var generator = NSFastEnumerationIterator(value)
   78|      0|                while let obj = generator.next() {
   79|      0|                    if let nsObject = obj as? NSObject {
   80|      0|                        nsObjects.append(nsObject)
   81|      0|                    } else {
   82|      0|                        collectionIsUsable = false
   83|      0|                        break
   84|      0|                    }
   85|      0|                }
   86|      0|            } else {
   87|      0|                collectionIsUsable = false
   88|      0|            }
   89|      0|
   90|      0|            if !collectionIsUsable {
   91|      0|                return NMBPredicateResult(
   92|      0|                    status: NMBPredicateStatus.fail,
   93|      0|                    message: NMBExpectationMessage(
   94|      0|                        // swiftlint:disable:next line_length
   95|      0|                        fail: "allPass can only be used with types which implement NSFastEnumeration (NSArray, NSSet, ...), and whose elements subclass NSObject, got <\(actualValue?.description ?? "nil")>"
   96|      0|                    )
   97|      0|                )
   98|      0|            }
   99|      0|
  100|      0|            let expr = Expression(expression: ({ nsObjects }), location: location)
  101|      0|            let pred: Predicate<[NSObject]> = createPredicate(Predicate { expr in
  102|      0|                if let predicate = matcher as? NMBPredicate {
  103|      0|                    return predicate.satisfies(({ try expr.evaluate() }), location: expr.location).toSwift()
  104|      0|                } else {
  105|      0|                    let failureMessage = FailureMessage()
  106|      0|                    let result = matcher.matches(
  107|      0|                        // swiftlint:disable:next force_try
  108|      0|                        ({ try! expr.evaluate() }),
  109|      0|                        failureMessage: failureMessage,
  110|      0|                        location: expr.location
  111|      0|                    )
  112|      0|                    let expectationMsg = failureMessage.toExpectationMessage()
  113|      0|                    return PredicateResult(
  114|      0|                        bool: result,
  115|      0|                        message: expectationMsg
  116|      0|                    )
  117|      0|                }
  118|      0|            })
  119|      0|            return try pred.satisfies(expr).toObjectiveC()
  120|      0|        }
  121|      0|    }
  122|       |}
  123|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/Async.swift:
    1|       |import Foundation
    2|       |import Dispatch
    3|       |
    4|       |/// If you are running on a slower machine, it could be useful to increase the default timeout value
    5|       |/// or slow down poll interval. Default timeout interval is 1, and poll interval is 0.01.
    6|       |public struct AsyncDefaults {
    7|       |    public static var timeout: DispatchTimeInterval = .seconds(1)
    8|       |    public static var pollInterval: DispatchTimeInterval = .milliseconds(10)
    9|       |}
   10|       |
   11|       |extension AsyncDefaults {
   12|       |    @available(*, unavailable, renamed: "timeout")
   13|       |    public static var Timeout: TimeInterval = 1
   14|       |    @available(*, unavailable, renamed: "pollInterval")
   15|       |    public static var PollInterval: TimeInterval = 0.01
   16|       |}
   17|       |
   18|      0|private func async<T>(style: ExpectationStyle, predicate: Predicate<T>, timeout: DispatchTimeInterval, poll: DispatchTimeInterval, fnName: String) -> Predicate<T> {
   19|      0|    return Predicate { actualExpression in
   20|      0|        let uncachedExpression = actualExpression.withoutCaching()
   21|      0|        let fnName = "expect(...).\(fnName)(...)"
   22|      0|        var lastPredicateResult: PredicateResult?
   23|      0|        let result = pollBlock(
   24|      0|            pollInterval: poll,
   25|      0|            timeoutInterval: timeout,
   26|      0|            file: actualExpression.location.file,
   27|      0|            line: actualExpression.location.line,
   28|      0|            fnName: fnName) {
   29|      0|                lastPredicateResult = try predicate.satisfies(uncachedExpression)
   30|      0|                return lastPredicateResult!.toBoolean(expectation: style)
   31|      0|        }
   32|      0|        switch result {
   33|      0|        case .completed: return lastPredicateResult!
   34|      0|        case .timedOut:
   35|      0|            let message = lastPredicateResult?.message ?? .fail("timed out before returning a value")
   36|      0|            return PredicateResult(status: .fail, message: message)
   37|      0|        case let .errorThrown(error):
   38|      0|            return PredicateResult(status: .fail, message: .fail("unexpected error thrown: <\(error)>"))
   39|      0|        case let .raisedException(exception):
   40|      0|            return PredicateResult(status: .fail, message: .fail("unexpected exception raised: \(exception)"))
   41|      0|        case .blockedRunLoop:
   42|      0|            let message = lastPredicateResult?.message.appended(message: " (timed out, but main run loop was unresponsive).") ??
   43|      0|                .fail("main run loop was unresponsive")
   44|      0|            return PredicateResult(status: .fail, message: message)
   45|      0|        case .incomplete:
   46|      0|            internalError("Reached .incomplete state for \(fnName)(...).")
   47|      0|        }
   48|      0|    }
   49|      0|}
   50|       |
   51|       |private let toEventuallyRequiresClosureError = FailureMessage(
   52|       |    stringValue: """
   53|       |        expect(...).toEventually(...) requires an explicit closure (eg - expect { ... }.toEventually(...) )
   54|       |        Swift 1.2 @autoclosure behavior has changed in an incompatible way for Nimble to function
   55|       |        """
   56|       |)
   57|       |
   58|       |extension Expectation {
   59|       |    /// Tests the actual value using a matcher to match by checking continuously
   60|       |    /// at each pollInterval until the timeout is reached.
   61|       |    ///
   62|       |    /// @discussion
   63|       |    /// This function manages the main run loop (`NSRunLoop.mainRunLoop()`) while this function
   64|       |    /// is executing. Any attempts to touch the run loop may cause non-deterministic behavior.
   65|      0|    public func toEventually(_ predicate: Predicate<T>, timeout: DispatchTimeInterval = AsyncDefaults.timeout, pollInterval: DispatchTimeInterval = AsyncDefaults.pollInterval, description: String? = nil) {
   66|      0|        nimblePrecondition(expression.isClosure, "NimbleInternalError", toEventuallyRequiresClosureError.stringValue)
   67|      0|
   68|      0|        let (pass, msg) = execute(
   69|      0|            expression,
   70|      0|            .toMatch,
   71|      0|            async(style: .toMatch, predicate: predicate, timeout: timeout, poll: pollInterval, fnName: "toEventually"),
   72|      0|            to: "to eventually",
   73|      0|            description: description,
   74|      0|            captureExceptions: false
   75|      0|        )
   76|      0|        verify(pass, msg)
   77|      0|    }
   78|       |
   79|       |    /// Tests the actual value using a matcher to not match by checking
   80|       |    /// continuously at each pollInterval until the timeout is reached.
   81|       |    ///
   82|       |    /// @discussion
   83|       |    /// This function manages the main run loop (`NSRunLoop.mainRunLoop()`) while this function
   84|       |    /// is executing. Any attempts to touch the run loop may cause non-deterministic behavior.
   85|      0|    public func toEventuallyNot(_ predicate: Predicate<T>, timeout: DispatchTimeInterval = AsyncDefaults.timeout, pollInterval: DispatchTimeInterval = AsyncDefaults.pollInterval, description: String? = nil) {
   86|      0|        nimblePrecondition(expression.isClosure, "NimbleInternalError", toEventuallyRequiresClosureError.stringValue)
   87|      0|
   88|      0|        let (pass, msg) = execute(
   89|      0|            expression,
   90|      0|            .toNotMatch,
   91|      0|            async(
   92|      0|                style: .toNotMatch,
   93|      0|                predicate: predicate,
   94|      0|                timeout: timeout,
   95|      0|                poll: pollInterval,
   96|      0|                fnName: "toEventuallyNot"
   97|      0|            ),
   98|      0|            to: "to eventually not",
   99|      0|            description: description,
  100|      0|            captureExceptions: false
  101|      0|        )
  102|      0|        verify(pass, msg)
  103|      0|    }
  104|       |
  105|       |    /// Tests the actual value using a matcher to not match by checking
  106|       |    /// continuously at each pollInterval until the timeout is reached.
  107|       |    ///
  108|       |    /// Alias of toEventuallyNot()
  109|       |    ///
  110|       |    /// @discussion
  111|       |    /// This function manages the main run loop (`NSRunLoop.mainRunLoop()`) while this function
  112|       |    /// is executing. Any attempts to touch the run loop may cause non-deterministic behavior.
  113|      0|    public func toNotEventually(_ predicate: Predicate<T>, timeout: DispatchTimeInterval = AsyncDefaults.timeout, pollInterval: DispatchTimeInterval = AsyncDefaults.pollInterval, description: String? = nil) {
  114|      0|        return toEventuallyNot(predicate, timeout: timeout, pollInterval: pollInterval, description: description)
  115|      0|    }
  116|       |}
  117|       |
  118|       |@available(*, deprecated, message: "Use Predicate instead")
  119|       |extension Expectation {
  120|       |    /// Tests the actual value using a matcher to match by checking continuously
  121|       |    /// at each pollInterval until the timeout is reached.
  122|       |    ///
  123|       |    /// @discussion
  124|       |    /// This function manages the main run loop (`NSRunLoop.mainRunLoop()`) while this function
  125|       |    /// is executing. Any attempts to touch the run loop may cause non-deterministic behavior.
  126|       |    public func toEventually<U>(_ matcher: U, timeout: DispatchTimeInterval = AsyncDefaults.timeout, pollInterval: DispatchTimeInterval = AsyncDefaults.pollInterval, description: String? = nil)
  127|      0|        where U: Matcher, U.ValueType == T {
  128|      0|        if expression.isClosure {
  129|      0|            let (pass, msg) = execute(
  130|      0|                expression,
  131|      0|                .toMatch,
  132|      0|                async(
  133|      0|                    style: .toMatch,
  134|      0|                    predicate: matcher.predicate,
  135|      0|                    timeout: timeout,
  136|      0|                    poll: pollInterval,
  137|      0|                    fnName: "toEventually"
  138|      0|                ),
  139|      0|                to: "to eventually",
  140|      0|                description: description,
  141|      0|                captureExceptions: false
  142|      0|            )
  143|      0|            verify(pass, msg)
  144|      0|        } else {
  145|      0|            verify(false, toEventuallyRequiresClosureError)
  146|      0|        }
  147|      0|    }
  148|       |
  149|       |    /// Tests the actual value using a matcher to not match by checking
  150|       |    /// continuously at each pollInterval until the timeout is reached.
  151|       |    ///
  152|       |    /// @discussion
  153|       |    /// This function manages the main run loop (`NSRunLoop.mainRunLoop()`) while this function
  154|       |    /// is executing. Any attempts to touch the run loop may cause non-deterministic behavior.
  155|       |    public func toEventuallyNot<U>(_ matcher: U, timeout: DispatchTimeInterval = AsyncDefaults.timeout, pollInterval: DispatchTimeInterval = AsyncDefaults.pollInterval, description: String? = nil)
  156|      0|        where U: Matcher, U.ValueType == T {
  157|      0|        if expression.isClosure {
  158|      0|            let (pass, msg) = expressionDoesNotMatch(
  159|      0|                expression,
  160|      0|                matcher: async(
  161|      0|                    style: .toNotMatch,
  162|      0|                    predicate: matcher.predicate,
  163|      0|                    timeout: timeout,
  164|      0|                    poll: pollInterval,
  165|      0|                    fnName: "toEventuallyNot"
  166|      0|                ),
  167|      0|                toNot: "to eventually not",
  168|      0|                description: description
  169|      0|            )
  170|      0|            verify(pass, msg)
  171|      0|        } else {
  172|      0|            verify(false, toEventuallyRequiresClosureError)
  173|      0|        }
  174|      0|    }
  175|       |
  176|       |    /// Tests the actual value using a matcher to not match by checking
  177|       |    /// continuously at each pollInterval until the timeout is reached.
  178|       |    ///
  179|       |    /// Alias of toEventuallyNot()
  180|       |    ///
  181|       |    /// @discussion
  182|       |    /// This function manages the main run loop (`NSRunLoop.mainRunLoop()`) while this function
  183|       |    /// is executing. Any attempts to touch the run loop may cause non-deterministic behavior.
  184|       |    public func toNotEventually<U>(_ matcher: U, timeout: DispatchTimeInterval = AsyncDefaults.timeout, pollInterval: DispatchTimeInterval = AsyncDefaults.pollInterval, description: String? = nil)
  185|      0|        where U: Matcher, U.ValueType == T {
  186|      0|        return toEventuallyNot(matcher, timeout: timeout, pollInterval: pollInterval, description: description)
  187|      0|    }
  188|       |}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/BeAKindOf.swift:
    1|      0|private func matcherMessage<T>(forType expectedType: T.Type) -> String {
    2|      0|    return "be a kind of \(String(describing: expectedType))"
    3|      0|}
    4|      0|private func matcherMessage(forClass expectedClass: AnyClass) -> String {
    5|      0|    return "be a kind of \(String(describing: expectedClass))"
    6|      0|}
    7|       |
    8|       |/// A Nimble matcher that succeeds when the actual value is an instance of the given class.
    9|      0|public func beAKindOf<T>(_ expectedType: T.Type) -> Predicate<Any> {
   10|      0|    return Predicate.define { actualExpression in
   11|      0|        let message: ExpectationMessage
   12|      0|
   13|      0|        let instance = try actualExpression.evaluate()
   14|      0|        guard let validInstance = instance else {
   15|      0|            message = .expectedCustomValueTo(matcherMessage(forType: expectedType), actual: "<nil>")
   16|      0|            return PredicateResult(status: .fail, message: message)
   17|      0|        }
   18|      0|        message = .expectedCustomValueTo(
   19|      0|            "be a kind of \(String(describing: expectedType))",
   20|      0|            actual: "<\(String(describing: type(of: validInstance))) instance>"
   21|      0|        )
   22|      0|
   23|      0|        return PredicateResult(
   24|      0|            bool: validInstance is T,
   25|      0|            message: message
   26|      0|        )
   27|      0|    }
   28|      0|}
   29|       |
   30|       |#if canImport(Darwin)
   31|       |import class Foundation.NSObject
   32|       |
   33|       |/// A Nimble matcher that succeeds when the actual value is an instance of the given class.
   34|       |/// @see beAnInstanceOf if you want to match against the exact class
   35|      0|public func beAKindOf(_ expectedClass: AnyClass) -> Predicate<NSObject> {
   36|      0|    return Predicate.define { actualExpression in
   37|      0|        let message: ExpectationMessage
   38|      0|        let status: PredicateStatus
   39|      0|
   40|      0|        let instance = try actualExpression.evaluate()
   41|      0|        if let validInstance = instance {
   42|      0|            status = PredicateStatus(bool: instance != nil && instance!.isKind(of: expectedClass))
   43|      0|            message = .expectedCustomValueTo(
   44|      0|                matcherMessage(forClass: expectedClass),
   45|      0|                actual: "<\(String(describing: type(of: validInstance))) instance>"
   46|      0|            )
   47|      0|        } else {
   48|      0|            status = .fail
   49|      0|            message = .expectedCustomValueTo(
   50|      0|                matcherMessage(forClass: expectedClass),
   51|      0|                actual: "<nil>"
   52|      0|            )
   53|      0|        }
   54|      0|
   55|      0|        return PredicateResult(status: status, message: message)
   56|      0|    }
   57|      0|}
   58|       |
   59|       |extension NMBPredicate {
   60|      0|    @objc public class func beAKindOfMatcher(_ expected: AnyClass) -> NMBPredicate {
   61|      0|        return NMBPredicate { actualExpression in
   62|      0|            return try beAKindOf(expected).satisfies(actualExpression).toObjectiveC()
   63|      0|        }
   64|      0|    }
   65|       |}
   66|       |
   67|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/BeAnInstanceOf.swift:
    1|       |import Foundation
    2|       |
    3|       |/// A Nimble matcher that succeeds when the actual value is an _exact_ instance of the given class.
    4|      0|public func beAnInstanceOf<T>(_ expectedType: T.Type) -> Predicate<Any> {
    5|      0|    let errorMessage = "be an instance of \(String(describing: expectedType))"
    6|      0|    return Predicate.define { actualExpression in
    7|      0|        let instance = try actualExpression.evaluate()
    8|      0|        guard let validInstance = instance else {
    9|      0|            return PredicateResult(
   10|      0|                status: .doesNotMatch,
   11|      0|                message: .expectedActualValueTo(errorMessage)
   12|      0|            )
   13|      0|        }
   14|      0|
   15|      0|        let actualString = "<\(String(describing: type(of: validInstance))) instance>"
   16|      0|
   17|      0|        return PredicateResult(
   18|      0|            status: PredicateStatus(bool: type(of: validInstance) == expectedType),
   19|      0|            message: .expectedCustomValueTo(errorMessage, actual: actualString)
   20|      0|        )
   21|      0|    }
   22|      0|}
   23|       |
   24|       |/// A Nimble matcher that succeeds when the actual value is an instance of the given class.
   25|       |/// @see beAKindOf if you want to match against subclasses
   26|      0|public func beAnInstanceOf(_ expectedClass: AnyClass) -> Predicate<NSObject> {
   27|      0|    let errorMessage = "be an instance of \(String(describing: expectedClass))"
   28|      0|    return Predicate.define { actualExpression in
   29|      0|        let instance = try actualExpression.evaluate()
   30|      0|        let actualString: String
   31|      0|        if let validInstance = instance {
   32|      0|            actualString = "<\(String(describing: type(of: validInstance))) instance>"
   33|      0|        } else {
   34|      0|            actualString = "<nil>"
   35|      0|        }
   36|      0|        #if canImport(Darwin)
   37|      0|            let matches = instance != nil && instance!.isMember(of: expectedClass)
   38|      0|        #else
   39|      0|            let matches = instance != nil && type(of: instance!) == expectedClass
   40|      0|        #endif
   41|      0|        return PredicateResult(
   42|      0|            status: PredicateStatus(bool: matches),
   43|      0|            message: .expectedCustomValueTo(errorMessage, actual: actualString)
   44|      0|        )
   45|      0|    }
   46|      0|}
   47|       |
   48|       |#if canImport(Darwin)
   49|       |extension NMBPredicate {
   50|      0|    @objc public class func beAnInstanceOfMatcher(_ expected: AnyClass) -> NMBPredicate {
   51|      0|        return NMBPredicate { actualExpression in
   52|      0|            return try beAnInstanceOf(expected).satisfies(actualExpression).toObjectiveC()
   53|      0|        }
   54|      0|    }
   55|       |}
   56|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/BeCloseTo.swift:
    1|       |import Foundation
    2|       |
    3|       |// swiftlint:disable:next identifier_name
    4|       |public let DefaultDelta = 0.0001
    5|       |
    6|       |internal func isCloseTo(_ actualValue: NMBDoubleConvertible?,
    7|       |                        expectedValue: NMBDoubleConvertible,
    8|       |                        delta: Double)
    9|      0|    -> PredicateResult {
   10|      0|        let errorMessage = "be close to <\(stringify(expectedValue))> (within \(stringify(delta)))"
   11|      0|        return PredicateResult(
   12|      0|            bool: actualValue != nil &&
   13|      0|                abs(actualValue!.doubleValue - expectedValue.doubleValue) < delta,
   14|      0|            message: .expectedCustomValueTo(errorMessage, actual: "<\(stringify(actualValue))>")
   15|      0|        )
   16|      0|}
   17|       |
   18|       |/// A Nimble matcher that succeeds when a value is close to another. This is used for floating
   19|       |/// point values which can have imprecise results when doing arithmetic on them.
   20|       |///
   21|       |/// @see equal
   22|      0|public func beCloseTo<Value: NMBDoubleConvertible>(_ expectedValue: Value, within delta: Double = DefaultDelta) -> Predicate<Value> {
   23|      0|    return Predicate.define { actualExpression in
   24|      0|        return isCloseTo(try actualExpression.evaluate(), expectedValue: expectedValue, delta: delta)
   25|      0|    }
   26|      0|}
   27|       |
   28|      0|private func beCloseTo(_ expectedValue: NMBDoubleConvertible, within delta: Double = DefaultDelta) -> Predicate<NMBDoubleConvertible> {
   29|      0|    return Predicate.define { actualExpression in
   30|      0|        return isCloseTo(try actualExpression.evaluate(), expectedValue: expectedValue, delta: delta)
   31|      0|    }
   32|      0|}
   33|       |
   34|       |#if canImport(Darwin)
   35|       |public class NMBObjCBeCloseToPredicate: NMBPredicate {
   36|       |    private let _expected: NSNumber
   37|       |
   38|      0|    fileprivate init(expected: NSNumber, within: CDouble) {
   39|      0|        _expected = expected
   40|      0|
   41|      0|        let predicate = beCloseTo(expected, within: within)
   42|      0|        let predicateBlock: PredicateBlock = { actualExpression in
   43|      0|            let expr = actualExpression.cast { $0 as? NMBDoubleConvertible }
   44|      0|            return try predicate.satisfies(expr).toObjectiveC()
   45|      0|        }
   46|      0|        super.init(predicate: predicateBlock)
   47|      0|    }
   48|       |
   49|      0|    @objc public var within: (CDouble) -> NMBObjCBeCloseToPredicate {
   50|      0|        let expected = _expected
   51|      0|        return { delta in
   52|      0|            return NMBObjCBeCloseToPredicate(expected: expected, within: delta)
   53|      0|        }
   54|      0|    }
   55|       |}
   56|       |
   57|       |extension NMBPredicate {
   58|      0|    @objc public class func beCloseToMatcher(_ expected: NSNumber, within: CDouble) -> NMBObjCBeCloseToPredicate {
   59|      0|        return NMBObjCBeCloseToPredicate(expected: expected, within: within)
   60|      0|    }
   61|       |}
   62|       |#endif
   63|       |
   64|      0|public func beCloseTo(_ expectedValues: [Double], within delta: Double = DefaultDelta) -> Predicate<[Double]> {
   65|      0|    let errorMessage = "be close to <\(stringify(expectedValues))> (each within \(stringify(delta)))"
   66|      0|    return Predicate.simple(errorMessage) { actualExpression in
   67|      0|        if let actual = try actualExpression.evaluate() {
   68|      0|            if actual.count != expectedValues.count {
   69|      0|                return .doesNotMatch
   70|      0|            } else {
   71|      0|                for (index, actualItem) in actual.enumerated() {
   72|      0|                    if fabs(actualItem - expectedValues[index]) > delta {
   73|      0|                        return .doesNotMatch
   74|      0|                    }
   75|      0|                }
   76|      0|                return .matches
   77|      0|            }
   78|      0|        }
   79|      0|        return .doesNotMatch
   80|      0|    }
   81|      0|}
   82|       |
   83|       |// MARK: - Operators
   84|       |
   85|       |infix operator ≈ : ComparisonPrecedence
   86|       |
   87|       |extension Expectation where T == [Double] {
   88|       |    // swiftlint:disable:next identifier_name
   89|      0|    public static func ≈(lhs: Expectation, rhs: [Double]) {
   90|      0|        lhs.to(beCloseTo(rhs))
   91|      0|    }
   92|       |}
   93|       |
   94|       |extension Expectation where T == NMBDoubleConvertible {
   95|       |    // swiftlint:disable:next identifier_name
   96|      0|    public static func ≈(lhs: Expectation, rhs: NMBDoubleConvertible) {
   97|      0|        lhs.to(beCloseTo(rhs))
   98|      0|    }
   99|       |
  100|       |    // swiftlint:disable:next identifier_name
  101|      0|    public static func ≈(lhs: Expectation, rhs: (expected: NMBDoubleConvertible, delta: Double)) {
  102|      0|        lhs.to(beCloseTo(rhs.expected, within: rhs.delta))
  103|      0|    }
  104|       |
  105|      0|    public static func == (lhs: Expectation, rhs: (expected: NMBDoubleConvertible, delta: Double)) {
  106|      0|        lhs.to(beCloseTo(rhs.expected, within: rhs.delta))
  107|      0|    }
  108|       |}
  109|       |
  110|       |// make this higher precedence than exponents so the Doubles either end aren't pulled in
  111|       |// unexpectantly
  112|       |precedencegroup PlusMinusOperatorPrecedence {
  113|       |    higherThan: BitwiseShiftPrecedence
  114|       |}
  115|       |
  116|       |infix operator ± : PlusMinusOperatorPrecedence
  117|       |// swiftlint:disable:next identifier_name
  118|      0|public func ±(lhs: NMBDoubleConvertible, rhs: Double) -> (expected: NMBDoubleConvertible, delta: Double) {
  119|      0|    return (expected: lhs, delta: rhs)
  120|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/BeEmpty.swift:
    1|       |import Foundation
    2|       |
    3|       |/// A Nimble matcher that succeeds when a value is "empty". For collections, this
    4|       |/// means the are no items in that collection. For strings, it is an empty string.
    5|      0|public func beEmpty<S: Sequence>() -> Predicate<S> {
    6|      0|    return Predicate.simple("be empty") { actualExpression in
    7|      0|        guard let actual = try actualExpression.evaluate() else { return .fail }
    8|      0|
    9|      0|        var generator = actual.makeIterator()
   10|      0|        return PredicateStatus(bool: generator.next() == nil)
   11|      0|    }
   12|      0|}
   13|       |
   14|       |/// A Nimble matcher that succeeds when a value is "empty". For collections, this
   15|       |/// means the are no items in that collection. For strings, it is an empty string.
   16|      0|public func beEmpty<S: SetAlgebra>() -> Predicate<S> {
   17|      0|    return Predicate.simple("be empty") { actualExpression in
   18|      0|        guard let actual = try actualExpression.evaluate() else { return .fail }
   19|      0|        return PredicateStatus(bool: actual.isEmpty)
   20|      0|    }
   21|      0|}
   22|       |
   23|       |/// A Nimble matcher that succeeds when a value is "empty". For collections, this
   24|       |/// means the are no items in that collection. For strings, it is an empty string.
   25|      0|public func beEmpty<S: Sequence & SetAlgebra>() -> Predicate<S> {
   26|      0|    return Predicate.simple("be empty") { actualExpression in
   27|      0|        guard let actual = try actualExpression.evaluate() else { return .fail }
   28|      0|        return PredicateStatus(bool: actual.isEmpty)
   29|      0|    }
   30|      0|}
   31|       |
   32|       |/// A Nimble matcher that succeeds when a value is "empty". For collections, this
   33|       |/// means the are no items in that collection. For strings, it is an empty string.
   34|      0|public func beEmpty() -> Predicate<String> {
   35|      0|    return Predicate.simple("be empty") { actualExpression in
   36|      0|        guard let actual = try actualExpression.evaluate() else { return .fail }
   37|      0|        return PredicateStatus(bool: actual.isEmpty)
   38|      0|    }
   39|      0|}
   40|       |
   41|       |/// A Nimble matcher that succeeds when a value is "empty". For collections, this
   42|       |/// means the are no items in that collection. For NSString instances, it is an empty string.
   43|      0|public func beEmpty() -> Predicate<NSString> {
   44|      0|    return Predicate.simple("be empty") { actualExpression in
   45|      0|        guard let actual = try actualExpression.evaluate() else { return .fail }
   46|      0|        return PredicateStatus(bool: actual.length == 0)
   47|      0|    }
   48|      0|}
   49|       |
   50|       |// Without specific overrides, beEmpty() is ambiguous for NSDictionary, NSArray,
   51|       |// etc, since they conform to Sequence as well as NMBCollection.
   52|       |
   53|       |/// A Nimble matcher that succeeds when a value is "empty". For collections, this
   54|       |/// means the are no items in that collection. For strings, it is an empty string.
   55|      0|public func beEmpty() -> Predicate<NSDictionary> {
   56|      0|    return Predicate.simple("be empty") { actualExpression in
   57|      0|        guard let actual = try actualExpression.evaluate() else { return .fail }
   58|      0|        return PredicateStatus(bool: actual.count == 0)
   59|      0|    }
   60|      0|}
   61|       |
   62|       |/// A Nimble matcher that succeeds when a value is "empty". For collections, this
   63|       |/// means the are no items in that collection. For strings, it is an empty string.
   64|      0|public func beEmpty() -> Predicate<NSArray> {
   65|      0|    return Predicate.simple("be empty") { actualExpression in
   66|      0|        guard let actual = try actualExpression.evaluate() else { return .fail }
   67|      0|        return PredicateStatus(bool: actual.count == 0)
   68|      0|    }
   69|      0|}
   70|       |
   71|       |/// A Nimble matcher that succeeds when a value is "empty". For collections, this
   72|       |/// means the are no items in that collection. For strings, it is an empty string.
   73|      0|public func beEmpty() -> Predicate<NMBCollection> {
   74|      0|    return Predicate.simple("be empty") { actualExpression in
   75|      0|        guard let actual = try actualExpression.evaluate() else { return .fail }
   76|      0|        return PredicateStatus(bool: actual.count == 0)
   77|      0|    }
   78|      0|}
   79|       |
   80|       |#if canImport(Darwin)
   81|       |extension NMBPredicate {
   82|      0|    @objc public class func beEmptyMatcher() -> NMBPredicate {
   83|      0|        return NMBPredicate { actualExpression in
   84|      0|            let location = actualExpression.location
   85|      0|            let actualValue = try actualExpression.evaluate()
   86|      0|
   87|      0|            if let value = actualValue as? NMBCollection {
   88|      0|                let expr = Expression(expression: ({ value }), location: location)
   89|      0|                return try beEmpty().satisfies(expr).toObjectiveC()
   90|      0|            } else if let value = actualValue as? NSString {
   91|      0|                let expr = Expression(expression: ({ value }), location: location)
   92|      0|                return try beEmpty().satisfies(expr).toObjectiveC()
   93|      0|            } else if let actualValue = actualValue {
   94|      0|                let badTypeErrorMsg = "be empty (only works for NSArrays, NSSets, NSIndexSets, NSDictionaries, NSHashTables, and NSStrings)"
   95|      0|                return NMBPredicateResult(
   96|      0|                    status: NMBPredicateStatus.fail,
   97|      0|                    message: NMBExpectationMessage(
   98|      0|                        expectedActualValueTo: badTypeErrorMsg,
   99|      0|                        customActualValue: "\(String(describing: type(of: actualValue))) type"
  100|      0|                    )
  101|      0|                )
  102|      0|            }
  103|      0|            return NMBPredicateResult(
  104|      0|                status: NMBPredicateStatus.fail,
  105|      0|                message: NMBExpectationMessage(expectedActualValueTo: "be empty").appendedBeNilHint()
  106|      0|            )
  107|      0|        }
  108|      0|    }
  109|       |}
  110|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/BeGreaterThan.swift:
    1|       |/// A Nimble matcher that succeeds when the actual value is greater than the expected value.
    2|      0|public func beGreaterThan<T: Comparable>(_ expectedValue: T?) -> Predicate<T> {
    3|      0|    let errorMessage = "be greater than <\(stringify(expectedValue))>"
    4|      0|    return Predicate.simple(errorMessage) { actualExpression in
    5|      0|        guard let actual = try actualExpression.evaluate(), let expected = expectedValue else { return .fail }
    6|      0|
    7|      0|        return PredicateStatus(bool: actual > expected)
    8|      0|    }
    9|      0|}
   10|       |
   11|      0|public func ><T: Comparable>(lhs: Expectation<T>, rhs: T) {
   12|      0|    lhs.to(beGreaterThan(rhs))
   13|      0|}
   14|       |
   15|       |#if canImport(Darwin)
   16|       |import enum Foundation.ComparisonResult
   17|       |
   18|       |/// A Nimble matcher that succeeds when the actual value is greater than the expected value.
   19|      0|public func beGreaterThan(_ expectedValue: NMBComparable?) -> Predicate<NMBComparable> {
   20|      0|    let errorMessage = "be greater than <\(stringify(expectedValue))>"
   21|      0|    return Predicate.simple(errorMessage) { actualExpression in
   22|      0|        let actualValue = try actualExpression.evaluate()
   23|      0|        let matches = actualValue != nil
   24|      0|            && actualValue!.NMB_compare(expectedValue) == ComparisonResult.orderedDescending
   25|      0|        return PredicateStatus(bool: matches)
   26|      0|    }
   27|      0|}
   28|       |
   29|      0|public func > (lhs: Expectation<NMBComparable>, rhs: NMBComparable?) {
   30|      0|    lhs.to(beGreaterThan(rhs))
   31|      0|}
   32|       |
   33|       |extension NMBPredicate {
   34|      0|    @objc public class func beGreaterThanMatcher(_ expected: NMBComparable?) -> NMBPredicate {
   35|      0|        return NMBPredicate { actualExpression in
   36|      0|            let expr = actualExpression.cast { $0 as? NMBComparable }
   37|      0|            return try beGreaterThan(expected).satisfies(expr).toObjectiveC()
   38|      0|        }
   39|      0|    }
   40|       |}
   41|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/BeGreaterThanOrEqualTo.swift:
    1|       |/// A Nimble matcher that succeeds when the actual value is greater than
    2|       |/// or equal to the expected value.
    3|      0|public func beGreaterThanOrEqualTo<T: Comparable>(_ expectedValue: T?) -> Predicate<T> {
    4|      0|    let message = "be greater than or equal to <\(stringify(expectedValue))>"
    5|      0|    return Predicate.simple(message) { actualExpression in
    6|      0|        guard let actual = try actualExpression.evaluate(), let expected = expectedValue else { return .fail }
    7|      0|
    8|      0|        return PredicateStatus(bool: actual >= expected)
    9|      0|    }
   10|      0|}
   11|       |
   12|      0|public func >=<T: Comparable>(lhs: Expectation<T>, rhs: T) {
   13|      0|    lhs.to(beGreaterThanOrEqualTo(rhs))
   14|      0|}
   15|       |
   16|       |#if canImport(Darwin)
   17|       |import enum Foundation.ComparisonResult
   18|       |
   19|       |/// A Nimble matcher that succeeds when the actual value is greater than
   20|       |/// or equal to the expected value.
   21|      0|public func beGreaterThanOrEqualTo<T: NMBComparable>(_ expectedValue: T?) -> Predicate<T> {
   22|      0|    let message = "be greater than or equal to <\(stringify(expectedValue))>"
   23|      0|    return Predicate.simple(message) { actualExpression in
   24|      0|        let actualValue = try actualExpression.evaluate()
   25|      0|        let matches = actualValue != nil && actualValue!.NMB_compare(expectedValue) != ComparisonResult.orderedAscending
   26|      0|        return PredicateStatus(bool: matches)
   27|      0|    }
   28|      0|}
   29|       |
   30|      0|public func >=<T: NMBComparable>(lhs: Expectation<T>, rhs: T) {
   31|      0|    lhs.to(beGreaterThanOrEqualTo(rhs))
   32|      0|}
   33|       |
   34|       |extension NMBPredicate {
   35|      0|    @objc public class func beGreaterThanOrEqualToMatcher(_ expected: NMBComparable?) -> NMBPredicate {
   36|      0|        return NMBPredicate { actualExpression in
   37|      0|            let expr = actualExpression.cast { $0 as? NMBComparable }
   38|      0|            return try beGreaterThanOrEqualTo(expected).satisfies(expr).toObjectiveC()
   39|      0|        }
   40|      0|    }
   41|       |}
   42|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/BeIdenticalTo.swift:
    1|       |/// A Nimble matcher that succeeds when the actual value is the same instance
    2|       |/// as the expected instance.
    3|      0|public func beIdenticalTo(_ expected: Any?) -> Predicate<Any> {
    4|      0|    return Predicate.define { actualExpression in
    5|      0|        let actual = try actualExpression.evaluate() as AnyObject?
    6|      0|
    7|      0|        let bool = actual === (expected as AnyObject?) && actual !== nil
    8|      0|        return PredicateResult(
    9|      0|            bool: bool,
   10|      0|            message: .expectedCustomValueTo(
   11|      0|                "be identical to \(identityAsString(expected))",
   12|      0|                actual: "\(identityAsString(actual))"
   13|      0|            )
   14|      0|        )
   15|      0|    }
   16|      0|}
   17|       |
   18|       |extension Expectation where T == Any {
   19|      0|    public static func === (lhs: Expectation, rhs: Any?) {
   20|      0|        lhs.to(beIdenticalTo(rhs))
   21|      0|    }
   22|       |
   23|      0|    public static func !== (lhs: Expectation, rhs: Any?) {
   24|      0|        lhs.toNot(beIdenticalTo(rhs))
   25|      0|    }
   26|       |}
   27|       |
   28|       |/// A Nimble matcher that succeeds when the actual value is the same instance
   29|       |/// as the expected instance.
   30|       |///
   31|       |/// Alias for "beIdenticalTo".
   32|      0|public func be(_ expected: Any?) -> Predicate<Any> {
   33|      0|    return beIdenticalTo(expected)
   34|      0|}
   35|       |
   36|       |#if canImport(Darwin)
   37|       |import class Foundation.NSObject
   38|       |
   39|       |extension NMBPredicate {
   40|      0|    @objc public class func beIdenticalToMatcher(_ expected: NSObject?) -> NMBPredicate {
   41|      0|        return NMBPredicate { actualExpression in
   42|      0|            let aExpr = actualExpression.cast { $0 as Any? }
   43|      0|            return try beIdenticalTo(expected).satisfies(aExpr).toObjectiveC()
   44|      0|        }
   45|      0|    }
   46|       |}
   47|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/BeLessThan.swift:
    1|       |/// A Nimble matcher that succeeds when the actual value is less than the expected value.
    2|      0|public func beLessThan<T: Comparable>(_ expectedValue: T?) -> Predicate<T> {
    3|      0|    let message = "be less than <\(stringify(expectedValue))>"
    4|      0|    return Predicate.simple(message) { actualExpression in
    5|      0|        guard let actual = try actualExpression.evaluate(), let expected = expectedValue else { return .fail }
    6|      0|
    7|      0|        return PredicateStatus(bool: actual < expected)
    8|      0|    }
    9|      0|}
   10|       |
   11|      0|public func <<T: Comparable>(lhs: Expectation<T>, rhs: T) {
   12|      0|    lhs.to(beLessThan(rhs))
   13|      0|}
   14|       |
   15|       |#if canImport(Darwin)
   16|       |import enum Foundation.ComparisonResult
   17|       |
   18|       |/// A Nimble matcher that succeeds when the actual value is less than the expected value.
   19|      0|public func beLessThan(_ expectedValue: NMBComparable?) -> Predicate<NMBComparable> {
   20|      0|    let message = "be less than <\(stringify(expectedValue))>"
   21|      0|    return Predicate.simple(message) { actualExpression in
   22|      0|        let actualValue = try actualExpression.evaluate()
   23|      0|        let matches = actualValue != nil && actualValue!.NMB_compare(expectedValue) == ComparisonResult.orderedAscending
   24|      0|        return PredicateStatus(bool: matches)
   25|      0|    }
   26|      0|}
   27|       |
   28|      0|public func < (lhs: Expectation<NMBComparable>, rhs: NMBComparable?) {
   29|      0|    lhs.to(beLessThan(rhs))
   30|      0|}
   31|       |
   32|       |extension NMBPredicate {
   33|      0|    @objc public class func beLessThanMatcher(_ expected: NMBComparable?) -> NMBPredicate {
   34|      0|        return NMBPredicate { actualExpression in
   35|      0|            let expr = actualExpression.cast { $0 as? NMBComparable }
   36|      0|            return try beLessThan(expected).satisfies(expr).toObjectiveC()
   37|      0|        }
   38|      0|    }
   39|       |}
   40|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/BeLessThanOrEqual.swift:
    1|       |/// A Nimble matcher that succeeds when the actual value is less than
    2|       |/// or equal to the expected value.
    3|      0|public func beLessThanOrEqualTo<T: Comparable>(_ expectedValue: T?) -> Predicate<T> {
    4|      0|    return Predicate.simple("be less than or equal to <\(stringify(expectedValue))>") { actualExpression in
    5|      0|        guard let actual = try actualExpression.evaluate(), let expected = expectedValue else { return .fail }
    6|      0|
    7|      0|        return PredicateStatus(bool: actual <= expected)
    8|      0|    }
    9|      0|}
   10|       |
   11|      0|public func <=<T: Comparable>(lhs: Expectation<T>, rhs: T) {
   12|      0|    lhs.to(beLessThanOrEqualTo(rhs))
   13|      0|}
   14|       |
   15|       |#if canImport(Darwin)
   16|       |import enum Foundation.ComparisonResult
   17|       |
   18|       |/// A Nimble matcher that succeeds when the actual value is less than
   19|       |/// or equal to the expected value.
   20|      0|public func beLessThanOrEqualTo<T: NMBComparable>(_ expectedValue: T?) -> Predicate<T> {
   21|      0|    return Predicate.simple("be less than or equal to <\(stringify(expectedValue))>") { actualExpression in
   22|      0|        let actualValue = try actualExpression.evaluate()
   23|      0|        let matches = actualValue.map { $0.NMB_compare(expectedValue) != .orderedDescending } ?? false
   24|      0|        return PredicateStatus(bool: matches)
   25|      0|    }
   26|      0|}
   27|       |
   28|      0|public func <=<T: NMBComparable>(lhs: Expectation<T>, rhs: T) {
   29|      0|    lhs.to(beLessThanOrEqualTo(rhs))
   30|      0|}
   31|       |
   32|       |extension NMBPredicate {
   33|      0|    @objc public class func beLessThanOrEqualToMatcher(_ expected: NMBComparable?) -> NMBPredicate {
   34|      0|        return NMBPredicate { actualExpression in
   35|      0|            let expr = actualExpression.cast { $0 as? NMBComparable }
   36|      0|            return try beLessThanOrEqualTo(expected).satisfies(expr).toObjectiveC()
   37|      0|        }
   38|      0|    }
   39|       |}
   40|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/BeLogical.swift:
    1|       |import Foundation
    2|       |
    3|       |extension Int8: ExpressibleByBooleanLiteral {
    4|      0|    public init(booleanLiteral value: Bool) {
    5|      0|        self = NSNumber(value: value).int8Value
    6|      0|    }
    7|       |}
    8|       |
    9|       |extension UInt8: ExpressibleByBooleanLiteral {
   10|      0|    public init(booleanLiteral value: Bool) {
   11|      0|        self = NSNumber(value: value).uint8Value
   12|      0|    }
   13|       |}
   14|       |
   15|       |extension Int16: ExpressibleByBooleanLiteral {
   16|      0|    public init(booleanLiteral value: Bool) {
   17|      0|        self = NSNumber(value: value).int16Value
   18|      0|    }
   19|       |}
   20|       |
   21|       |extension UInt16: ExpressibleByBooleanLiteral {
   22|      0|    public init(booleanLiteral value: Bool) {
   23|      0|        self = NSNumber(value: value).uint16Value
   24|      0|    }
   25|       |}
   26|       |
   27|       |extension Int32: ExpressibleByBooleanLiteral {
   28|      0|    public init(booleanLiteral value: Bool) {
   29|      0|        self = NSNumber(value: value).int32Value
   30|      0|    }
   31|       |}
   32|       |
   33|       |extension UInt32: ExpressibleByBooleanLiteral {
   34|      0|    public init(booleanLiteral value: Bool) {
   35|      0|        self = NSNumber(value: value).uint32Value
   36|      0|    }
   37|       |}
   38|       |
   39|       |extension Int64: ExpressibleByBooleanLiteral {
   40|      0|    public init(booleanLiteral value: Bool) {
   41|      0|        self = NSNumber(value: value).int64Value
   42|      0|    }
   43|       |}
   44|       |
   45|       |extension UInt64: ExpressibleByBooleanLiteral {
   46|      0|    public init(booleanLiteral value: Bool) {
   47|      0|        self = NSNumber(value: value).uint64Value
   48|      0|    }
   49|       |}
   50|       |
   51|       |extension Float: ExpressibleByBooleanLiteral {
   52|      0|    public init(booleanLiteral value: Bool) {
   53|      0|        self = NSNumber(value: value).floatValue
   54|      0|    }
   55|       |}
   56|       |
   57|       |extension Double: ExpressibleByBooleanLiteral {
   58|      0|    public init(booleanLiteral value: Bool) {
   59|      0|        self = NSNumber(value: value).doubleValue
   60|      0|    }
   61|       |}
   62|       |
   63|       |extension Int: ExpressibleByBooleanLiteral {
   64|      0|    public init(booleanLiteral value: Bool) {
   65|      0|        self = NSNumber(value: value).intValue
   66|      0|    }
   67|       |}
   68|       |
   69|       |extension UInt: ExpressibleByBooleanLiteral {
   70|      0|    public init(booleanLiteral value: Bool) {
   71|      0|        self = NSNumber(value: value).uintValue
   72|      0|    }
   73|       |}
   74|       |
   75|      3|internal func rename<T>(_ matcher: Predicate<T>, failureMessage message: ExpectationMessage) -> Predicate<T> {
   76|      3|    return Predicate { actualExpression in
   77|      3|        let result = try matcher.satisfies(actualExpression)
   78|      3|        return PredicateResult(status: result.status, message: message)
   79|      3|    }.requireNonNil
   80|      3|}
   81|       |
   82|       |// MARK: beTrue() / beFalse()
   83|       |
   84|       |/// A Nimble matcher that succeeds when the actual value is exactly true.
   85|       |/// This matcher will not match against nils.
   86|      3|public func beTrue() -> Predicate<Bool> {
   87|      3|    return rename(equal(true), failureMessage: .expectedActualValueTo("be true"))
   88|      3|}
   89|       |
   90|       |/// A Nimble matcher that succeeds when the actual value is exactly false.
   91|       |/// This matcher will not match against nils.
   92|      0|public func beFalse() -> Predicate<Bool> {
   93|      0|    return rename(equal(false), failureMessage: .expectedActualValueTo("be false"))
   94|      0|}
   95|       |
   96|       |// MARK: beTruthy() / beFalsy()
   97|       |
   98|       |/// A Nimble matcher that succeeds when the actual value is not logically false.
   99|      0|public func beTruthy<T: ExpressibleByBooleanLiteral & Equatable>() -> Predicate<T> {
  100|      0|    return Predicate.simpleNilable("be truthy") { actualExpression in
  101|      0|        let actualValue = try actualExpression.evaluate()
  102|      0|        if let actualValue = actualValue {
  103|      0|            return PredicateStatus(bool: actualValue == (true as T))
  104|      0|        }
  105|      0|        return PredicateStatus(bool: actualValue != nil)
  106|      0|    }
  107|      0|}
  108|       |
  109|       |/// A Nimble matcher that succeeds when the actual value is logically false.
  110|       |/// This matcher will match against nils.
  111|      0|public func beFalsy<T: ExpressibleByBooleanLiteral & Equatable>() -> Predicate<T> {
  112|      0|    return Predicate.simpleNilable("be falsy") { actualExpression in
  113|      0|        let actualValue = try actualExpression.evaluate()
  114|      0|        if let actualValue = actualValue {
  115|      0|            return PredicateStatus(bool: actualValue == (false as T))
  116|      0|        }
  117|      0|        return PredicateStatus(bool: actualValue == nil)
  118|      0|    }
  119|      0|}
  120|       |
  121|       |#if canImport(Darwin)
  122|       |extension NMBPredicate {
  123|      0|    @objc public class func beTruthyMatcher() -> NMBPredicate {
  124|      0|        return NMBPredicate { actualExpression in
  125|      0|            let expr = actualExpression.cast { ($0 as? NSNumber)?.boolValue ?? false }
  126|      0|            return try beTruthy().satisfies(expr).toObjectiveC()
  127|      0|        }
  128|      0|    }
  129|       |
  130|      0|    @objc public class func beFalsyMatcher() -> NMBPredicate {
  131|      0|        return NMBPredicate { actualExpression in
  132|      0|            let expr = actualExpression.cast { ($0 as? NSNumber)?.boolValue ?? false }
  133|      0|            return try beFalsy().satisfies(expr).toObjectiveC()
  134|      0|        }
  135|      0|    }
  136|       |
  137|      0|    @objc public class func beTrueMatcher() -> NMBPredicate {
  138|      0|        return NMBPredicate { actualExpression in
  139|      0|            let expr = actualExpression.cast { ($0 as? NSNumber)?.boolValue ?? false }
  140|      0|            return try beTrue().satisfies(expr).toObjectiveC()
  141|      0|        }
  142|      0|    }
  143|       |
  144|      0|    @objc public class func beFalseMatcher() -> NMBPredicate {
  145|      0|        return NMBPredicate { actualExpression in
  146|      0|            let expr = actualExpression.cast { value -> Bool? in
  147|      0|                guard let value = value else { return nil }
  148|      0|                return (value as? NSNumber)?.boolValue ?? false
  149|      0|            }
  150|      0|            return try beFalse().satisfies(expr).toObjectiveC()
  151|      0|        }
  152|      0|    }
  153|       |}
  154|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/BeNil.swift:
    1|       |/// A Nimble matcher that succeeds when the actual value is nil.
    2|      2|public func beNil<T>() -> Predicate<T> {
    3|      2|    return Predicate.simpleNilable("be nil") { actualExpression in
    4|      2|        let actualValue = try actualExpression.evaluate()
    5|      2|        return PredicateStatus(bool: actualValue == nil)
    6|      2|    }
    7|      2|}
    8|       |
    9|       |#if canImport(Darwin)
   10|       |import Foundation
   11|       |
   12|       |extension NMBPredicate {
   13|      0|    @objc public class func beNilMatcher() -> NMBPredicate {
   14|      0|        return NMBPredicate { actualExpression in
   15|      0|            return try beNil().satisfies(actualExpression).toObjectiveC()
   16|      0|        }
   17|      0|    }
   18|       |}
   19|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/BeVoid.swift:
    1|       |/// A Nimble matcher that succeeds when the actual value is Void.
    2|      0|public func beVoid() -> Predicate<()> {
    3|      0|    return Predicate.simpleNilable("be void") { actualExpression in
    4|      0|        let actualValue: ()? = try actualExpression.evaluate()
    5|      0|        return PredicateStatus(bool: actualValue != nil)
    6|      0|    }
    7|      0|}
    8|       |
    9|       |extension Expectation where T == () {
   10|      0|    public static func == (lhs: Expectation<()>, rhs: ()) {
   11|      0|        lhs.to(beVoid())
   12|      0|    }
   13|       |
   14|      0|    public static func != (lhs: Expectation<()>, rhs: ()) {
   15|      0|        lhs.toNot(beVoid())
   16|      0|    }
   17|       |}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/BeginWith.swift:
    1|       |import Foundation
    2|       |
    3|       |/// A Nimble matcher that succeeds when the actual sequence's first element
    4|       |/// is equal to the expected value.
    5|      0|public func beginWith<S: Sequence>(_ startingElement: S.Element) -> Predicate<S> where S.Element: Equatable {
    6|      0|    return Predicate.simple("begin with <\(startingElement)>") { actualExpression in
    7|      0|        guard let actualValue = try actualExpression.evaluate() else { return .fail }
    8|      0|
    9|      0|        var actualGenerator = actualValue.makeIterator()
   10|      0|        return PredicateStatus(bool: actualGenerator.next() == startingElement)
   11|      0|    }
   12|      0|}
   13|       |
   14|       |/// A Nimble matcher that succeeds when the actual collection's first element
   15|       |/// is equal to the expected object.
   16|      0|public func beginWith(_ startingElement: Any) -> Predicate<NMBOrderedCollection> {
   17|      0|    return Predicate.simple("begin with <\(startingElement)>") { actualExpression in
   18|      0|        guard let collection = try actualExpression.evaluate() else { return .fail }
   19|      0|        guard collection.count > 0 else { return .doesNotMatch }
   20|      0|        #if os(Linux)
   21|      0|            guard let collectionValue = collection.object(at: 0) as? NSObject else {
   22|      0|                return .fail
   23|      0|            }
   24|      0|        #else
   25|      0|            let collectionValue = collection.object(at: 0) as AnyObject
   26|      0|        #endif
   27|      0|        return PredicateStatus(bool: collectionValue.isEqual(startingElement))
   28|      0|    }
   29|      0|}
   30|       |
   31|       |/// A Nimble matcher that succeeds when the actual string contains expected substring
   32|       |/// where the expected substring's location is zero.
   33|      0|public func beginWith(_ startingSubstring: String) -> Predicate<String> {
   34|      0|    return Predicate.simple("begin with <\(startingSubstring)>") { actualExpression in
   35|      0|        guard let actual = try actualExpression.evaluate() else { return .fail }
   36|      0|
   37|      0|        return PredicateStatus(bool: actual.hasPrefix(startingSubstring))
   38|      0|    }
   39|      0|}
   40|       |
   41|       |#if canImport(Darwin)
   42|       |extension NMBPredicate {
   43|      0|    @objc public class func beginWithMatcher(_ expected: Any) -> NMBPredicate {
   44|      0|        return NMBPredicate { actualExpression in
   45|      0|            let actual = try actualExpression.evaluate()
   46|      0|            if actual is String {
   47|      0|                let expr = actualExpression.cast { $0 as? String }
   48|      0|                // swiftlint:disable:next force_cast
   49|      0|                return try beginWith(expected as! String).satisfies(expr).toObjectiveC()
   50|      0|            } else {
   51|      0|                let expr = actualExpression.cast { $0 as? NMBOrderedCollection }
   52|      0|                return try beginWith(expected).satisfies(expr).toObjectiveC()
   53|      0|            }
   54|      0|        }
   55|      0|    }
   56|       |}
   57|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/BeginWithPrefix.swift:
    1|       |/// A Nimble matcher that succeeds when the exepected sequence is a prefix of the actual sequence.
    2|       |///
    3|       |/// This is a matcher abstraction for https://developer.apple.com/documentation/swift/sequence/2854218-starts
    4|       |public func beginWith<Seq1: Sequence, Seq2: Sequence>(prefix expectedPrefix: Seq2?)
    5|      0|    -> Predicate<Seq1> where Seq1.Element: Equatable, Seq1.Element == Seq2.Element {
    6|      0|    return Predicate.define("begin with <\(stringify(expectedPrefix))>") { (actualExpression, msg) in
    7|      0|        let actualPrefix = try actualExpression.evaluate()
    8|      0|        switch (expectedPrefix, actualPrefix) {
    9|      0|        case (nil, _?):
   10|      0|            return PredicateResult(status: .fail, message: msg.appendedBeNilHint())
   11|      0|        case (nil, nil), (_, nil):
   12|      0|            return PredicateResult(status: .fail, message: msg)
   13|      0|        case (let expected?, let actual?):
   14|      0|            let matches = actual.starts(with: expected)
   15|      0|            return PredicateResult(bool: matches, message: msg)
   16|      0|        }
   17|      0|    }
   18|      0|}
   19|       |
   20|       |/// A Nimble matcher that succeeds when the expected sequence is the prefix of the actual sequence, using the given predicate as the equivalence test.
   21|       |///
   22|       |/// This is a matcher abstraction for https://developer.apple.com/documentation/swift/sequence/2996828-starts
   23|       |public func beginWith<Seq1: Sequence, Seq2: Sequence>(
   24|       |    prefix expectedPrefix: Seq2?,
   25|       |    by areEquivalent: @escaping (Seq1.Element, Seq2.Element) -> Bool
   26|      0|) -> Predicate<Seq1> {
   27|      0|    return Predicate.define("begin with <\(stringify(expectedPrefix))>") { (actualExpression, msg) in
   28|      0|        let actualPrefix = try actualExpression.evaluate()
   29|      0|        switch (expectedPrefix, actualPrefix) {
   30|      0|        case (nil, _?):
   31|      0|            return PredicateResult(status: .fail, message: msg.appendedBeNilHint())
   32|      0|        case (nil, nil), (_, nil):
   33|      0|            return PredicateResult(status: .fail, message: msg)
   34|      0|        case (let expected?, let actual?):
   35|      0|            let matches = actual.starts(with: expected, by: areEquivalent)
   36|      0|            return PredicateResult(bool: matches, message: msg)
   37|      0|        }
   38|      0|    }
   39|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/Contain.swift:
    1|       |#if canImport(Foundation)
    2|       |import Foundation
    3|       |#endif
    4|       |
    5|       |/// A Nimble matcher that succeeds when the actual sequence contains the expected values.
    6|      0|public func contain<S: Sequence>(_ items: S.Element...) -> Predicate<S> where S.Element: Equatable {
    7|      0|    return contain(items)
    8|      0|}
    9|       |
   10|       |/// A Nimble matcher that succeeds when the actual sequence contains the expected values.
   11|      0|public func contain<S: Sequence>(_ items: [S.Element]) -> Predicate<S> where S.Element: Equatable {
   12|      0|    return Predicate.simple("contain <\(arrayAsString(items))>") { actualExpression in
   13|      0|        guard let actual = try actualExpression.evaluate() else { return .fail }
   14|      0|
   15|      0|        let matches = items.allSatisfy {
   16|      0|            return actual.contains($0)
   17|      0|        }
   18|      0|        return PredicateStatus(bool: matches)
   19|      0|    }
   20|      0|}
   21|       |
   22|       |/// A Nimble matcher that succeeds when the actual set contains the expected values.
   23|      0|public func contain<S: SetAlgebra>(_ items: S.Element...) -> Predicate<S> where S.Element: Equatable {
   24|      0|    return contain(items)
   25|      0|}
   26|       |
   27|       |/// A Nimble matcher that succeeds when the actual set contains the expected values.
   28|      0|public func contain<S: SetAlgebra>(_ items: [S.Element]) -> Predicate<S> where S.Element: Equatable {
   29|      0|    return Predicate.simple("contain <\(arrayAsString(items))>") { actualExpression in
   30|      0|        guard let actual = try actualExpression.evaluate() else { return .fail }
   31|      0|
   32|      0|        let matches = items.allSatisfy {
   33|      0|            return actual.contains($0)
   34|      0|        }
   35|      0|        return PredicateStatus(bool: matches)
   36|      0|    }
   37|      0|}
   38|       |
   39|       |/// A Nimble matcher that succeeds when the actual set contains the expected values.
   40|      0|public func contain<S: Sequence & SetAlgebra>(_ items: S.Element...) -> Predicate<S> where S.Element: Equatable {
   41|      0|    return contain(items)
   42|      0|}
   43|       |
   44|       |/// A Nimble matcher that succeeds when the actual set contains the expected values.
   45|      0|public func contain<S: Sequence & SetAlgebra>(_ items: [S.Element]) -> Predicate<S> where S.Element: Equatable {
   46|      0|    return Predicate.simple("contain <\(arrayAsString(items))>") { actualExpression in
   47|      0|        guard let actual = try actualExpression.evaluate() else { return .fail }
   48|      0|
   49|      0|        let matches = items.allSatisfy {
   50|      0|            return actual.contains($0)
   51|      0|        }
   52|      0|        return PredicateStatus(bool: matches)
   53|      0|    }
   54|      0|}
   55|       |
   56|       |/// A Nimble matcher that succeeds when the actual string contains the expected substring.
   57|      0|public func contain(_ substrings: String...) -> Predicate<String> {
   58|      0|    return contain(substrings)
   59|      0|}
   60|       |
   61|      0|public func contain(_ substrings: [String]) -> Predicate<String> {
   62|      0|    return Predicate.simple("contain <\(arrayAsString(substrings))>") { actualExpression in
   63|      0|        guard let actual = try actualExpression.evaluate() else { return .fail }
   64|      0|
   65|      0|        let matches = substrings.allSatisfy {
   66|      0|            let range = actual.range(of: $0)
   67|      0|            return range != nil && !range!.isEmpty
   68|      0|        }
   69|      0|        return PredicateStatus(bool: matches)
   70|      0|    }
   71|      0|}
   72|       |
   73|       |#if canImport(Foundation)
   74|       |/// A Nimble matcher that succeeds when the actual string contains the expected substring.
   75|      0|public func contain(_ substrings: NSString...) -> Predicate<NSString> {
   76|      0|    return contain(substrings)
   77|      0|}
   78|       |
   79|      0|public func contain(_ substrings: [NSString]) -> Predicate<NSString> {
   80|      0|    return Predicate.simple("contain <\(arrayAsString(substrings))>") { actualExpression in
   81|      0|        guard let actual = try actualExpression.evaluate() else { return .fail }
   82|      0|
   83|      0|        let matches = substrings.allSatisfy { actual.range(of: $0.description).length != 0 }
   84|      0|        return PredicateStatus(bool: matches)
   85|      0|    }
   86|      0|}
   87|       |#endif
   88|       |
   89|       |/// A Nimble matcher that succeeds when the actual collection contains the expected object.
   90|      0|public func contain(_ items: Any?...) -> Predicate<NMBContainer> {
   91|      0|    return contain(items)
   92|      0|}
   93|       |
   94|      0|public func contain(_ items: [Any?]) -> Predicate<NMBContainer> {
   95|      0|    return Predicate.simple("contain <\(arrayAsString(items))>") { actualExpression in
   96|      0|        guard let actual = try actualExpression.evaluate() else { return .fail }
   97|      0|
   98|      0|        let matches = items.allSatisfy { item in
   99|      0|            return item.map { actual.contains($0) } ?? false
  100|      0|        }
  101|      0|        return PredicateStatus(bool: matches)
  102|      0|    }
  103|      0|}
  104|       |
  105|       |#if canImport(Darwin)
  106|       |extension NMBPredicate {
  107|      0|    @objc public class func containMatcher(_ expected: [NSObject]) -> NMBPredicate {
  108|      0|        return NMBPredicate { actualExpression in
  109|      0|            let location = actualExpression.location
  110|      0|            let actualValue = try actualExpression.evaluate()
  111|      0|            if let value = actualValue as? NMBContainer {
  112|      0|                let expr = Expression(expression: ({ value as NMBContainer }), location: location)
  113|      0|
  114|      0|                // A straightforward cast on the array causes this to crash, so we have to cast the individual items
  115|      0|                let expectedOptionals: [Any?] = expected.map({ $0 as Any? })
  116|      0|                return try contain(expectedOptionals).satisfies(expr).toObjectiveC()
  117|      0|            } else if let value = actualValue as? NSString {
  118|      0|                let expr = Expression(expression: ({ value as String }), location: location)
  119|      0|                // swiftlint:disable:next force_cast
  120|      0|                return try contain(expected as! [String]).satisfies(expr).toObjectiveC()
  121|      0|            }
  122|      0|
  123|      0|            let message: ExpectationMessage
  124|      0|            if actualValue != nil {
  125|      0|                message = ExpectationMessage.expectedActualValueTo(
  126|      0|                    "contain <\(arrayAsString(expected))> (only works for NSArrays, NSSets, NSHashTables, and NSStrings)"
  127|      0|                )
  128|      0|            } else {
  129|      0|                message = ExpectationMessage
  130|      0|                    .expectedActualValueTo("contain <\(arrayAsString(expected))>")
  131|      0|                    .appendedBeNilHint()
  132|      0|            }
  133|      0|            return NMBPredicateResult(status: .fail, message: message.toObjectiveC())
  134|      0|        }
  135|      0|    }
  136|       |}
  137|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/ContainElementSatisfying.swift:
    1|       |public func containElementSatisfying<S: Sequence>(
    2|       |    _ predicate: @escaping ((S.Element) -> Bool), _ predicateDescription: String = ""
    3|      0|) -> Predicate<S> {
    4|      0|    return Predicate.define { actualExpression in
    5|      0|        let message: ExpectationMessage
    6|      0|        if predicateDescription == "" {
    7|      0|            message = .expectedTo("find object in collection that satisfies predicate")
    8|      0|        } else {
    9|      0|            message = .expectedTo("find object in collection \(predicateDescription)")
   10|      0|        }
   11|      0|
   12|      0|        if let sequence = try actualExpression.evaluate() {
   13|      0|            for object in sequence {
   14|      0|                if predicate(object) {
   15|      0|                    return PredicateResult(bool: true, message: message)
   16|      0|                }
   17|      0|            }
   18|      0|
   19|      0|            return PredicateResult(bool: false, message: message)
   20|      0|        }
   21|      0|
   22|      0|        return PredicateResult(status: .fail, message: message)
   23|      0|    }
   24|      0|}
   25|       |
   26|       |#if canImport(Darwin)
   27|       |import class Foundation.NSObject
   28|       |import struct Foundation.NSFastEnumerationIterator
   29|       |import protocol Foundation.NSFastEnumeration
   30|       |
   31|       |extension NMBPredicate {
   32|      0|    @objc public class func containElementSatisfyingMatcher(_ predicate: @escaping ((NSObject) -> Bool)) -> NMBPredicate {
   33|      0|        return NMBPredicate { actualExpression in
   34|      0|            let value = try actualExpression.evaluate()
   35|      0|            guard let enumeration = value as? NSFastEnumeration else {
   36|      0|                let message = ExpectationMessage.fail(
   37|      0|                    "containElementSatisfying must be provided an NSFastEnumeration object"
   38|      0|                )
   39|      0|                return NMBPredicateResult(status: .fail, message: message.toObjectiveC())
   40|      0|            }
   41|      0|
   42|      0|            let message = ExpectationMessage
   43|      0|                .expectedTo("find object in collection that satisfies predicate")
   44|      0|                .toObjectiveC()
   45|      0|
   46|      0|            var iterator = NSFastEnumerationIterator(enumeration)
   47|      0|            while let item = iterator.next() {
   48|      0|                guard let object = item as? NSObject else {
   49|      0|                    continue
   50|      0|                }
   51|      0|
   52|      0|                if predicate(object) {
   53|      0|                    return NMBPredicateResult(status: .matches, message: message)
   54|      0|                }
   55|      0|            }
   56|      0|
   57|      0|            return NMBPredicateResult(status: .doesNotMatch, message: message)
   58|      0|        }
   59|      0|    }
   60|       |}
   61|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/ElementsEqual.swift:
    1|       |/// A Nimble matcher that succeeds when the actual sequence and the exepected sequence contain the same elements in
    2|       |/// the same order.
    3|       |///
    4|       |/// This is a matcher abstraction for https://developer.apple.com/documentation/swift/sequence/2854213-elementsequal
    5|       |public func elementsEqual<Seq1: Sequence, Seq2: Sequence>(
    6|       |    _ expectedValue: Seq2?
    7|      0|) -> Predicate<Seq1> where Seq1.Element: Equatable, Seq1.Element == Seq2.Element {
    8|      0|    return Predicate.define("elementsEqual <\(stringify(expectedValue))>") { (actualExpression, msg) in
    9|      0|        let actualValue = try actualExpression.evaluate()
   10|      0|        switch (expectedValue, actualValue) {
   11|      0|        case (nil, _?):
   12|      0|            return PredicateResult(status: .fail, message: msg.appendedBeNilHint())
   13|      0|        case (nil, nil), (_, nil):
   14|      0|            return PredicateResult(status: .fail, message: msg)
   15|      0|        case (let expected?, let actual?):
   16|      0|            let matches = expected.elementsEqual(actual)
   17|      0|            return PredicateResult(bool: matches, message: msg)
   18|      0|        }
   19|      0|    }
   20|      0|}
   21|       |
   22|       |/// A Nimble matcher that succeeds when the actual sequence and the exepected sequence contain equivalent elements in
   23|       |/// the same order, using the given predicate as the equivalence test.
   24|       |///
   25|       |/// This is a matcher abstraction for https://developer.apple.com/documentation/swift/sequence/2949668-elementsequal
   26|       |public func elementsEqual<Seq1: Sequence, Seq2: Sequence>(
   27|       |    _ expectedValue: Seq2?,
   28|       |    by areEquivalent: @escaping (Seq1.Element, Seq2.Element) -> Bool
   29|      0|) -> Predicate<Seq1> {
   30|      0|    return Predicate.define("elementsEqual <\(stringify(expectedValue))>") { (actualExpression, msg) in
   31|      0|        let actualValue = try actualExpression.evaluate()
   32|      0|        switch (expectedValue, actualValue) {
   33|      0|        case (nil, _?):
   34|      0|            return PredicateResult(status: .fail, message: msg.appendedBeNilHint())
   35|      0|        case (nil, nil), (_, nil):
   36|      0|            return PredicateResult(status: .fail, message: msg)
   37|      0|        case (let expected?, let actual?):
   38|      0|            let matches = actual.elementsEqual(expected, by: areEquivalent)
   39|      0|            return PredicateResult(bool: matches, message: msg)
   40|      0|        }
   41|      0|    }
   42|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/EndWith.swift:
    1|       |import Foundation
    2|       |
    3|       |/// A Nimble matcher that succeeds when the actual sequence's last element
    4|       |/// is equal to the expected value.
    5|      0|public func endWith<S: Sequence>(_ endingElement: S.Element) -> Predicate<S> where S.Element: Equatable {
    6|      0|    return Predicate.simple("end with <\(endingElement)>") { actualExpression in
    7|      0|        guard let actualValue = try actualExpression.evaluate() else { return .fail }
    8|      0|
    9|      0|        var actualGenerator = actualValue.makeIterator()
   10|      0|        var lastItem: S.Element?
   11|      0|        var item: S.Element?
   12|      0|        repeat {
   13|      0|            lastItem = item
   14|      0|            item = actualGenerator.next()
   15|      0|        } while(item != nil)
   16|      0|
   17|      0|        return PredicateStatus(bool: lastItem == endingElement)
   18|      0|    }
   19|      0|}
   20|       |
   21|       |/// A Nimble matcher that succeeds when the actual collection's last element
   22|       |/// is equal to the expected object.
   23|      0|public func endWith(_ endingElement: Any) -> Predicate<NMBOrderedCollection> {
   24|      0|    return Predicate.simple("end with <\(endingElement)>") { actualExpression in
   25|      0|        guard let collection = try actualExpression.evaluate() else { return .fail }
   26|      0|
   27|      0|        guard collection.count > 0 else { return PredicateStatus(bool: false) }
   28|      0|        #if os(Linux)
   29|      0|            guard let collectionValue = collection.object(at: collection.count - 1) as? NSObject else {
   30|      0|                return .fail
   31|      0|            }
   32|      0|        #else
   33|      0|            let collectionValue = collection.object(at: collection.count - 1) as AnyObject
   34|      0|        #endif
   35|      0|
   36|      0|        return PredicateStatus(bool: collectionValue.isEqual(endingElement))
   37|      0|    }
   38|      0|}
   39|       |
   40|       |/// A Nimble matcher that succeeds when the actual string contains the expected substring
   41|       |/// where the expected substring's location is the actual string's length minus the
   42|       |/// expected substring's length.
   43|      0|public func endWith(_ endingSubstring: String) -> Predicate<String> {
   44|      0|    return Predicate.simple("end with <\(endingSubstring)>") { actualExpression in
   45|      0|        guard let collection = try actualExpression.evaluate() else { return .fail }
   46|      0|
   47|      0|        return PredicateStatus(bool: collection.hasSuffix(endingSubstring))
   48|      0|    }
   49|      0|}
   50|       |
   51|       |#if canImport(Darwin)
   52|       |extension NMBPredicate {
   53|      0|    @objc public class func endWithMatcher(_ expected: Any) -> NMBPredicate {
   54|      0|        return NMBPredicate { actualExpression in
   55|      0|            let actual = try actualExpression.evaluate()
   56|      0|            if actual is String {
   57|      0|                let expr = actualExpression.cast { $0 as? String }
   58|      0|                // swiftlint:disable:next force_cast
   59|      0|                return try endWith(expected as! String).satisfies(expr).toObjectiveC()
   60|      0|            } else {
   61|      0|                let expr = actualExpression.cast { $0 as? NMBOrderedCollection }
   62|      0|                return try endWith(expected).satisfies(expr).toObjectiveC()
   63|      0|            }
   64|      0|        }
   65|      0|    }
   66|       |}
   67|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/Equal+Tuple.swift:
    1|       |// swiftlint:disable large_tuple vertical_whitespace
    2|       |
    3|       |// MARK: Tuple2
    4|       |
    5|       |/// A Nimble matcher that succeeds when the actual tuple is equal to the expected tuple.
    6|       |/// Values can support equal by supporting the Equatable protocol.
    7|       |public func equal<T1: Equatable, T2: Equatable>(
    8|       |    _ expectedValue: (T1, T2)?
    9|      0|) -> Predicate<(T1, T2)> {
   10|      0|    equal(expectedValue, by: ==)
   11|      0|}
   12|       |
   13|       |public func ==<T1: Equatable, T2: Equatable>(
   14|       |    lhs: Expectation<(T1, T2)>,
   15|       |    rhs: (T1, T2)?
   16|      0|) {
   17|      0|    lhs.to(equal(rhs))
   18|      0|}
   19|       |
   20|       |public func !=<T1: Equatable, T2: Equatable>(
   21|       |    lhs: Expectation<(T1, T2)>,
   22|       |    rhs: (T1, T2)?
   23|      0|) {
   24|      0|    lhs.toNot(equal(rhs))
   25|      0|}
   26|       |
   27|       |
   28|       |// MARK: Tuple3
   29|       |
   30|       |/// A Nimble matcher that succeeds when the actual tuple is equal to the expected tuple.
   31|       |/// Values can support equal by supporting the Equatable protocol.
   32|       |public func equal<T1: Equatable, T2: Equatable, T3: Equatable>(
   33|       |    _ expectedValue: (T1, T2, T3)?
   34|      0|) -> Predicate<(T1, T2, T3)> {
   35|      0|    equal(expectedValue, by: ==)
   36|      0|}
   37|       |
   38|       |public func ==<T1: Equatable, T2: Equatable, T3: Equatable>(
   39|       |    lhs: Expectation<(T1, T2, T3)>,
   40|       |    rhs: (T1, T2, T3)?
   41|      0|) {
   42|      0|    lhs.to(equal(rhs))
   43|      0|}
   44|       |
   45|       |public func !=<T1: Equatable, T2: Equatable, T3: Equatable>(
   46|       |    lhs: Expectation<(T1, T2, T3)>,
   47|       |    rhs: (T1, T2, T3)?
   48|      0|) {
   49|      0|    lhs.toNot(equal(rhs))
   50|      0|}
   51|       |
   52|       |
   53|       |// MARK: Tuple4
   54|       |
   55|       |/// A Nimble matcher that succeeds when the actual tuple is equal to the expected tuple.
   56|       |/// Values can support equal by supporting the Equatable protocol.
   57|       |public func equal<T1: Equatable, T2: Equatable, T3: Equatable, T4: Equatable>(
   58|       |    _ expectedValue: (T1, T2, T3, T4)?
   59|      0|) -> Predicate<(T1, T2, T3, T4)> {
   60|      0|    equal(expectedValue, by: ==)
   61|      0|}
   62|       |
   63|       |public func ==<T1: Equatable, T2: Equatable, T3: Equatable, T4: Equatable>(
   64|       |    lhs: Expectation<(T1, T2, T3, T4)>,
   65|       |    rhs: (T1, T2, T3, T4)?
   66|      0|) {
   67|      0|    lhs.to(equal(rhs))
   68|      0|}
   69|       |
   70|       |public func !=<T1: Equatable, T2: Equatable, T3: Equatable, T4: Equatable>(
   71|       |    lhs: Expectation<(T1, T2, T3, T4)>,
   72|       |    rhs: (T1, T2, T3, T4)?
   73|      0|) {
   74|      0|    lhs.toNot(equal(rhs))
   75|      0|}
   76|       |
   77|       |
   78|       |// MARK: Tuple5
   79|       |
   80|       |/// A Nimble matcher that succeeds when the actual tuple is equal to the expected tuple.
   81|       |/// Values can support equal by supporting the Equatable protocol.
   82|       |public func equal<T1: Equatable, T2: Equatable, T3: Equatable, T4: Equatable, T5: Equatable>(
   83|       |    _ expectedValue: (T1, T2, T3, T4, T5)?
   84|      0|) -> Predicate<(T1, T2, T3, T4, T5)> {
   85|      0|    equal(expectedValue, by: ==)
   86|      0|}
   87|       |
   88|       |public func ==<T1: Equatable, T2: Equatable, T3: Equatable, T4: Equatable, T5: Equatable>(
   89|       |    lhs: Expectation<(T1, T2, T3, T4, T5)>,
   90|       |    rhs: (T1, T2, T3, T4, T5)?
   91|      0|) {
   92|      0|    lhs.to(equal(rhs))
   93|      0|}
   94|       |
   95|       |public func !=<T1: Equatable, T2: Equatable, T3: Equatable, T4: Equatable, T5: Equatable>(
   96|       |    lhs: Expectation<(T1, T2, T3, T4, T5)>,
   97|       |    rhs: (T1, T2, T3, T4, T5)?
   98|      0|) {
   99|      0|    lhs.toNot(equal(rhs))
  100|      0|}
  101|       |
  102|       |
  103|       |// MARK: Tuple6
  104|       |
  105|       |/// A Nimble matcher that succeeds when the actual tuple is equal to the expected tuple.
  106|       |/// Values can support equal by supporting the Equatable protocol.
  107|       |public func equal<T1: Equatable, T2: Equatable, T3: Equatable, T4: Equatable, T5: Equatable, T6: Equatable>(
  108|       |    _ expectedValue: (T1, T2, T3, T4, T5, T6)?
  109|      0|) -> Predicate<(T1, T2, T3, T4, T5, T6)> {
  110|      0|    equal(expectedValue, by: ==)
  111|      0|}
  112|       |
  113|       |public func ==<T1: Equatable, T2: Equatable, T3: Equatable, T4: Equatable, T5: Equatable, T6: Equatable>(
  114|       |    lhs: Expectation<(T1, T2, T3, T4, T5, T6)>,
  115|       |    rhs: (T1, T2, T3, T4, T5, T6)?
  116|      0|) {
  117|      0|    lhs.to(equal(rhs))
  118|      0|}
  119|       |
  120|       |public func !=<T1: Equatable, T2: Equatable, T3: Equatable, T4: Equatable, T5: Equatable, T6: Equatable>(
  121|       |    lhs: Expectation<(T1, T2, T3, T4, T5, T6)>,
  122|       |    rhs: (T1, T2, T3, T4, T5, T6)?
  123|      0|) {
  124|      0|    lhs.toNot(equal(rhs))
  125|      0|}
  126|       |
  127|       |// swiftlint:enable large_tuple vertical_whitespace

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/Equal.swift:
    1|       |internal func equal<T>(
    2|       |    _ expectedValue: T?,
    3|       |    by areEquivalent: @escaping (T, T) -> Bool
    4|     17|) -> Predicate<T> {
    5|     17|    return Predicate.define("equal <\(stringify(expectedValue))>") { actualExpression, msg in
    6|     17|        let actualValue = try actualExpression.evaluate()
    7|     17|        switch (expectedValue, actualValue) {
    8|      0|        case (nil, _?):
    9|      0|            return PredicateResult(status: .fail, message: msg.appendedBeNilHint())
   10|      0|        case (_, nil):
   11|      0|            return PredicateResult(status: .fail, message: msg)
   12|     17|        case (let expected?, let actual?):
   13|     17|            let matches = areEquivalent(expected, actual)
   14|     17|            return PredicateResult(bool: matches, message: msg)
   15|     17|        }
   16|     17|    }
   17|     17|}
   18|       |
   19|       |/// A Nimble matcher that succeeds when the actual value is equal to the expected value.
   20|       |/// Values can support equal by supporting the Equatable protocol.
   21|       |///
   22|       |/// @see beCloseTo if you want to match imprecise types (eg - floats, doubles).
   23|     17|public func equal<T: Equatable>(_ expectedValue: T?) -> Predicate<T> {
   24|     34|    equal(expectedValue, by: ==)
  ------------------
  | $s6Nimble5equalyAA9PredicateVyxGxSgSQRzlFSbx_xtcxmcfu_:
  |   24|     17|    equal(expectedValue, by: ==)
  ------------------
  | $s6Nimble5equalyAA9PredicateVyxGxSgSQRzlFSbx_xtcxmcfu_Sbx_xtcfu0_:
  |   24|     17|    equal(expectedValue, by: ==)
  ------------------
   25|     17|}
   26|       |
   27|       |/// A Nimble matcher allowing comparison of collection with optional type
   28|      0|public func equal<T: Equatable>(_ expectedValue: [T?]) -> Predicate<[T?]> {
   29|      0|    return Predicate.define("equal <\(stringify(expectedValue))>") { actualExpression, msg in
   30|      0|        guard let actualValue = try actualExpression.evaluate() else {
   31|      0|            return PredicateResult(
   32|      0|                status: .fail,
   33|      0|                message: msg.appendedBeNilHint()
   34|      0|            )
   35|      0|        }
   36|      0|
   37|      0|        let matches = expectedValue == actualValue
   38|      0|        return PredicateResult(bool: matches, message: msg)
   39|      0|    }
   40|      0|}
   41|       |
   42|       |/// A Nimble matcher that succeeds when the actual set is equal to the expected set.
   43|      0|public func equal<T>(_ expectedValue: Set<T>?) -> Predicate<Set<T>> {
   44|      0|    return equal(expectedValue, stringify: { stringify($0) })
   45|      0|}
   46|       |
   47|       |/// A Nimble matcher that succeeds when the actual set is equal to the expected set.
   48|      0|public func equal<T: Comparable>(_ expectedValue: Set<T>?) -> Predicate<Set<T>> {
   49|      0|    return equal(expectedValue, stringify: {
   50|      0|        if let set = $0 {
   51|      0|            return stringify(Array(set).sorted { $0 < $1 })
   52|      0|        } else {
   53|      0|            return "nil"
   54|      0|        }
   55|      0|    })
   56|      0|}
   57|       |
   58|      0|private func equal<T>(_ expectedValue: Set<T>?, stringify: @escaping (Set<T>?) -> String) -> Predicate<Set<T>> {
   59|      0|    return Predicate { actualExpression in
   60|      0|        var errorMessage: ExpectationMessage =
   61|      0|            .expectedActualValueTo("equal <\(stringify(expectedValue))>")
   62|      0|
   63|      0|        guard let expectedValue = expectedValue else {
   64|      0|            return PredicateResult(
   65|      0|                status: .fail,
   66|      0|                message: errorMessage.appendedBeNilHint()
   67|      0|            )
   68|      0|        }
   69|      0|
   70|      0|        guard let actualValue = try actualExpression.evaluate() else {
   71|      0|            return PredicateResult(
   72|      0|                status: .fail,
   73|      0|                message: errorMessage.appendedBeNilHint()
   74|      0|            )
   75|      0|        }
   76|      0|
   77|      0|        errorMessage = .expectedCustomValueTo(
   78|      0|            "equal <\(stringify(expectedValue))>",
   79|      0|            actual: "<\(stringify(actualValue))>"
   80|      0|        )
   81|      0|
   82|      0|        if expectedValue == actualValue {
   83|      0|            return PredicateResult(
   84|      0|                status: .matches,
   85|      0|                message: errorMessage
   86|      0|            )
   87|      0|        }
   88|      0|
   89|      0|        let missing = expectedValue.subtracting(actualValue)
   90|      0|        if missing.count > 0 {
   91|      0|            errorMessage = errorMessage.appended(message: ", missing <\(stringify(missing))>")
   92|      0|        }
   93|      0|
   94|      0|        let extra = actualValue.subtracting(expectedValue)
   95|      0|        if extra.count > 0 {
   96|      0|            errorMessage = errorMessage.appended(message: ", extra <\(stringify(extra))>")
   97|      0|        }
   98|      0|        return  PredicateResult(
   99|      0|            status: .doesNotMatch,
  100|      0|            message: errorMessage
  101|      0|        )
  102|      0|    }
  103|      0|}
  104|       |
  105|      0|public func ==<T: Equatable>(lhs: Expectation<T>, rhs: T?) {
  106|      0|    lhs.to(equal(rhs))
  107|      0|}
  108|       |
  109|      0|public func !=<T: Equatable>(lhs: Expectation<T>, rhs: T?) {
  110|      0|    lhs.toNot(equal(rhs))
  111|      0|}
  112|       |
  113|      0|public func ==<T: Equatable>(lhs: Expectation<[T]>, rhs: [T]?) {
  114|      0|    lhs.to(equal(rhs))
  115|      0|}
  116|       |
  117|      0|public func !=<T: Equatable>(lhs: Expectation<[T]>, rhs: [T]?) {
  118|      0|    lhs.toNot(equal(rhs))
  119|      0|}
  120|       |
  121|      0|public func == <T>(lhs: Expectation<Set<T>>, rhs: Set<T>?) {
  122|      0|    lhs.to(equal(rhs))
  123|      0|}
  124|       |
  125|      0|public func != <T>(lhs: Expectation<Set<T>>, rhs: Set<T>?) {
  126|      0|    lhs.toNot(equal(rhs))
  127|      0|}
  128|       |
  129|      0|public func ==<T: Comparable>(lhs: Expectation<Set<T>>, rhs: Set<T>?) {
  130|      0|    lhs.to(equal(rhs))
  131|      0|}
  132|       |
  133|      0|public func !=<T: Comparable>(lhs: Expectation<Set<T>>, rhs: Set<T>?) {
  134|      0|    lhs.toNot(equal(rhs))
  135|      0|}
  136|       |
  137|      0|public func ==<T, C: Equatable>(lhs: Expectation<[T: C]>, rhs: [T: C]?) {
  138|      0|    lhs.to(equal(rhs))
  139|      0|}
  140|       |
  141|      0|public func !=<T, C: Equatable>(lhs: Expectation<[T: C]>, rhs: [T: C]?) {
  142|      0|    lhs.toNot(equal(rhs))
  143|      0|}
  144|       |
  145|       |#if canImport(Darwin)
  146|       |import class Foundation.NSObject
  147|       |
  148|       |extension NMBPredicate {
  149|      0|    @objc public class func equalMatcher(_ expected: NSObject) -> NMBPredicate {
  150|      0|        return NMBPredicate { actualExpression in
  151|      0|            return try equal(expected).satisfies(actualExpression).toObjectiveC()
  152|      0|        }
  153|      0|    }
  154|       |}
  155|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/HaveCount.swift:
    1|       |// The `haveCount` matchers do not print the full string representation of the collection value,
    2|       |// instead they only print the type name and the expected count. This makes it easier to understand
    3|       |// the reason for failed expectations. See: https://github.com/Quick/Nimble/issues/308.
    4|       |// The representation of the collection content is provided in a new line as an `extendedMessage`.
    5|       |
    6|       |/// A Nimble matcher that succeeds when the actual Collection's count equals
    7|       |/// the expected value
    8|      0|public func haveCount<T: Collection>(_ expectedValue: Int) -> Predicate<T> {
    9|      0|    return Predicate.define { actualExpression in
   10|      0|        if let actualValue = try actualExpression.evaluate() {
   11|      0|            let message = ExpectationMessage
   12|      0|                .expectedCustomValueTo(
   13|      0|                    "have \(prettyCollectionType(actualValue)) with count \(stringify(expectedValue))",
   14|      0|                    actual: "\(actualValue.count)"
   15|      0|                )
   16|      0|                .appended(details: "Actual Value: \(stringify(actualValue))")
   17|      0|
   18|      0|            let result = expectedValue == actualValue.count
   19|      0|            return PredicateResult(bool: result, message: message)
   20|      0|        } else {
   21|      0|            return PredicateResult(status: .fail, message: .fail(""))
   22|      0|        }
   23|      0|    }
   24|      0|}
   25|       |
   26|       |/// A Nimble matcher that succeeds when the actual collection's count equals
   27|       |/// the expected value
   28|      0|public func haveCount(_ expectedValue: Int) -> Predicate<NMBCollection> {
   29|      0|    return Predicate { actualExpression in
   30|      0|        if let actualValue = try actualExpression.evaluate() {
   31|      0|            let message = ExpectationMessage
   32|      0|                .expectedCustomValueTo(
   33|      0|                    "have \(prettyCollectionType(actualValue)) with count \(stringify(expectedValue))",
   34|      0|                    actual: "\(actualValue.count)"
   35|      0|                )
   36|      0|                .appended(details: "Actual Value: \(stringify(actualValue))")
   37|      0|
   38|      0|            let result = expectedValue == actualValue.count
   39|      0|            return PredicateResult(bool: result, message: message)
   40|      0|        } else {
   41|      0|            return PredicateResult(status: .fail, message: .fail(""))
   42|      0|        }
   43|      0|    }
   44|      0|}
   45|       |
   46|       |#if canImport(Darwin)
   47|       |import Foundation
   48|       |
   49|       |extension NMBPredicate {
   50|      0|    @objc public class func haveCountMatcher(_ expected: NSNumber) -> NMBPredicate {
   51|      0|        return NMBPredicate { actualExpression in
   52|      0|            let location = actualExpression.location
   53|      0|            let actualValue = try actualExpression.evaluate()
   54|      0|            if let value = actualValue as? NMBCollection {
   55|      0|                let expr = Expression(expression: ({ value as NMBCollection}), location: location)
   56|      0|                return try haveCount(expected.intValue).satisfies(expr).toObjectiveC()
   57|      0|            }
   58|      0|
   59|      0|            let message: ExpectationMessage
   60|      0|            if let actualValue = actualValue {
   61|      0|                message = ExpectationMessage.expectedCustomValueTo(
   62|      0|                    "get type of NSArray, NSSet, NSDictionary, or NSHashTable",
   63|      0|                    actual: "\(String(describing: type(of: actualValue)))"
   64|      0|                )
   65|      0|            } else {
   66|      0|                message = ExpectationMessage
   67|      0|                    .expectedActualValueTo("have a collection with count \(stringify(expected.intValue))")
   68|      0|                    .appendedBeNilHint()
   69|      0|            }
   70|      0|            return NMBPredicateResult(status: .fail, message: message.toObjectiveC())
   71|      0|        }
   72|      0|    }
   73|       |}
   74|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/Match.swift:
    1|       |/// A Nimble matcher that succeeds when the actual string satisfies the regular expression
    2|       |/// described by the expected string.
    3|      0|public func match(_ expectedValue: String?) -> Predicate<String> {
    4|      0|    return Predicate.simple("match <\(stringify(expectedValue))>") { actualExpression in
    5|      0|        guard let actual = try actualExpression.evaluate(), let regexp = expectedValue else { return .fail }
    6|      0|
    7|      0|        let bool = actual.range(of: regexp, options: .regularExpression) != nil
    8|      0|        return PredicateStatus(bool: bool)
    9|      0|    }
   10|      0|}
   11|       |
   12|       |#if canImport(Darwin)
   13|       |import class Foundation.NSString
   14|       |
   15|       |extension NMBPredicate {
   16|      0|    @objc public class func matchMatcher(_ expected: NSString) -> NMBPredicate {
   17|      0|        return NMBPredicate { actualExpression in
   18|      0|            let actual = actualExpression.cast { $0 as? String }
   19|      0|            return try match(expected.description).satisfies(actual).toObjectiveC()
   20|      0|        }
   21|      0|    }
   22|       |}
   23|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/MatchError.swift:
    1|       |/// A Nimble matcher that succeeds when the actual expression evaluates to an
    2|       |/// error from the specified case.
    3|       |///
    4|       |/// Errors are tried to be compared by their implementation of Equatable,
    5|       |/// otherwise they fallback to comparison by _domain and _code.
    6|      0|public func matchError<T: Error>(_ error: T) -> Predicate<Error> {
    7|      0|    return Predicate.define { actualExpression in
    8|      0|        let actualError = try actualExpression.evaluate()
    9|      0|
   10|      0|        let message = messageForError(
   11|      0|            postfixMessageVerb: "match",
   12|      0|            actualError: actualError,
   13|      0|            error: error
   14|      0|        )
   15|      0|
   16|      0|        var matches = false
   17|      0|        if let actualError = actualError, errorMatchesExpectedError(actualError, expectedError: error) {
   18|      0|            matches = true
   19|      0|        }
   20|      0|
   21|      0|        return PredicateResult(bool: matches, message: message)
   22|      0|    }
   23|      0|}
   24|       |
   25|       |/// A Nimble matcher that succeeds when the actual expression evaluates to an
   26|       |/// error from the specified case.
   27|       |///
   28|       |/// Errors are tried to be compared by their implementation of Equatable,
   29|       |/// otherwise they fallback to comparision by _domain and _code.
   30|      0|public func matchError<T: Error & Equatable>(_ error: T) -> Predicate<Error> {
   31|      0|    return Predicate.define { actualExpression in
   32|      0|        let actualError = try actualExpression.evaluate()
   33|      0|
   34|      0|        let message = messageForError(
   35|      0|            postfixMessageVerb: "match",
   36|      0|            actualError: actualError,
   37|      0|            error: error
   38|      0|        )
   39|      0|
   40|      0|        var matches = false
   41|      0|        if let actualError = actualError as? T, error == actualError {
   42|      0|            matches = true
   43|      0|        }
   44|      0|
   45|      0|        return PredicateResult(bool: matches, message: message)
   46|      0|    }
   47|      0|}
   48|       |
   49|       |/// A Nimble matcher that succeeds when the actual expression evaluates to an
   50|       |/// error of the specified type
   51|      0|public func matchError<T: Error>(_ errorType: T.Type) -> Predicate<Error> {
   52|      0|    return Predicate.define { actualExpression in
   53|      0|        let actualError = try actualExpression.evaluate()
   54|      0|
   55|      0|        let message = messageForError(
   56|      0|            postfixMessageVerb: "match",
   57|      0|            actualError: actualError,
   58|      0|            errorType: errorType
   59|      0|        )
   60|      0|
   61|      0|        var matches = false
   62|      0|        if actualError as? T != nil {
   63|      0|            matches = true
   64|      0|        }
   65|      0|
   66|      0|        return PredicateResult(bool: matches, message: message)
   67|      0|    }
   68|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/MatcherFunc.swift:
    1|       |/// DEPRECATED: A convenience API to build matchers that don't need special negation
    2|       |/// behavior. The toNot() behavior is the negation of to().
    3|       |///
    4|       |/// @see NonNilMatcherFunc if you prefer to have this matcher fail when nil
    5|       |///                        values are received in an expectation.
    6|       |///
    7|       |/// You may use this when implementing your own custom matchers.
    8|       |///
    9|       |/// Use the Matcher protocol instead of this type to accept custom matchers as
   10|       |/// input parameters.
   11|       |/// @see allPass for an example that uses accepts other matchers as input.
   12|       |@available(*, deprecated, message: "Use Predicate instead")
   13|       |public struct MatcherFunc<T>: Matcher {
   14|       |    public let matcher: (Expression<T>, FailureMessage) throws -> Bool
   15|       |
   16|      0|    public init(_ matcher: @escaping (Expression<T>, FailureMessage) throws -> Bool) {
   17|      0|        self.matcher = matcher
   18|      0|    }
   19|       |
   20|      0|    public func matches(_ actualExpression: Expression<T>, failureMessage: FailureMessage) throws -> Bool {
   21|      0|        return try matcher(actualExpression, failureMessage)
   22|      0|    }
   23|       |
   24|      0|    public func doesNotMatch(_ actualExpression: Expression<T>, failureMessage: FailureMessage) throws -> Bool {
   25|      0|        return try !matcher(actualExpression, failureMessage)
   26|      0|    }
   27|       |
   28|       |    /// Compatibility layer to new Matcher API. Converts an old-style matcher to a new one.
   29|       |    /// Note: You should definitely spend the time to convert to the new api as soon as possible
   30|       |    /// since this struct type is deprecated.
   31|       |    @available(*, deprecated, message: "Use Predicate directly instead")
   32|      0|    public var predicate: Predicate<T> {
   33|      0|        return Predicate.fromDeprecatedMatcher(self)
   34|      0|    }
   35|       |}
   36|       |
   37|       |/// DEPRECATED: A convenience API to build matchers that don't need special negation
   38|       |/// behavior. The toNot() behavior is the negation of to().
   39|       |///
   40|       |/// Unlike MatcherFunc, this will always fail if an expectation contains nil.
   41|       |/// This applies regardless of using to() or toNot().
   42|       |///
   43|       |/// You may use this when implementing your own custom matchers.
   44|       |///
   45|       |/// Use the Matcher protocol instead of this type to accept custom matchers as
   46|       |/// input parameters.
   47|       |/// @see allPass for an example that uses accepts other matchers as input.
   48|       |@available(*, deprecated, message: "Use Predicate instead")
   49|       |public struct NonNilMatcherFunc<T>: Matcher {
   50|       |    public let matcher: (Expression<T>, FailureMessage) throws -> Bool
   51|       |
   52|      0|    public init(_ matcher: @escaping (Expression<T>, FailureMessage) throws -> Bool) {
   53|      0|        self.matcher = matcher
   54|      0|    }
   55|       |
   56|      0|    public func matches(_ actualExpression: Expression<T>, failureMessage: FailureMessage) throws -> Bool {
   57|      0|        let pass = try matcher(actualExpression, failureMessage)
   58|      0|        if try attachNilErrorIfNeeded(actualExpression, failureMessage: failureMessage) {
   59|      0|            return false
   60|      0|        }
   61|      0|        return pass
   62|      0|    }
   63|       |
   64|      0|    public func doesNotMatch(_ actualExpression: Expression<T>, failureMessage: FailureMessage) throws -> Bool {
   65|      0|        let pass = try !matcher(actualExpression, failureMessage)
   66|      0|        if try attachNilErrorIfNeeded(actualExpression, failureMessage: failureMessage) {
   67|      0|            return false
   68|      0|        }
   69|      0|        return pass
   70|      0|    }
   71|       |
   72|      0|    internal func attachNilErrorIfNeeded(_ actualExpression: Expression<T>, failureMessage: FailureMessage) throws -> Bool {
   73|      0|        if try actualExpression.evaluate() == nil {
   74|      0|            failureMessage.postfixActual = " (use beNil() to match nils)"
   75|      0|            return true
   76|      0|        }
   77|      0|        return false
   78|      0|    }
   79|       |
   80|       |    /// Compatibility layer to new Matcher API. Converts an old-style matcher to a new one.
   81|       |    /// Note: You should definitely spend the time to convert to the new api as soon as possible
   82|       |    /// since this struct type is deprecated.
   83|       |    @available(*, deprecated, message: "Use Predicate directly instead")
   84|      0|    public var predicate: Predicate<T> {
   85|      0|        return Predicate.fromDeprecatedMatcher(self)
   86|      0|    }
   87|       |}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/MatcherProtocols.swift:
    1|       |import Foundation
    2|       |// `CGFloat` is in Foundation (swift-corelibs-foundation) on Linux.
    3|       |#if canImport(Darwin)
    4|       |    import CoreGraphics
    5|       |#endif
    6|       |
    7|       |/// Implement this protocol to implement a custom matcher for Swift
    8|       |@available(*, deprecated, message: "Use Predicate instead")
    9|       |public protocol Matcher {
   10|       |    associatedtype ValueType
   11|       |    func matches(_ actualExpression: Expression<ValueType>, failureMessage: FailureMessage) throws -> Bool
   12|       |    func doesNotMatch(_ actualExpression: Expression<ValueType>, failureMessage: FailureMessage) throws -> Bool
   13|       |}
   14|       |
   15|       |@available(*, deprecated)
   16|       |extension Matcher {
   17|      0|    var predicate: Predicate<ValueType> {
   18|      0|        return Predicate.fromDeprecatedMatcher(self)
   19|      0|    }
   20|       |
   21|      0|    var toClosure: (Expression<ValueType>, FailureMessage, Bool) throws -> Bool {
   22|      0|        return { expr, msg, expectedResult in
   23|      0|            if expectedResult {
   24|      0|                return try self.matches(expr, failureMessage: msg)
   25|      0|            } else {
   26|      0|                return try self.doesNotMatch(expr, failureMessage: msg)
   27|      0|            }
   28|      0|        }
   29|      0|    }
   30|       |}
   31|       |
   32|       |#if canImport(Darwin)
   33|       |/// Objective-C interface to the Swift variant of Matcher.
   34|       |@objc public protocol NMBMatcher {
   35|       |    func matches(_ actualBlock: @escaping () -> NSObject?, failureMessage: FailureMessage, location: SourceLocation) -> Bool
   36|       |    func doesNotMatch(_ actualBlock: @escaping () -> NSObject?, failureMessage: FailureMessage, location: SourceLocation) -> Bool
   37|       |}
   38|       |#endif
   39|       |
   40|       |/// Protocol for types that support contain() matcher.
   41|       |public protocol NMBContainer {
   42|       |    func contains(_ anObject: Any) -> Bool
   43|       |}
   44|       |
   45|       |#if canImport(Darwin)
   46|       |// swiftlint:disable:next todo
   47|       |// FIXME: NSHashTable can not conform to NMBContainer since swift-DEVELOPMENT-SNAPSHOT-2016-04-25-a
   48|       |// extension NSHashTable : NMBContainer {} // Corelibs Foundation does not include this class yet
   49|       |#endif
   50|       |
   51|       |extension NSArray: NMBContainer {}
   52|       |extension NSSet: NMBContainer {}
   53|       |
   54|       |/// Protocol for types that support only beEmpty(), haveCount() matchers
   55|       |public protocol NMBCollection {
   56|       |    var count: Int { get }
   57|       |}
   58|       |
   59|       |#if canImport(Darwin)
   60|       |extension NSHashTable: NMBCollection {} // Corelibs Foundation does not include these classes yet
   61|       |extension NSMapTable: NMBCollection {}
   62|       |#endif
   63|       |
   64|       |extension NSSet: NMBCollection {}
   65|       |extension NSIndexSet: NMBCollection {}
   66|       |extension NSDictionary: NMBCollection {}
   67|       |
   68|       |/// Protocol for types that support beginWith(), endWith(), beEmpty() matchers
   69|       |public protocol NMBOrderedCollection: NMBCollection {
   70|       |    func object(at index: Int) -> Any
   71|       |}
   72|       |
   73|       |extension NSArray: NMBOrderedCollection {}
   74|       |
   75|       |public protocol NMBDoubleConvertible {
   76|       |    var doubleValue: CDouble { get }
   77|       |}
   78|       |
   79|       |extension Double: NMBDoubleConvertible {
   80|      0|    public var doubleValue: CDouble {
   81|      0|        return self
   82|      0|    }
   83|       |}
   84|       |
   85|       |extension Float: NMBDoubleConvertible {
   86|      0|    public var doubleValue: CDouble {
   87|      0|        return CDouble(self)
   88|      0|    }
   89|       |}
   90|       |
   91|       |extension CGFloat: NMBDoubleConvertible {
   92|      0|    public var doubleValue: CDouble {
   93|      0|        return CDouble(self)
   94|      0|    }
   95|       |}
   96|       |
   97|       |extension NSNumber: NMBDoubleConvertible {
   98|       |}
   99|       |
  100|      0|private let dateFormatter: DateFormatter = {
  101|      0|    let formatter = DateFormatter()
  102|      0|    formatter.dateFormat = "yyyy-MM-dd HH:mm:ss.SSSS"
  103|      0|    formatter.locale = Locale(identifier: "en_US_POSIX")
  104|      0|
  105|      0|    return formatter
  106|      0|}()
  107|       |
  108|       |extension Date: NMBDoubleConvertible {
  109|      0|    public var doubleValue: CDouble {
  110|      0|        return self.timeIntervalSinceReferenceDate
  111|      0|    }
  112|       |}
  113|       |
  114|       |extension NSDate: NMBDoubleConvertible {
  115|      0|    public var doubleValue: CDouble {
  116|      0|        return self.timeIntervalSinceReferenceDate
  117|      0|    }
  118|       |}
  119|       |
  120|       |extension Date: TestOutputStringConvertible {
  121|      0|    public var testDescription: String {
  122|      0|        return dateFormatter.string(from: self)
  123|      0|    }
  124|       |}
  125|       |
  126|       |extension NSDate: TestOutputStringConvertible {
  127|      0|    public var testDescription: String {
  128|      0|        return dateFormatter.string(from: Date(timeIntervalSinceReferenceDate: self.timeIntervalSinceReferenceDate))
  129|      0|    }
  130|       |}
  131|       |
  132|       |#if canImport(Darwin)
  133|       |/// Protocol for types to support beLessThan(), beLessThanOrEqualTo(),
  134|       |///  beGreaterThan(), beGreaterThanOrEqualTo(), and equal() matchers.
  135|       |///
  136|       |/// Types that conform to Swift's Comparable protocol will work implicitly too
  137|       |@objc public protocol NMBComparable {
  138|       |    func NMB_compare(_ otherObject: NMBComparable!) -> ComparisonResult
  139|       |}
  140|       |
  141|       |extension NSNumber: NMBComparable {
  142|      0|    public func NMB_compare(_ otherObject: NMBComparable!) -> ComparisonResult {
  143|      0|        // swiftlint:disable:next force_cast
  144|      0|        return compare(otherObject as! NSNumber)
  145|      0|    }
  146|       |}
  147|       |extension NSString: NMBComparable {
  148|      0|    public func NMB_compare(_ otherObject: NMBComparable!) -> ComparisonResult {
  149|      0|        // swiftlint:disable:next force_cast
  150|      0|        return compare(otherObject as! String)
  151|      0|    }
  152|       |}
  153|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/PostNotification.swift:
    1|       |#if canImport(Foundation)
    2|       |import Foundation
    3|       |
    4|       |internal class NotificationCollector {
    5|       |    private(set) var observedNotifications: [Notification]
    6|       |    private let notificationCenter: NotificationCenter
    7|       |    private let names: Set<Notification.Name>
    8|       |    private var tokens: [NSObjectProtocol]
    9|       |
   10|      0|    required init(notificationCenter: NotificationCenter, names: Set<Notification.Name> = []) {
   11|      0|        self.notificationCenter = notificationCenter
   12|      0|        self.observedNotifications = []
   13|      0|        self.names = names
   14|      0|        self.tokens = []
   15|      0|    }
   16|       |
   17|      0|    func startObserving() {
   18|      0|        func addObserver(forName name: Notification.Name?) -> NSObjectProtocol {
   19|      0|            return notificationCenter.addObserver(forName: name, object: nil, queue: nil) { [weak self] notification in
   20|      0|                // linux-swift gets confused by .append(n)
   21|      0|                self?.observedNotifications.append(notification)
   22|      0|            }
   23|      0|        }
   24|      0|
   25|      0|        if names.isEmpty {
   26|      0|            tokens.append(addObserver(forName: nil))
   27|      0|        } else {
   28|      0|            names.forEach { name in
   29|      0|                tokens.append(addObserver(forName: name))
   30|      0|            }
   31|      0|        }
   32|      0|    }
   33|       |
   34|      0|    deinit {
   35|      0|        tokens.forEach { token in
   36|      0|            notificationCenter.removeObserver(token)
   37|      0|        }
   38|      0|    }
   39|       |}
   40|       |
   41|       |private let mainThread = pthread_self()
   42|       |
   43|       |private func _postNotifications<Out>(
   44|       |    _ predicate: Predicate<[Notification]>,
   45|       |    from center: NotificationCenter,
   46|       |    names: Set<Notification.Name> = []
   47|      0|) -> Predicate<Out> {
   48|      0|    _ = mainThread // Force lazy-loading of this value
   49|      0|    let collector = NotificationCollector(notificationCenter: center, names: names)
   50|      0|    collector.startObserving()
   51|      0|    var once: Bool = false
   52|      0|
   53|      0|    return Predicate { actualExpression in
   54|      0|        let collectorNotificationsExpression = Expression(
   55|      0|            memoizedExpression: { _ in
   56|      0|                return collector.observedNotifications
   57|      0|            },
   58|      0|            location: actualExpression.location,
   59|      0|            withoutCaching: true
   60|      0|        )
   61|      0|
   62|      0|        assert(pthread_equal(mainThread, pthread_self()) != 0, "Only expecting closure to be evaluated on main thread.")
   63|      0|        if !once {
   64|      0|            once = true
   65|      0|            _ = try actualExpression.evaluate()
   66|      0|        }
   67|      0|
   68|      0|        let actualValue: String
   69|      0|        if collector.observedNotifications.isEmpty {
   70|      0|            actualValue = "no notifications"
   71|      0|        } else {
   72|      0|            actualValue = "<\(stringify(collector.observedNotifications))>"
   73|      0|        }
   74|      0|
   75|      0|        var result = try predicate.satisfies(collectorNotificationsExpression)
   76|      0|        result.message = result.message.replacedExpectation { message in
   77|      0|            return .expectedCustomValueTo(message.expectedMessage, actual: actualValue)
   78|      0|        }
   79|      0|        return result
   80|      0|    }
   81|      0|}
   82|       |
   83|       |public func postNotifications<Out>(
   84|       |    _ predicate: Predicate<[Notification]>,
   85|       |    from center: NotificationCenter = .default
   86|      0|) -> Predicate<Out> {
   87|      0|    _postNotifications(predicate, from: center)
   88|      0|}
   89|       |
   90|       |@available(*, deprecated, renamed: "postNotifications(_:from:)")
   91|       |public func postNotifications<Out>(
   92|       |    _ predicate: Predicate<[Notification]>,
   93|       |    fromNotificationCenter center: NotificationCenter
   94|      0|) -> Predicate<Out> {
   95|      0|    postNotifications(predicate, from: center)
   96|      0|}
   97|       |
   98|       |#if os(macOS)
   99|       |public func postDistributedNotifications<Out>(
  100|       |    _ predicate: Predicate<[Notification]>,
  101|       |    from center: DistributedNotificationCenter = .default(),
  102|       |    names: Set<Notification.Name>
  103|       |) -> Predicate<Out> {
  104|       |    _postNotifications(predicate, from: center, names: names)
  105|       |}
  106|       |#endif
  107|       |
  108|       |@available(*, deprecated, message: "Use Predicate instead")
  109|       |public func postNotifications<T>(
  110|       |    _ notificationsMatcher: T,
  111|       |    from center: NotificationCenter = .default
  112|      0|) -> Predicate<Any> where T: Matcher, T.ValueType == [Notification] {
  113|      0|    _ = mainThread // Force lazy-loading of this value
  114|      0|    let collector = NotificationCollector(notificationCenter: center)
  115|      0|    collector.startObserving()
  116|      0|    var once: Bool = false
  117|      0|
  118|      0|    return Predicate { actualExpression in
  119|      0|        let collectorNotificationsExpression = Expression(memoizedExpression: { _ in
  120|      0|            return collector.observedNotifications
  121|      0|            }, location: actualExpression.location, withoutCaching: true)
  122|      0|
  123|      0|        assert(pthread_equal(mainThread, pthread_self()) != 0, "Only expecting closure to be evaluated on main thread.")
  124|      0|        if !once {
  125|      0|            once = true
  126|      0|            _ = try actualExpression.evaluate()
  127|      0|        }
  128|      0|
  129|      0|        let failureMessage = FailureMessage()
  130|      0|        let match = try notificationsMatcher.matches(collectorNotificationsExpression, failureMessage: failureMessage)
  131|      0|        if collector.observedNotifications.isEmpty {
  132|      0|            failureMessage.actualValue = "no notifications"
  133|      0|        } else {
  134|      0|            failureMessage.actualValue = "<\(stringify(collector.observedNotifications))>"
  135|      0|        }
  136|      0|        return PredicateResult(bool: match, message: failureMessage.toExpectationMessage())
  137|      0|    }
  138|      0|}
  139|       |
  140|       |@available(*, deprecated, renamed: "postNotifications(_:from:)")
  141|       |public func postNotifications<T>(
  142|       |    _ notificationsMatcher: T,
  143|       |    fromNotificationCenter center: NotificationCenter
  144|      0|) -> Predicate<Any> where T: Matcher, T.ValueType == [Notification] {
  145|      0|    return postNotifications(notificationsMatcher, from: center)
  146|      0|}
  147|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/Predicate.swift:
    1|       |// New Matcher API
    2|       |//
    3|       |
    4|       |/// A Predicate is part of the new matcher API that provides assertions to expectations.
    5|       |///
    6|       |/// Given a code snippet:
    7|       |///
    8|       |///   expect(1).to(equal(2))
    9|       |///                ^^^^^^^^
   10|       |///            Called a "matcher"
   11|       |///
   12|       |/// A matcher consists of two parts a constructor function and the Predicate. The term Predicate
   13|       |/// is used as a separate name from Matcher to help transition custom matchers to the new Nimble
   14|       |/// matcher API.
   15|       |///
   16|       |/// The Predicate provide the heavy lifting on how to assert against a given value. Internally,
   17|       |/// predicates are simple wrappers around closures to provide static type information and
   18|       |/// allow composition and wrapping of existing behaviors.
   19|       |public struct Predicate<T> {
   20|       |    fileprivate var matcher: (Expression<T>) throws -> PredicateResult
   21|       |
   22|       |    /// Constructs a predicate that knows how take a given value
   23|     42|    public init(_ matcher: @escaping (Expression<T>) throws -> PredicateResult) {
   24|     42|        self.matcher = matcher
   25|     42|    }
   26|       |
   27|       |    /// Uses a predicate on a given value to see if it passes the predicate.
   28|       |    ///
   29|       |    /// @param expression The value to run the predicate's logic against
   30|       |    /// @returns A predicate result indicate passing or failing and an associated error message.
   31|     42|    public func satisfies(_ expression: Expression<T>) throws -> PredicateResult {
   32|     42|        return try matcher(expression)
   33|     42|    }
   34|       |}
   35|       |
   36|       |/// Provides convenience helpers to defining predicates
   37|       |extension Predicate {
   38|       |    /// Like Predicate() constructor, but automatically guard against nil (actual) values
   39|      0|    public static func define(matcher: @escaping (Expression<T>) throws -> PredicateResult) -> Predicate<T> {
   40|      0|        return Predicate<T> { actual in
   41|      0|            return try matcher(actual)
   42|      0|        }.requireNonNil
   43|      0|    }
   44|       |
   45|       |    /// Defines a predicate with a default message that can be returned in the closure
   46|       |    /// Also ensures the predicate's actual value cannot pass with `nil` given.
   47|     17|    public static func define(_ message: String = "match", matcher: @escaping (Expression<T>, ExpectationMessage) throws -> PredicateResult) -> Predicate<T> {
   48|     17|        return Predicate<T> { actual in
   49|     17|            return try matcher(actual, .expectedActualValueTo(message))
   50|     17|        }.requireNonNil
   51|     17|    }
   52|       |
   53|       |    /// Defines a predicate with a default message that can be returned in the closure
   54|       |    /// Unlike `define`, this allows nil values to succeed if the given closure chooses to.
   55|      0|    public static func defineNilable(_ message: String = "match", matcher: @escaping (Expression<T>, ExpectationMessage) throws -> PredicateResult) -> Predicate<T> {
   56|      0|        return Predicate<T> { actual in
   57|      0|            return try matcher(actual, .expectedActualValueTo(message))
   58|      0|        }
   59|      0|    }
   60|       |}
   61|       |
   62|       |extension Predicate {
   63|       |    /// Provides a simple predicate definition that provides no control over the predefined
   64|       |    /// error message.
   65|       |    ///
   66|       |    /// Also ensures the predicate's actual value cannot pass with `nil` given.
   67|      0|    public static func simple(_ message: String = "match", matcher: @escaping (Expression<T>) throws -> PredicateStatus) -> Predicate<T> {
   68|      0|        return Predicate<T> { actual in
   69|      0|            return PredicateResult(status: try matcher(actual), message: .expectedActualValueTo(message))
   70|      0|        }.requireNonNil
   71|      0|    }
   72|       |
   73|       |    /// Provides a simple predicate definition that provides no control over the predefined
   74|       |    /// error message.
   75|       |    ///
   76|       |    /// Unlike `simple`, this allows nil values to succeed if the given closure chooses to.
   77|      2|    public static func simpleNilable(_ message: String = "match", matcher: @escaping (Expression<T>) throws -> PredicateStatus) -> Predicate<T> {
   78|      2|        return Predicate<T> { actual in
   79|      2|            return PredicateResult(status: try matcher(actual), message: .expectedActualValueTo(message))
   80|      2|        }
   81|      2|    }
   82|       |}
   83|       |
   84|       |// The Expectation style intended for comparison to a PredicateStatus.
   85|       |public enum ExpectationStyle {
   86|       |    case toMatch, toNotMatch
   87|       |}
   88|       |
   89|       |/// The value that a Predicates return to describe if the given (actual) value matches the
   90|       |/// predicate.
   91|       |public struct PredicateResult {
   92|       |    /// Status indicates if the predicate matches, does not match, or fails.
   93|       |    public var status: PredicateStatus
   94|       |    /// The error message that can be displayed if it does not match
   95|       |    public var message: ExpectationMessage
   96|       |
   97|       |    /// Constructs a new PredicateResult with a given status and error message
   98|      5|    public init(status: PredicateStatus, message: ExpectationMessage) {
   99|      5|        self.status = status
  100|      5|        self.message = message
  101|      5|    }
  102|       |
  103|       |    /// Shorthand to PredicateResult(status: PredicateStatus(bool: bool), message: message)
  104|     17|    public init(bool: Bool, message: ExpectationMessage) {
  105|     17|        self.status = PredicateStatus(bool: bool)
  106|     17|        self.message = message
  107|     17|    }
  108|       |
  109|       |    /// Converts the result to a boolean based on what the expectation intended
  110|     19|    public func toBoolean(expectation style: ExpectationStyle) -> Bool {
  111|     19|        return status.toBoolean(expectation: style)
  112|     19|    }
  113|       |}
  114|       |
  115|       |/// PredicateStatus is a trinary that indicates if a Predicate matches a given value or not
  116|       |public enum PredicateStatus {
  117|       |    /// Matches indicates if the predicate / matcher passes with the given value
  118|       |    ///
  119|       |    /// For example, `equals(1)` returns `.matches` for `expect(1).to(equal(1))`.
  120|       |    case matches
  121|       |    /// DoesNotMatch indicates if the predicate / matcher fails with the given value, but *would*
  122|       |    /// succeed if the expectation was inverted.
  123|       |    ///
  124|       |    /// For example, `equals(2)` returns `.doesNotMatch` for `expect(1).toNot(equal(2))`.
  125|       |    case doesNotMatch
  126|       |    /// Fail indicates the predicate will never satisfy with the given value in any case.
  127|       |    /// A perfect example is that most matchers fail whenever given `nil`.
  128|       |    ///
  129|       |    /// Using `equal(1)` fails both `expect(nil).to(equal(1))` and `expect(nil).toNot(equal(1))`.
  130|       |    /// Note: Predicate's `requireNonNil` property will also provide this feature mostly for free.
  131|       |    ///       Your predicate will still need to guard against nils, but error messaging will be
  132|       |    ///       handled for you.
  133|       |    case fail
  134|       |
  135|       |    /// Converts a boolean to either .matches (if true) or .doesNotMatch (if false).
  136|     19|    public init(bool matches: Bool) {
  137|     19|        if matches {
  138|     19|            self = .matches
  139|     19|        } else {
  140|      0|            self = .doesNotMatch
  141|     19|        }
  142|     19|    }
  143|       |
  144|     19|    private func shouldMatch() -> Bool {
  145|     19|        switch self {
  146|     19|        case .matches: return true
  147|      0|        case .doesNotMatch, .fail: return false
  148|     19|        }
  149|     19|    }
  150|       |
  151|      0|    private func shouldNotMatch() -> Bool {
  152|      0|        switch self {
  153|      0|        case .doesNotMatch: return true
  154|      0|        case .matches, .fail: return false
  155|      0|        }
  156|      0|    }
  157|       |
  158|       |    /// Converts the PredicateStatus result to a boolean based on what the expectation intended
  159|     19|    internal func toBoolean(expectation style: ExpectationStyle) -> Bool {
  160|     19|        if style == .toMatch {
  161|     19|            return shouldMatch()
  162|      0|        } else {
  163|      0|            return shouldNotMatch()
  164|      0|        }
  165|      0|    }
  166|       |}
  167|       |
  168|       |extension Predicate {
  169|       |    /// Compatibility layer for old Matcher API, deprecated.
  170|       |    /// Emulates the MatcherFunc API
  171|      0|    internal static func _fromDeprecatedClosure(_ matcher: @escaping (Expression<T>, FailureMessage) throws -> Bool) -> Predicate {
  172|      0|        return Predicate { actual in
  173|      0|            let failureMessage = FailureMessage()
  174|      0|            let result = try matcher(actual, failureMessage)
  175|      0|            return PredicateResult(
  176|      0|                status: PredicateStatus(bool: result),
  177|      0|                message: failureMessage.toExpectationMessage()
  178|      0|            )
  179|      0|        }
  180|      0|    }
  181|       |}
  182|       |
  183|       |// Backwards compatibility until Old Matcher API removal
  184|       |@available(*, deprecated, message: "Use Predicate directly instead")
  185|       |extension Predicate: Matcher {
  186|       |    /// Compatibility layer for old Matcher API, deprecated
  187|      0|    public static func fromDeprecatedFullClosure(_ matcher: @escaping (Expression<T>, FailureMessage, Bool) throws -> Bool) -> Predicate {
  188|      0|        return Predicate { actual in
  189|      0|            let failureMessage = FailureMessage()
  190|      0|            let result = try matcher(actual, failureMessage, true)
  191|      0|            return PredicateResult(
  192|      0|                status: PredicateStatus(bool: result),
  193|      0|                message: failureMessage.toExpectationMessage()
  194|      0|            )
  195|      0|        }
  196|      0|    }
  197|       |
  198|       |    /// Compatibility layer for old Matcher API, deprecated.
  199|       |    /// Emulates the MatcherFunc API
  200|      0|    public static func fromDeprecatedClosure(_ matcher: @escaping (Expression<T>, FailureMessage) throws -> Bool) -> Predicate {
  201|      0|        return _fromDeprecatedClosure(matcher)
  202|      0|    }
  203|       |
  204|       |    /// Compatibility layer for old Matcher API, deprecated.
  205|       |    /// Same as calling .predicate on a MatcherFunc or NonNilMatcherFunc type.
  206|      0|    public static func fromDeprecatedMatcher<M>(_ matcher: M) -> Predicate where M: Matcher, M.ValueType == T {
  207|      0|        return self.fromDeprecatedFullClosure(matcher.toClosure)
  208|      0|    }
  209|       |
  210|       |    /// Deprecated Matcher API, use satisfies(_:_) instead
  211|      0|    public func matches(_ actualExpression: Expression<T>, failureMessage: FailureMessage) throws -> Bool {
  212|      0|        let result = try satisfies(actualExpression)
  213|      0|        result.message.update(failureMessage: failureMessage)
  214|      0|        return result.toBoolean(expectation: .toMatch)
  215|      0|    }
  216|       |
  217|       |    /// Deprecated Matcher API, use satisfies(_:_) instead
  218|      0|    public func doesNotMatch(_ actualExpression: Expression<T>, failureMessage: FailureMessage) throws -> Bool {
  219|      0|        let result = try satisfies(actualExpression)
  220|      0|        result.message.update(failureMessage: failureMessage)
  221|      0|        return result.toBoolean(expectation: .toNotMatch)
  222|      0|    }
  223|       |}
  224|       |
  225|       |extension Predicate {
  226|       |    // Someday, make this public? Needs documentation
  227|     20|    internal func after(f: @escaping (Expression<T>, PredicateResult) throws -> PredicateResult) -> Predicate<T> {
  228|     20|        // swiftlint:disable:previous identifier_name
  229|     20|        return Predicate { actual -> PredicateResult in
  230|     20|            let result = try self.satisfies(actual)
  231|     20|            return try f(actual, result)
  232|     20|        }
  233|     20|    }
  234|       |
  235|       |    /// Returns a new Predicate based on the current one that always fails if nil is given as
  236|       |    /// the actual value.
  237|       |    ///
  238|       |    /// This replaces `NonNilMatcherFunc`.
  239|     20|    public var requireNonNil: Predicate<T> {
  240|     20|        return after { actual, result in
  241|     20|            if try actual.evaluate() == nil {
  242|      0|                return PredicateResult(
  243|      0|                    status: .fail,
  244|      0|                    message: result.message.appendedBeNilHint()
  245|      0|                )
  246|     20|            }
  247|     20|            return result
  248|     20|        }
  249|     20|    }
  250|       |}
  251|       |
  252|       |#if canImport(Darwin)
  253|       |import class Foundation.NSObject
  254|       |
  255|       |public typealias PredicateBlock = (_ actualExpression: Expression<NSObject>) throws -> NMBPredicateResult
  256|       |
  257|       |public class NMBPredicate: NSObject {
  258|       |    private let predicate: PredicateBlock
  259|       |
  260|      0|    public init(predicate: @escaping PredicateBlock) {
  261|      0|        self.predicate = predicate
  262|      0|    }
  263|       |
  264|      0|    func satisfies(_ expression: @escaping () throws -> NSObject?, location: SourceLocation) -> NMBPredicateResult {
  265|      0|        let expr = Expression(expression: expression, location: location)
  266|      0|        do {
  267|      0|            return try self.predicate(expr)
  268|      0|        } catch let error {
  269|      0|            return PredicateResult(status: .fail, message: .fail("unexpected error thrown: <\(error)>")).toObjectiveC()
  270|      0|        }
  271|      0|    }
  272|       |}
  273|       |
  274|       |extension NMBPredicate: NMBMatcher {
  275|      0|    public func matches(_ actualBlock: @escaping () -> NSObject?, failureMessage: FailureMessage, location: SourceLocation) -> Bool {
  276|      0|        let result = satisfies(actualBlock, location: location).toSwift()
  277|      0|        result.message.update(failureMessage: failureMessage)
  278|      0|        return result.status.toBoolean(expectation: .toMatch)
  279|      0|    }
  280|       |
  281|      0|    public func doesNotMatch(_ actualBlock: @escaping () -> NSObject?, failureMessage: FailureMessage, location: SourceLocation) -> Bool {
  282|      0|        let result = satisfies(actualBlock, location: location).toSwift()
  283|      0|        result.message.update(failureMessage: failureMessage)
  284|      0|        return result.status.toBoolean(expectation: .toNotMatch)
  285|      0|    }
  286|       |}
  287|       |
  288|       |final public class NMBPredicateResult: NSObject {
  289|       |    public var status: NMBPredicateStatus
  290|       |    public var message: NMBExpectationMessage
  291|       |
  292|      0|    public init(status: NMBPredicateStatus, message: NMBExpectationMessage) {
  293|      0|        self.status = status
  294|      0|        self.message = message
  295|      0|    }
  296|       |
  297|      0|    public init(bool success: Bool, message: NMBExpectationMessage) {
  298|      0|        self.status = NMBPredicateStatus.from(bool: success)
  299|      0|        self.message = message
  300|      0|    }
  301|       |
  302|      0|    public func toSwift() -> PredicateResult {
  303|      0|        return PredicateResult(status: status.toSwift(),
  304|      0|                               message: message.toSwift())
  305|      0|    }
  306|       |}
  307|       |
  308|       |extension PredicateResult {
  309|      0|    public func toObjectiveC() -> NMBPredicateResult {
  310|      0|        return NMBPredicateResult(status: status.toObjectiveC(), message: message.toObjectiveC())
  311|      0|    }
  312|       |}
  313|       |
  314|       |final public class NMBPredicateStatus: NSObject {
  315|       |    private let status: Int
  316|      0|    private init(status: Int) {
  317|      0|        self.status = status
  318|      0|    }
  319|       |
  320|       |    public static let matches: NMBPredicateStatus = NMBPredicateStatus(status: 0)
  321|       |    public static let doesNotMatch: NMBPredicateStatus = NMBPredicateStatus(status: 1)
  322|       |    public static let fail: NMBPredicateStatus = NMBPredicateStatus(status: 2)
  323|       |
  324|      0|    public override var hash: Int { return self.status.hashValue }
  325|       |
  326|      0|    public override func isEqual(_ object: Any?) -> Bool {
  327|      0|        guard let otherPredicate = object as? NMBPredicateStatus else {
  328|      0|            return false
  329|      0|        }
  330|      0|        return self.status == otherPredicate.status
  331|      0|    }
  332|       |
  333|      0|    public static func from(status: PredicateStatus) -> NMBPredicateStatus {
  334|      0|        switch status {
  335|      0|        case .matches: return self.matches
  336|      0|        case .doesNotMatch: return self.doesNotMatch
  337|      0|        case .fail: return self.fail
  338|      0|        }
  339|      0|    }
  340|       |
  341|      0|    public static func from(bool success: Bool) -> NMBPredicateStatus {
  342|      0|        return self.from(status: PredicateStatus(bool: success))
  343|      0|    }
  344|       |
  345|      0|    public func toSwift() -> PredicateStatus {
  346|      0|        switch status {
  347|      0|        case NMBPredicateStatus.matches.status: return .matches
  348|      0|        case NMBPredicateStatus.doesNotMatch.status: return .doesNotMatch
  349|      0|        case NMBPredicateStatus.fail.status: return .fail
  350|      0|        default:
  351|      0|            internalError("Unhandle status for NMBPredicateStatus")
  352|      0|        }
  353|      0|    }
  354|       |}
  355|       |
  356|       |extension PredicateStatus {
  357|      0|    public func toObjectiveC() -> NMBPredicateStatus {
  358|      0|        return NMBPredicateStatus.from(status: self)
  359|      0|    }
  360|       |}
  361|       |
  362|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/RaisesException.swift:
    1|       |// This matcher requires the Objective-C, and being built by Xcode rather than the Swift Package Manager
    2|       |#if canImport(Darwin) && !SWIFT_PACKAGE
    3|       |import class Foundation.NSObject
    4|       |import class Foundation.NSDictionary
    5|       |import class Foundation.NSException
    6|       |
    7|       |/// A Nimble matcher that succeeds when the actual expression raises an
    8|       |/// exception with the specified name, reason, and/or userInfo.
    9|       |///
   10|       |/// Alternatively, you can pass a closure to do any arbitrary custom matching
   11|       |/// to the raised exception. The closure only gets called when an exception
   12|       |/// is raised.
   13|       |///
   14|       |/// nil arguments indicates that the matcher should not attempt to match against
   15|       |/// that parameter.
   16|       |public func raiseException<Out>(
   17|       |    named: NSExceptionName? = nil,
   18|       |    reason: String? = nil,
   19|       |    userInfo: NSDictionary? = nil,
   20|       |    closure: ((NSException) -> Void)? = nil
   21|      0|) -> Predicate<Out> {
   22|      0|    return raiseException(named: named?.rawValue, reason: reason, userInfo: userInfo, closure: closure)
   23|      0|}
   24|       |
   25|       |/// A Nimble matcher that succeeds when the actual expression raises an
   26|       |/// exception with the specified name, reason, and/or userInfo.
   27|       |///
   28|       |/// Alternatively, you can pass a closure to do any arbitrary custom matching
   29|       |/// to the raised exception. The closure only gets called when an exception
   30|       |/// is raised.
   31|       |///
   32|       |/// nil arguments indicates that the matcher should not attempt to match against
   33|       |/// that parameter.
   34|       |public func raiseException<Out>(
   35|       |    named: String?,
   36|       |    reason: String? = nil,
   37|       |    userInfo: NSDictionary? = nil,
   38|       |    closure: ((NSException) -> Void)? = nil
   39|      0|) -> Predicate<Out> {
   40|      0|    return Predicate { actualExpression in
   41|      0|        var exception: NSException?
   42|      0|        let capture = NMBExceptionCapture(handler: ({ e in
   43|      0|            exception = e
   44|      0|        }), finally: nil)
   45|      0|
   46|      0|        do {
   47|      0|            try capture.tryBlockThrows {
   48|      0|                _ = try actualExpression.evaluate()
   49|      0|            }
   50|      0|        } catch {
   51|      0|            return PredicateResult(status: .fail, message: .fail("unexpected error thrown: <\(error)>"))
   52|      0|        }
   53|      0|
   54|      0|        let message = messageForException(
   55|      0|            exception: exception,
   56|      0|            named: named,
   57|      0|            reason: reason,
   58|      0|            userInfo: userInfo,
   59|      0|            closure: closure
   60|      0|        )
   61|      0|
   62|      0|        let matches = exceptionMatchesNonNilFieldsOrClosure(
   63|      0|            exception,
   64|      0|            named: named,
   65|      0|            reason: reason,
   66|      0|            userInfo: userInfo,
   67|      0|            closure: closure
   68|      0|        )
   69|      0|        return PredicateResult(bool: matches, message: message)
   70|      0|    }
   71|      0|}
   72|       |
   73|       |internal func messageForException(
   74|       |    exception: NSException?,
   75|       |    named: String?,
   76|       |    reason: String?,
   77|       |    userInfo: NSDictionary?,
   78|       |    closure: ((NSException) -> Void)?
   79|      0|) -> ExpectationMessage {
   80|      0|    var rawMessage: String = "raise exception"
   81|      0|
   82|      0|    if let named = named {
   83|      0|        rawMessage += " with name <\(named)>"
   84|      0|    }
   85|      0|    if let reason = reason {
   86|      0|        rawMessage += " with reason <\(reason)>"
   87|      0|    }
   88|      0|    if let userInfo = userInfo {
   89|      0|        rawMessage += " with userInfo <\(userInfo)>"
   90|      0|    }
   91|      0|    if closure != nil {
   92|      0|        rawMessage += " that satisfies block"
   93|      0|    }
   94|      0|    if named == nil && reason == nil && userInfo == nil && closure == nil {
   95|      0|        rawMessage = "raise any exception"
   96|      0|    }
   97|      0|
   98|      0|    let actual: String
   99|      0|    if let exception = exception {
  100|      0|        // swiftlint:disable:next line_length
  101|      0|        actual = "\(String(describing: type(of: exception))) { name=\(exception.name), reason='\(stringify(exception.reason))', userInfo=\(stringify(exception.userInfo)) }"
  102|      0|    } else {
  103|      0|        actual = "no exception"
  104|      0|    }
  105|      0|
  106|      0|    return .expectedCustomValueTo(rawMessage, actual: actual)
  107|      0|}
  108|       |
  109|       |internal func exceptionMatchesNonNilFieldsOrClosure(
  110|       |    _ exception: NSException?,
  111|       |    named: String?,
  112|       |    reason: String?,
  113|       |    userInfo: NSDictionary?,
  114|      0|    closure: ((NSException) -> Void)?) -> Bool {
  115|      0|        var matches = false
  116|      0|
  117|      0|        if let exception = exception {
  118|      0|            matches = true
  119|      0|
  120|      0|            if let named = named, exception.name.rawValue != named {
  121|      0|                matches = false
  122|      0|            }
  123|      0|            if reason != nil && exception.reason != reason {
  124|      0|                matches = false
  125|      0|            }
  126|      0|            if let userInfo = userInfo, let exceptionUserInfo = exception.userInfo,
  127|      0|                (exceptionUserInfo as NSDictionary) != userInfo {
  128|      0|                matches = false
  129|      0|            }
  130|      0|            if let closure = closure {
  131|      0|                let assertions = gatherFailingExpectations {
  132|      0|                    closure(exception)
  133|      0|                }
  134|      0|                let messages = assertions.map { $0.message }
  135|      0|                if messages.count > 0 {
  136|      0|                    matches = false
  137|      0|                }
  138|      0|            }
  139|      0|        }
  140|      0|
  141|      0|        return matches
  142|      0|}
  143|       |
  144|       |public class NMBObjCRaiseExceptionPredicate: NMBPredicate {
  145|       |    private let _name: String?
  146|       |    private let _reason: String?
  147|       |    private let _userInfo: NSDictionary?
  148|       |    private let _block: ((NSException) -> Void)?
  149|       |
  150|      0|    fileprivate init(name: String?, reason: String?, userInfo: NSDictionary?, block: ((NSException) -> Void)?) {
  151|      0|        _name = name
  152|      0|        _reason = reason
  153|      0|        _userInfo = userInfo
  154|      0|        _block = block
  155|      0|
  156|      0|        let predicate: Predicate<NSObject> = raiseException(
  157|      0|            named: name,
  158|      0|            reason: reason,
  159|      0|            userInfo: userInfo,
  160|      0|            closure: block
  161|      0|        )
  162|      0|        let predicateBlock: PredicateBlock = { actualExpression in
  163|      0|            return try predicate.satisfies(actualExpression).toObjectiveC()
  164|      0|        }
  165|      0|        super.init(predicate: predicateBlock)
  166|      0|    }
  167|       |
  168|      0|    @objc public var named: (_ name: String) -> NMBObjCRaiseExceptionPredicate {
  169|      0|        let (reason, userInfo, block) = (_reason, _userInfo, _block)
  170|      0|        return { name in
  171|      0|            return NMBObjCRaiseExceptionPredicate(
  172|      0|                name: name,
  173|      0|                reason: reason,
  174|      0|                userInfo: userInfo,
  175|      0|                block: block
  176|      0|            )
  177|      0|        }
  178|      0|    }
  179|       |
  180|      0|    @objc public var reason: (_ reason: String?) -> NMBObjCRaiseExceptionPredicate {
  181|      0|        let (name, userInfo, block) = (_name, _userInfo, _block)
  182|      0|        return { reason in
  183|      0|            return NMBObjCRaiseExceptionPredicate(
  184|      0|                name: name,
  185|      0|                reason: reason,
  186|      0|                userInfo: userInfo,
  187|      0|                block: block
  188|      0|            )
  189|      0|        }
  190|      0|    }
  191|       |
  192|      0|    @objc public var userInfo: (_ userInfo: NSDictionary?) -> NMBObjCRaiseExceptionPredicate {
  193|      0|        let (name, reason, block) = (_name, _reason, _block)
  194|      0|        return { userInfo in
  195|      0|            return NMBObjCRaiseExceptionPredicate(
  196|      0|                name: name,
  197|      0|                reason: reason,
  198|      0|                userInfo: userInfo,
  199|      0|                block: block
  200|      0|            )
  201|      0|        }
  202|      0|    }
  203|       |
  204|      0|    @objc public var satisfyingBlock: (_ block: ((NSException) -> Void)?) -> NMBObjCRaiseExceptionPredicate {
  205|      0|        let (name, reason, userInfo) = (_name, _reason, _userInfo)
  206|      0|        return { block in
  207|      0|            return NMBObjCRaiseExceptionPredicate(
  208|      0|                name: name,
  209|      0|                reason: reason,
  210|      0|                userInfo: userInfo,
  211|      0|                block: block
  212|      0|            )
  213|      0|        }
  214|      0|    }
  215|       |}
  216|       |
  217|       |extension NMBPredicate {
  218|      0|    @objc public class func raiseExceptionMatcher() -> NMBObjCRaiseExceptionPredicate {
  219|      0|        return NMBObjCRaiseExceptionPredicate(name: nil, reason: nil, userInfo: nil, block: nil)
  220|      0|    }
  221|       |}
  222|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/SatisfyAllOf.swift:
    1|       |/// A Nimble matcher that succeeds when the actual value matches with all of the matchers
    2|       |/// provided in the variable list of matchers.
    3|      0|public func satisfyAllOf<T>(_ predicates: Predicate<T>...) -> Predicate<T> {
    4|      0|    return satisfyAllOf(predicates)
    5|      0|}
    6|       |
    7|       |/// A Nimble matcher that succeeds when the actual value matches with all of the matchers
    8|       |/// provided in the variable list of matchers.
    9|       |@available(*, deprecated, message: "Use Predicate instead")
   10|       |public func satisfyAllOf<T, U>(_ matchers: U...) -> Predicate<T>
   11|      0|    where U: Matcher, U.ValueType == T {
   12|      0|        return satisfyAllOf(matchers.map { $0.predicate })
   13|      0|}
   14|       |
   15|       |/// A Nimble matcher that succeeds when the actual value matches with all of the matchers
   16|       |/// provided in the array of matchers.
   17|      0|public func satisfyAllOf<T>(_ predicates: [Predicate<T>]) -> Predicate<T> {
   18|      0|    return Predicate.define { actualExpression in
   19|      0|        var postfixMessages = [String]()
   20|      0|        var status: PredicateStatus = .matches
   21|      0|        for predicate in predicates {
   22|      0|            let result = try predicate.satisfies(actualExpression)
   23|      0|            if result.status == .fail {
   24|      0|                status = .fail
   25|      0|            } else if result.status == .doesNotMatch, status != .fail {
   26|      0|                status = .doesNotMatch
   27|      0|            }
   28|      0|            postfixMessages.append("{\(result.message.expectedMessage)}")
   29|      0|        }
   30|      0|
   31|      0|        var msg: ExpectationMessage
   32|      0|        if let actualValue = try actualExpression.evaluate() {
   33|      0|            msg = .expectedCustomValueTo(
   34|      0|                "match all of: " + postfixMessages.joined(separator: ", and "),
   35|      0|                actual: "\(actualValue)"
   36|      0|            )
   37|      0|        } else {
   38|      0|            msg = .expectedActualValueTo(
   39|      0|                "match all of: " + postfixMessages.joined(separator: ", and ")
   40|      0|            )
   41|      0|        }
   42|      0|
   43|      0|        return PredicateResult(status: status, message: msg)
   44|      0|    }
   45|      0|}
   46|       |
   47|      0|public func && <T>(left: Predicate<T>, right: Predicate<T>) -> Predicate<T> {
   48|      0|    return satisfyAllOf(left, right)
   49|      0|}
   50|       |
   51|       |#if canImport(Darwin)
   52|       |import class Foundation.NSObject
   53|       |
   54|       |extension NMBPredicate {
   55|      0|    @objc public class func satisfyAllOfMatcher(_ matchers: [NMBMatcher]) -> NMBPredicate {
   56|      0|        return NMBPredicate { actualExpression in
   57|      0|            if matchers.isEmpty {
   58|      0|                return NMBPredicateResult(
   59|      0|                    status: NMBPredicateStatus.fail,
   60|      0|                    message: NMBExpectationMessage(
   61|      0|                        fail: "satisfyAllOf must be called with at least one matcher"
   62|      0|                    )
   63|      0|                )
   64|      0|            }
   65|      0|
   66|      0|            var elementEvaluators = [Predicate<NSObject>]()
   67|      0|            for matcher in matchers {
   68|      0|                let elementEvaluator = Predicate<NSObject> { expression in
   69|      0|                    if let predicate = matcher as? NMBPredicate {
   70|      0|                        return predicate.satisfies({ try expression.evaluate() }, location: actualExpression.location).toSwift()
   71|      0|                    } else {
   72|      0|                        let failureMessage = FailureMessage()
   73|      0|                        let success = matcher.matches(
   74|      0|                            // swiftlint:disable:next force_try
   75|      0|                            { try! expression.evaluate() },
   76|      0|                            failureMessage: failureMessage,
   77|      0|                            location: actualExpression.location
   78|      0|                        )
   79|      0|                        return PredicateResult(bool: success, message: failureMessage.toExpectationMessage())
   80|      0|                    }
   81|      0|                }
   82|      0|
   83|      0|                elementEvaluators.append(elementEvaluator)
   84|      0|            }
   85|      0|
   86|      0|            return try satisfyAllOf(elementEvaluators).satisfies(actualExpression).toObjectiveC()
   87|      0|        }
   88|      0|    }
   89|       |}
   90|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/SatisfyAnyOf.swift:
    1|       |/// A Nimble matcher that succeeds when the actual value matches with any of the matchers
    2|       |/// provided in the variable list of matchers.
    3|      0|public func satisfyAnyOf<T>(_ predicates: Predicate<T>...) -> Predicate<T> {
    4|      0|    return satisfyAnyOf(predicates)
    5|      0|}
    6|       |
    7|       |/// A Nimble matcher that succeeds when the actual value matches with any of the matchers
    8|       |/// provided in the variable list of matchers. 
    9|       |@available(*, deprecated, message: "Use Predicate instead")
   10|       |public func satisfyAnyOf<T, U>(_ matchers: U...) -> Predicate<T>
   11|      0|    where U: Matcher, U.ValueType == T {
   12|      0|        return satisfyAnyOf(matchers.map { $0.predicate })
   13|      0|}
   14|       |
   15|       |/// A Nimble matcher that succeeds when the actual value matches with any of the matchers
   16|       |/// provided in the array of matchers.
   17|      0|public func satisfyAnyOf<T>(_ predicates: [Predicate<T>]) -> Predicate<T> {
   18|      0|        return Predicate.define { actualExpression in
   19|      0|            var postfixMessages = [String]()
   20|      0|            var status: PredicateStatus = .doesNotMatch
   21|      0|            for predicate in predicates {
   22|      0|                let result = try predicate.satisfies(actualExpression)
   23|      0|                if result.status == .fail {
   24|      0|                    status = .fail
   25|      0|                } else if result.status == .matches, status != .fail {
   26|      0|                    status = .matches
   27|      0|                }
   28|      0|                postfixMessages.append("{\(result.message.expectedMessage)}")
   29|      0|            }
   30|      0|
   31|      0|            var msg: ExpectationMessage
   32|      0|            if let actualValue = try actualExpression.evaluate() {
   33|      0|                msg = .expectedCustomValueTo(
   34|      0|                    "match one of: " + postfixMessages.joined(separator: ", or "),
   35|      0|                    actual: "\(actualValue)"
   36|      0|                )
   37|      0|            } else {
   38|      0|                msg = .expectedActualValueTo(
   39|      0|                    "match one of: " + postfixMessages.joined(separator: ", or ")
   40|      0|                )
   41|      0|            }
   42|      0|
   43|      0|            return PredicateResult(status: status, message: msg)
   44|      0|        }
   45|      0|}
   46|       |
   47|      0|public func || <T>(left: Predicate<T>, right: Predicate<T>) -> Predicate<T> {
   48|      0|    return satisfyAnyOf(left, right)
   49|      0|}
   50|       |
   51|       |@available(*, deprecated, message: "Use Predicate instead")
   52|      0|public func || <T>(left: NonNilMatcherFunc<T>, right: NonNilMatcherFunc<T>) -> Predicate<T> {
   53|      0|    return satisfyAnyOf(left, right)
   54|      0|}
   55|       |
   56|       |@available(*, deprecated, message: "Use Predicate instead")
   57|      0|public func || <T>(left: MatcherFunc<T>, right: MatcherFunc<T>) -> Predicate<T> {
   58|      0|    return satisfyAnyOf(left, right)
   59|      0|}
   60|       |
   61|       |#if canImport(Darwin)
   62|       |import class Foundation.NSObject
   63|       |
   64|       |extension NMBPredicate {
   65|      0|    @objc public class func satisfyAnyOfMatcher(_ matchers: [NMBMatcher]) -> NMBPredicate {
   66|      0|        return NMBPredicate { actualExpression in
   67|      0|            if matchers.isEmpty {
   68|      0|                return NMBPredicateResult(
   69|      0|                    status: NMBPredicateStatus.fail,
   70|      0|                    message: NMBExpectationMessage(
   71|      0|                        fail: "satisfyAnyOf must be called with at least one matcher"
   72|      0|                    )
   73|      0|                )
   74|      0|            }
   75|      0|
   76|      0|            var elementEvaluators = [Predicate<NSObject>]()
   77|      0|            for matcher in matchers {
   78|      0|                let elementEvaluator = Predicate<NSObject> { expression in
   79|      0|                    if let predicate = matcher as? NMBPredicate {
   80|      0|                        return predicate.satisfies({ try expression.evaluate() }, location: actualExpression.location).toSwift()
   81|      0|                    } else {
   82|      0|                        let failureMessage = FailureMessage()
   83|      0|                        let success = matcher.matches(
   84|      0|                            // swiftlint:disable:next force_try
   85|      0|                            { try! expression.evaluate() },
   86|      0|                            failureMessage: failureMessage,
   87|      0|                            location: actualExpression.location
   88|      0|                        )
   89|      0|                        return PredicateResult(bool: success, message: failureMessage.toExpectationMessage())
   90|      0|                    }
   91|      0|                }
   92|      0|
   93|      0|                elementEvaluators.append(elementEvaluator)
   94|      0|            }
   95|      0|
   96|      0|            return try satisfyAnyOf(elementEvaluators).satisfies(actualExpression).toObjectiveC()
   97|      0|        }
   98|      0|    }
   99|       |}
  100|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/ThrowAssertion.swift:
    1|       |#if canImport(CwlPreconditionTesting) && (os(macOS) || os(iOS))
    2|       |import CwlPreconditionTesting
    3|       |#elseif canImport(CwlPosixPreconditionTesting)
    4|       |import CwlPosixPreconditionTesting
    5|       |#endif
    6|       |
    7|      0|public func throwAssertion<Out>() -> Predicate<Out> {
    8|      0|    return Predicate { actualExpression in
    9|      0|    #if arch(x86_64) && canImport(Darwin)
   10|      0|        let message = ExpectationMessage.expectedTo("throw an assertion")
   11|      0|
   12|      0|        var actualError: Error?
   13|      0|        let caughtException: BadInstructionException? = catchBadInstruction {
   14|      0|            #if os(tvOS)
   15|      0|                if !NimbleEnvironment.activeInstance.suppressTVOSAssertionWarning {
   16|      0|                    print()
   17|      0|                    print("[Nimble Warning]: If you're getting stuck on a debugger breakpoint for a " +
   18|      0|                        "fatal error while using throwAssertion(), please disable 'Debug Executable' " +
   19|      0|                        "in your scheme. Go to 'Edit Scheme > Test > Info' and uncheck " +
   20|      0|                        "'Debug Executable'. If you've already done that, suppress this warning " +
   21|      0|                        "by setting `NimbleEnvironment.activeInstance.suppressTVOSAssertionWarning = true`. " +
   22|      0|                        "This is required because the standard methods of catching assertions " +
   23|      0|                        "(mach APIs) are unavailable for tvOS. Instead, the same mechanism the " +
   24|      0|                        "debugger uses is the fallback method for tvOS."
   25|      0|                    )
   26|      0|                    print()
   27|      0|                    NimbleEnvironment.activeInstance.suppressTVOSAssertionWarning = true
   28|      0|                }
   29|      0|            #endif
   30|      0|            do {
   31|      0|                _ = try actualExpression.evaluate()
   32|      0|            } catch {
   33|      0|                actualError = error
   34|      0|            }
   35|      0|        }
   36|      0|
   37|      0|        if let actualError = actualError {
   38|      0|            return PredicateResult(
   39|      0|                bool: false,
   40|      0|                message: message.appended(message: "; threw error instead <\(actualError)>")
   41|      0|            )
   42|      0|        } else {
   43|      0|            return PredicateResult(bool: caughtException != nil, message: message)
   44|      0|        }
   45|      0|    #else
   46|      0|        fatalError("The throwAssertion Nimble matcher can only run on x86_64 platforms with " +
   47|      0|            "Objective-C (e.g. macOS, iPhone 5s or later simulators). You can silence this error " +
   48|      0|            "by placing the test case inside an #if arch(x86_64) or canImport(Darwin) conditional statement")
   49|      0|    #endif
   50|      0|    }
   51|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/ThrowError.swift:
    1|       |/// A Nimble matcher that succeeds when the actual expression throws an
    2|       |/// error of the specified type or from the specified case.
    3|       |///
    4|       |/// Errors are tried to be compared by their implementation of Equatable,
    5|       |/// otherwise they fallback to comparison by _domain and _code.
    6|       |///
    7|       |/// Alternatively, you can pass a closure to do any arbitrary custom matching
    8|       |/// to the thrown error. The closure only gets called when an error was thrown.
    9|       |///
   10|       |/// nil arguments indicates that the matcher should not attempt to match against
   11|       |/// that parameter.
   12|      0|public func throwError<Out>() -> Predicate<Out> {
   13|      0|    return Predicate { actualExpression in
   14|      0|        var actualError: Error?
   15|      0|        do {
   16|      0|            _ = try actualExpression.evaluate()
   17|      0|        } catch {
   18|      0|            actualError = error
   19|      0|        }
   20|      0|
   21|      0|        if let actualError = actualError {
   22|      0|            return PredicateResult(
   23|      0|                bool: true,
   24|      0|                message: .expectedCustomValueTo("throw any error", actual: "<\(actualError)>")
   25|      0|            )
   26|      0|        } else {
   27|      0|            return PredicateResult(
   28|      0|                bool: false,
   29|      0|                message: .expectedCustomValueTo("throw any error", actual: "no error")
   30|      0|            )
   31|      0|        }
   32|      0|    }
   33|      0|}
   34|       |
   35|       |/// A Nimble matcher that succeeds when the actual expression throws an
   36|       |/// error of the specified type or from the specified case.
   37|       |///
   38|       |/// Errors are tried to be compared by their implementation of Equatable,
   39|       |/// otherwise they fallback to comparision by _domain and _code.
   40|       |///
   41|       |/// Alternatively, you can pass a closure to do any arbitrary custom matching
   42|       |/// to the thrown error. The closure only gets called when an error was thrown.
   43|       |///
   44|       |/// nil arguments indicates that the matcher should not attempt to match against
   45|       |/// that parameter.
   46|      0|public func throwError<T: Error, Out>(_ error: T, closure: ((Error) -> Void)? = nil) -> Predicate<Out> {
   47|      0|    return Predicate { actualExpression in
   48|      0|        var actualError: Error?
   49|      0|        do {
   50|      0|            _ = try actualExpression.evaluate()
   51|      0|        } catch {
   52|      0|            actualError = error
   53|      0|        }
   54|      0|
   55|      0|        let message = messageForError(
   56|      0|            actualError: actualError,
   57|      0|            error: error,
   58|      0|            errorType: nil,
   59|      0|            closure: closure
   60|      0|        )
   61|      0|
   62|      0|        var matches = false
   63|      0|        if let actualError = actualError, errorMatchesExpectedError(actualError, expectedError: error) {
   64|      0|            matches = true
   65|      0|
   66|      0|            if let closure = closure {
   67|      0|                let assertions = gatherFailingExpectations {
   68|      0|                    closure(actualError)
   69|      0|                }
   70|      0|                let messages = assertions.map { $0.message }
   71|      0|                if !messages.isEmpty {
   72|      0|                    matches = false
   73|      0|                }
   74|      0|            }
   75|      0|        }
   76|      0|
   77|      0|        return PredicateResult(bool: matches, message: message)
   78|      0|    }
   79|      0|}
   80|       |
   81|       |/// A Nimble matcher that succeeds when the actual expression throws an
   82|       |/// error of the specified type or from the specified case.
   83|       |///
   84|       |/// Errors are tried to be compared by their implementation of Equatable,
   85|       |/// otherwise they fallback to comparision by _domain and _code.
   86|       |///
   87|       |/// Alternatively, you can pass a closure to do any arbitrary custom matching
   88|       |/// to the thrown error. The closure only gets called when an error was thrown.
   89|       |///
   90|       |/// nil arguments indicates that the matcher should not attempt to match against
   91|       |/// that parameter.
   92|      0|public func throwError<T: Error & Equatable, Out>(_ error: T, closure: ((T) -> Void)? = nil) -> Predicate<Out> {
   93|      0|    return Predicate { actualExpression in
   94|      0|        var actualError: Error?
   95|      0|        do {
   96|      0|            _ = try actualExpression.evaluate()
   97|      0|        } catch {
   98|      0|            actualError = error
   99|      0|        }
  100|      0|
  101|      0|        let message = messageForError(
  102|      0|            actualError: actualError,
  103|      0|            error: error,
  104|      0|            errorType: nil,
  105|      0|            closure: closure
  106|      0|        )
  107|      0|
  108|      0|        var matches = false
  109|      0|        if let actualError = actualError as? T, error == actualError {
  110|      0|            matches = true
  111|      0|
  112|      0|            if let closure = closure {
  113|      0|                let assertions = gatherFailingExpectations {
  114|      0|                    closure(actualError)
  115|      0|                }
  116|      0|                let messages = assertions.map { $0.message }
  117|      0|                if !messages.isEmpty {
  118|      0|                    matches = false
  119|      0|                }
  120|      0|            }
  121|      0|        }
  122|      0|
  123|      0|        return PredicateResult(bool: matches, message: message)
  124|      0|    }
  125|      0|}
  126|       |
  127|       |/// A Nimble matcher that succeeds when the actual expression throws an
  128|       |/// error of the specified type or from the specified case.
  129|       |///
  130|       |/// Errors are tried to be compared by their implementation of Equatable,
  131|       |/// otherwise they fallback to comparision by _domain and _code.
  132|       |///
  133|       |/// Alternatively, you can pass a closure to do any arbitrary custom matching
  134|       |/// to the thrown error. The closure only gets called when an error was thrown.
  135|       |///
  136|       |/// nil arguments indicates that the matcher should not attempt to match against
  137|       |/// that parameter.
  138|       |public func throwError<T: Error, Out>(
  139|       |    errorType: T.Type,
  140|       |    closure: ((T) -> Void)? = nil
  141|      0|) -> Predicate<Out> {
  142|      0|    return Predicate { actualExpression in
  143|      0|        var actualError: Error?
  144|      0|        do {
  145|      0|            _ = try actualExpression.evaluate()
  146|      0|        } catch {
  147|      0|            actualError = error
  148|      0|        }
  149|      0|
  150|      0|        let message = messageForError(
  151|      0|            actualError: actualError,
  152|      0|            error: nil,
  153|      0|            errorType: errorType,
  154|      0|            closure: closure
  155|      0|        )
  156|      0|
  157|      0|        var matches = false
  158|      0|        if let actualError = actualError {
  159|      0|            matches = true
  160|      0|
  161|      0|            if let actualError = actualError as? T {
  162|      0|                if let closure = closure {
  163|      0|                    let assertions = gatherFailingExpectations {
  164|      0|                        closure(actualError)
  165|      0|                    }
  166|      0|                    let messages = assertions.map { $0.message }
  167|      0|                    if !messages.isEmpty {
  168|      0|                        matches = false
  169|      0|                    }
  170|      0|                }
  171|      0|            } else {
  172|      0|                matches = (actualError is T)
  173|      0|                // The closure expects another ErrorProtocol as argument, so this
  174|      0|                // is _supposed_ to fail, so that it becomes more obvious.
  175|      0|                if let closure = closure {
  176|      0|                    let assertions = gatherExpectations {
  177|      0|                        if let actual = actualError as? T {
  178|      0|                            closure(actual)
  179|      0|                        }
  180|      0|                    }
  181|      0|                    let messages = assertions.map { $0.message }
  182|      0|                    if !messages.isEmpty {
  183|      0|                        matches = false
  184|      0|                    }
  185|      0|                }
  186|      0|            }
  187|      0|        }
  188|      0|
  189|      0|        return PredicateResult(bool: matches, message: message)
  190|      0|    }
  191|      0|}
  192|       |
  193|       |/// A Nimble matcher that succeeds when the actual expression throws any
  194|       |/// error or when the passed closures' arbitrary custom matching succeeds.
  195|       |///
  196|       |/// This duplication to it's generic adequate is required to allow to receive
  197|       |/// values of the existential type `Error` in the closure.
  198|       |///
  199|       |/// The closure only gets called when an error was thrown.
  200|      0|public func throwError<Out>(closure: @escaping ((Error) -> Void)) -> Predicate<Out> {
  201|      0|    return Predicate { actualExpression in
  202|      0|        var actualError: Error?
  203|      0|        do {
  204|      0|            _ = try actualExpression.evaluate()
  205|      0|        } catch {
  206|      0|            actualError = error
  207|      0|        }
  208|      0|
  209|      0|        let message = messageForError(actualError: actualError, closure: closure)
  210|      0|
  211|      0|        var matches = false
  212|      0|        if let actualError = actualError {
  213|      0|            matches = true
  214|      0|
  215|      0|            let assertions = gatherFailingExpectations {
  216|      0|                closure(actualError)
  217|      0|            }
  218|      0|            let messages = assertions.map { $0.message }
  219|      0|            if !messages.isEmpty {
  220|      0|                matches = false
  221|      0|            }
  222|      0|        }
  223|      0|
  224|      0|        return PredicateResult(bool: matches, message: message)
  225|      0|    }
  226|      0|}
  227|       |
  228|       |/// A Nimble matcher that succeeds when the actual expression throws any
  229|       |/// error or when the passed closures' arbitrary custom matching succeeds.
  230|       |///
  231|       |/// This duplication to it's generic adequate is required to allow to receive
  232|       |/// values of the existential type `Error` in the closure.
  233|       |///
  234|       |/// The closure only gets called when an error was thrown.
  235|      0|public func throwError<T: Error, Out>(closure: @escaping ((T) -> Void)) -> Predicate<Out> {
  236|      0|    return Predicate { actualExpression in
  237|      0|        var actualError: Error?
  238|      0|        do {
  239|      0|            _ = try actualExpression.evaluate()
  240|      0|        } catch {
  241|      0|            actualError = error
  242|      0|        }
  243|      0|
  244|      0|        let message = messageForError(actualError: actualError, closure: closure)
  245|      0|
  246|      0|        var matches = false
  247|      0|        if let actualError = actualError as? T {
  248|      0|            matches = true
  249|      0|
  250|      0|            let assertions = gatherFailingExpectations {
  251|      0|                closure(actualError)
  252|      0|            }
  253|      0|            let messages = assertions.map { $0.message }
  254|      0|            if !messages.isEmpty {
  255|      0|                matches = false
  256|      0|            }
  257|      0|        }
  258|      0|
  259|      0|        return PredicateResult(bool: matches, message: message)
  260|      0|    }
  261|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Matchers/ToSucceed.swift:
    1|       |/**
    2|       | Used by the `toSucceed` matcher.
    3|       |
    4|       | This is the return type for the closure.
    5|       | */
    6|       |public enum ToSucceedResult {
    7|       |    case succeeded
    8|       |    case failed(reason: String)
    9|       |}
   10|       |
   11|       |/**
   12|       | A Nimble matcher that takes in a closure for validation.
   13|       |
   14|       | Return `.succeeded` when the validation succeeds.
   15|       | Return `.failed` with a failure reason when the validation fails.
   16|       | */
   17|      0|public func succeed() -> Predicate<() -> ToSucceedResult> {
   18|      0|    return Predicate.define { actualExpression in
   19|      0|        let optActual = try actualExpression.evaluate()
   20|      0|        guard let actual = optActual else {
   21|      0|            return PredicateResult(status: .fail, message: .fail("expected a closure, got <nil>"))
   22|      0|        }
   23|      0|
   24|      0|        switch actual() {
   25|      0|        case .succeeded:
   26|      0|            return PredicateResult(
   27|      0|                bool: true,
   28|      0|                message: .expectedCustomValueTo("succeed", actual: "<succeeded>")
   29|      0|            )
   30|      0|        case .failed(let reason):
   31|      0|            return PredicateResult(
   32|      0|                bool: false,
   33|      0|                message: .expectedCustomValueTo("succeed", actual: "<failed> because <\(reason)>")
   34|      0|            )
   35|      0|        }
   36|      0|    }
   37|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Utils/Await.swift:
    1|       |import CoreFoundation
    2|       |import Dispatch
    3|       |import Foundation
    4|       |
    5|       |private let timeoutLeeway = DispatchTimeInterval.milliseconds(1)
    6|       |private let pollLeeway = DispatchTimeInterval.milliseconds(1)
    7|       |
    8|       |/// Stores debugging information about callers
    9|       |internal struct WaitingInfo: CustomStringConvertible {
   10|       |    let name: String
   11|       |    let file: FileString
   12|       |    let lineNumber: UInt
   13|       |
   14|      0|    var description: String {
   15|      0|        return "\(name) at \(file):\(lineNumber)"
   16|      0|    }
   17|       |}
   18|       |
   19|       |internal protocol WaitLock {
   20|       |    func acquireWaitingLock(_ fnName: String, file: FileString, line: UInt)
   21|       |    func releaseWaitingLock()
   22|       |    func isWaitingLocked() -> Bool
   23|       |}
   24|       |
   25|       |internal class AssertionWaitLock: WaitLock {
   26|       |    private var currentWaiter: WaitingInfo?
   27|      1|    init() { }
   28|       |
   29|      0|    func acquireWaitingLock(_ fnName: String, file: FileString, line: UInt) {
   30|      0|        let info = WaitingInfo(name: fnName, file: file, lineNumber: line)
   31|      0|        let isMainThread = Thread.isMainThread
   32|      0|        nimblePrecondition(
   33|      0|            isMainThread,
   34|      0|            "InvalidNimbleAPIUsage",
   35|      0|            "\(fnName) can only run on the main thread."
   36|      0|        )
   37|      0|        nimblePrecondition(
   38|      0|            currentWaiter == nil,
   39|      0|            "InvalidNimbleAPIUsage",
   40|      0|            """
   41|      0|            Nested async expectations are not allowed to avoid creating flaky tests.
   42|      0|
   43|      0|            The call to
   44|      0|            \t\(info)
   45|      0|            triggered this exception because
   46|      0|            \t\(currentWaiter!)
   47|      0|            is currently managing the main run loop.
   48|      0|            """
   49|      0|        )
   50|      0|        currentWaiter = info
   51|      0|    }
   52|       |
   53|      0|    func isWaitingLocked() -> Bool {
   54|      0|        return currentWaiter != nil
   55|      0|    }
   56|       |
   57|      0|    func releaseWaitingLock() {
   58|      0|        currentWaiter = nil
   59|      0|    }
   60|       |}
   61|       |
   62|       |internal enum AwaitResult<T> {
   63|       |    /// Incomplete indicates None (aka - this value hasn't been fulfilled yet)
   64|       |    case incomplete
   65|       |    /// TimedOut indicates the result reached its defined timeout limit before returning
   66|       |    case timedOut
   67|       |    /// BlockedRunLoop indicates the main runloop is too busy processing other blocks to trigger
   68|       |    /// the timeout code.
   69|       |    ///
   70|       |    /// This may also mean the async code waiting upon may have never actually ran within the
   71|       |    /// required time because other timers & sources are running on the main run loop.
   72|       |    case blockedRunLoop
   73|       |    /// The async block successfully executed and returned a given result
   74|       |    case completed(T)
   75|       |    /// When a Swift Error is thrown
   76|       |    case errorThrown(Error)
   77|       |    /// When an Objective-C Exception is raised
   78|       |    case raisedException(NSException)
   79|       |
   80|      0|    func isIncomplete() -> Bool {
   81|      0|        switch self {
   82|      0|        case .incomplete: return true
   83|      0|        default: return false
   84|      0|        }
   85|      0|    }
   86|       |
   87|      0|    func isCompleted() -> Bool {
   88|      0|        switch self {
   89|      0|        case .completed: return true
   90|      0|        default: return false
   91|      0|        }
   92|      0|    }
   93|       |}
   94|       |
   95|       |/// Holds the resulting value from an asynchronous expectation.
   96|       |/// This class is thread-safe at receiving an "response" to this promise.
   97|       |internal final class AwaitPromise<T> {
   98|      0|    private(set) internal var asyncResult: AwaitResult<T> = .incomplete
   99|       |    private var signal: DispatchSemaphore
  100|       |
  101|      0|    init() {
  102|      0|        signal = DispatchSemaphore(value: 1)
  103|      0|    }
  104|       |
  105|      0|    deinit {
  106|      0|        signal.signal()
  107|      0|    }
  108|       |
  109|       |    /// Resolves the promise with the given result if it has not been resolved. Repeated calls to
  110|       |    /// this method will resolve in a no-op.
  111|       |    ///
  112|       |    /// @returns a Bool that indicates if the async result was accepted or rejected because another
  113|       |    ///          value was received first.
  114|      0|    func resolveResult(_ result: AwaitResult<T>) -> Bool {
  115|      0|        if signal.wait(timeout: .now()) == .success {
  116|      0|            self.asyncResult = result
  117|      0|            return true
  118|      0|        } else {
  119|      0|            return false
  120|      0|        }
  121|      0|    }
  122|       |}
  123|       |
  124|       |internal struct AwaitTrigger {
  125|       |    let timeoutSource: DispatchSourceTimer
  126|       |    let actionSource: DispatchSourceTimer?
  127|       |    let start: () throws -> Void
  128|       |}
  129|       |
  130|       |/// Factory for building fully configured AwaitPromises and waiting for their results.
  131|       |///
  132|       |/// This factory stores all the state for an async expectation so that Await doesn't
  133|       |/// doesn't have to manage it.
  134|       |internal class AwaitPromiseBuilder<T> {
  135|       |    let awaiter: Awaiter
  136|       |    let waitLock: WaitLock
  137|       |    let trigger: AwaitTrigger
  138|       |    let promise: AwaitPromise<T>
  139|       |
  140|       |    internal init(
  141|       |        awaiter: Awaiter,
  142|       |        waitLock: WaitLock,
  143|       |        promise: AwaitPromise<T>,
  144|      0|        trigger: AwaitTrigger) {
  145|      0|            self.awaiter = awaiter
  146|      0|            self.waitLock = waitLock
  147|      0|            self.promise = promise
  148|      0|            self.trigger = trigger
  149|      0|    }
  150|       |
  151|      0|    func timeout(_ timeoutInterval: DispatchTimeInterval, forcefullyAbortTimeout: DispatchTimeInterval) -> Self {
  152|      0|        // = Discussion =
  153|      0|        //
  154|      0|        // There's a lot of technical decisions here that is useful to elaborate on. This is
  155|      0|        // definitely more lower-level than the previous NSRunLoop based implementation.
  156|      0|        //
  157|      0|        //
  158|      0|        // Why Dispatch Source?
  159|      0|        //
  160|      0|        //
  161|      0|        // We're using a dispatch source to have better control of the run loop behavior.
  162|      0|        // A timer source gives us deferred-timing control without having to rely as much on
  163|      0|        // a run loop's traditional dispatching machinery (eg - NSTimers, DefaultRunLoopMode, etc.)
  164|      0|        // which is ripe for getting corrupted by application code.
  165|      0|        //
  166|      0|        // And unlike dispatch_async(), we can control how likely our code gets prioritized to
  167|      0|        // executed (see leeway parameter) + DISPATCH_TIMER_STRICT.
  168|      0|        //
  169|      0|        // This timer is assumed to run on the HIGH priority queue to ensure it maintains the
  170|      0|        // highest priority over normal application / test code when possible.
  171|      0|        //
  172|      0|        //
  173|      0|        // Run Loop Management
  174|      0|        //
  175|      0|        // In order to properly interrupt the waiting behavior performed by this factory class,
  176|      0|        // this timer stops the main run loop to tell the waiter code that the result should be
  177|      0|        // checked.
  178|      0|        //
  179|      0|        // In addition, stopping the run loop is used to halt code executed on the main run loop.
  180|      0|        trigger.timeoutSource.schedule(
  181|      0|            deadline: DispatchTime.now() + timeoutInterval,
  182|      0|            repeating: .never,
  183|      0|            leeway: timeoutLeeway
  184|      0|        )
  185|      0|        trigger.timeoutSource.setEventHandler {
  186|      0|            guard self.promise.asyncResult.isIncomplete() else { return }
  187|      0|            let timedOutSem = DispatchSemaphore(value: 0)
  188|      0|            let semTimedOutOrBlocked = DispatchSemaphore(value: 0)
  189|      0|            semTimedOutOrBlocked.signal()
  190|      0|            let runLoop = CFRunLoopGetMain()
  191|      0|            #if canImport(Darwin)
  192|      0|                let runLoopMode = CFRunLoopMode.defaultMode.rawValue
  193|      0|            #else
  194|      0|                let runLoopMode = kCFRunLoopDefaultMode
  195|      0|            #endif
  196|      0|            CFRunLoopPerformBlock(runLoop, runLoopMode) {
  197|      0|                if semTimedOutOrBlocked.wait(timeout: .now()) == .success {
  198|      0|                    timedOutSem.signal()
  199|      0|                    semTimedOutOrBlocked.signal()
  200|      0|                    if self.promise.resolveResult(.timedOut) {
  201|      0|                        CFRunLoopStop(CFRunLoopGetMain())
  202|      0|                    }
  203|      0|                }
  204|      0|            }
  205|      0|            // potentially interrupt blocking code on run loop to let timeout code run
  206|      0|            CFRunLoopStop(runLoop)
  207|      0|            let now = DispatchTime.now() + forcefullyAbortTimeout
  208|      0|            let didNotTimeOut = timedOutSem.wait(timeout: now) != .success
  209|      0|            let timeoutWasNotTriggered = semTimedOutOrBlocked.wait(timeout: .now()) == .success
  210|      0|            if didNotTimeOut && timeoutWasNotTriggered {
  211|      0|                if self.promise.resolveResult(.blockedRunLoop) {
  212|      0|                    CFRunLoopStop(CFRunLoopGetMain())
  213|      0|                }
  214|      0|            }
  215|      0|        }
  216|      0|        return self
  217|      0|    }
  218|       |
  219|       |    /// Blocks for an asynchronous result.
  220|       |    ///
  221|       |    /// @discussion
  222|       |    /// This function must be executed on the main thread and cannot be nested. This is because
  223|       |    /// this function (and it's related methods) coordinate through the main run loop. Tampering
  224|       |    /// with the run loop can cause undesirable behavior.
  225|       |    ///
  226|       |    /// This method will return an AwaitResult in the following cases:
  227|       |    ///
  228|       |    /// - The main run loop is blocked by other operations and the async expectation cannot be
  229|       |    ///   be stopped.
  230|       |    /// - The async expectation timed out
  231|       |    /// - The async expectation succeeded
  232|       |    /// - The async expectation raised an unexpected exception (objc)
  233|       |    /// - The async expectation raised an unexpected error (swift)
  234|       |    ///
  235|       |    /// The returned AwaitResult will NEVER be .incomplete.
  236|      0|    func wait(_ fnName: String = #function, file: FileString = #file, line: UInt = #line) -> AwaitResult<T> {
  237|      0|        waitLock.acquireWaitingLock(
  238|      0|            fnName,
  239|      0|            file: file,
  240|      0|            line: line)
  241|      0|
  242|      0|        let capture = NMBExceptionCapture(handler: ({ exception in
  243|      0|            _ = self.promise.resolveResult(.raisedException(exception))
  244|      0|        }), finally: ({
  245|      0|            self.waitLock.releaseWaitingLock()
  246|      0|        }))
  247|      0|        capture.tryBlock {
  248|      0|            do {
  249|      0|                try self.trigger.start()
  250|      0|            } catch let error {
  251|      0|                _ = self.promise.resolveResult(.errorThrown(error))
  252|      0|            }
  253|      0|            self.trigger.timeoutSource.resume()
  254|      0|            while self.promise.asyncResult.isIncomplete() {
  255|      0|                // Stopping the run loop does not work unless we run only 1 mode
  256|      0|                _ = RunLoop.current.run(mode: .default, before: .distantFuture)
  257|      0|            }
  258|      0|
  259|      0|            self.trigger.timeoutSource.cancel()
  260|      0|            if let asyncSource = self.trigger.actionSource {
  261|      0|                asyncSource.cancel()
  262|      0|            }
  263|      0|        }
  264|      0|
  265|      0|        return promise.asyncResult
  266|      0|    }
  267|       |}
  268|       |
  269|       |internal class Awaiter {
  270|       |    let waitLock: WaitLock
  271|       |    let timeoutQueue: DispatchQueue
  272|       |    let asyncQueue: DispatchQueue
  273|       |
  274|       |    internal init(
  275|       |        waitLock: WaitLock,
  276|       |        asyncQueue: DispatchQueue,
  277|      1|        timeoutQueue: DispatchQueue) {
  278|      1|            self.waitLock = waitLock
  279|      1|            self.asyncQueue = asyncQueue
  280|      1|            self.timeoutQueue = timeoutQueue
  281|      1|    }
  282|       |
  283|      0|    private func createTimerSource(_ queue: DispatchQueue) -> DispatchSourceTimer {
  284|      0|        return DispatchSource.makeTimerSource(flags: .strict, queue: queue)
  285|      0|    }
  286|       |
  287|       |    func performBlock<T>(
  288|       |        file: FileString,
  289|       |        line: UInt,
  290|       |        _ closure: @escaping (@escaping (T) -> Void) throws -> Void
  291|      0|        ) -> AwaitPromiseBuilder<T> {
  292|      0|            let promise = AwaitPromise<T>()
  293|      0|            let timeoutSource = createTimerSource(timeoutQueue)
  294|      0|            var completionCount = 0
  295|      0|            let trigger = AwaitTrigger(timeoutSource: timeoutSource, actionSource: nil) {
  296|      0|                try closure { result in
  297|      0|                    completionCount += 1
  298|      0|                    if completionCount < 2 {
  299|      0|                        func completeBlock() {
  300|      0|                            if promise.resolveResult(.completed(result)) {
  301|      0|                                CFRunLoopStop(CFRunLoopGetMain())
  302|      0|                            }
  303|      0|                        }
  304|      0|
  305|      0|                        if Thread.isMainThread {
  306|      0|                            completeBlock()
  307|      0|                        } else {
  308|      0|                            DispatchQueue.main.async { completeBlock() }
  309|      0|                        }
  310|      0|                    } else {
  311|      0|                        fail("waitUntil(..) expects its completion closure to be only called once",
  312|      0|                             file: file, line: line)
  313|      0|                    }
  314|      0|                }
  315|      0|            }
  316|      0|
  317|      0|            return AwaitPromiseBuilder(
  318|      0|                awaiter: self,
  319|      0|                waitLock: waitLock,
  320|      0|                promise: promise,
  321|      0|                trigger: trigger)
  322|      0|    }
  323|       |
  324|      0|    func poll<T>(_ pollInterval: DispatchTimeInterval, closure: @escaping () throws -> T?) -> AwaitPromiseBuilder<T> {
  325|      0|        let promise = AwaitPromise<T>()
  326|      0|        let timeoutSource = createTimerSource(timeoutQueue)
  327|      0|        let asyncSource = createTimerSource(asyncQueue)
  328|      0|        let trigger = AwaitTrigger(timeoutSource: timeoutSource, actionSource: asyncSource) {
  329|      0|            let interval = pollInterval
  330|      0|            asyncSource.schedule(deadline: .now(), repeating: interval, leeway: pollLeeway)
  331|      0|            asyncSource.setEventHandler {
  332|      0|                do {
  333|      0|                    if let result = try closure() {
  334|      0|                        if promise.resolveResult(.completed(result)) {
  335|      0|                            CFRunLoopStop(CFRunLoopGetCurrent())
  336|      0|                        }
  337|      0|                    }
  338|      0|                } catch let error {
  339|      0|                    if promise.resolveResult(.errorThrown(error)) {
  340|      0|                        CFRunLoopStop(CFRunLoopGetCurrent())
  341|      0|                    }
  342|      0|                }
  343|      0|            }
  344|      0|            asyncSource.resume()
  345|      0|        }
  346|      0|
  347|      0|        return AwaitPromiseBuilder(
  348|      0|            awaiter: self,
  349|      0|            waitLock: waitLock,
  350|      0|            promise: promise,
  351|      0|            trigger: trigger)
  352|      0|    }
  353|       |}
  354|       |
  355|       |internal func pollBlock(
  356|       |    pollInterval: DispatchTimeInterval,
  357|       |    timeoutInterval: DispatchTimeInterval,
  358|       |    file: FileString,
  359|       |    line: UInt,
  360|       |    fnName: String = #function,
  361|      0|    expression: @escaping () throws -> Bool) -> AwaitResult<Bool> {
  362|      0|        let awaiter = NimbleEnvironment.activeInstance.awaiter
  363|      0|        let result = awaiter.poll(pollInterval) { () throws -> Bool? in
  364|      0|            if try expression() {
  365|      0|                return true
  366|      0|            }
  367|      0|            return nil
  368|      0|        }.timeout(timeoutInterval, forcefullyAbortTimeout: timeoutInterval.divided).wait(fnName, file: file, line: line)
  369|      0|
  370|      0|        return result
  371|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Utils/DispatchTimeInterval.swift:
    1|       |import Dispatch
    2|       |
    3|       |#if canImport(CDispatch)
    4|       |import CDispatch
    5|       |#endif
    6|       |
    7|       |extension DispatchTimeInterval {
    8|       |    // ** Note: We cannot simply divide the time interval because DispatchTimeInterval associated value type is Int
    9|      0|    var divided: DispatchTimeInterval {
   10|      0|        switch self {
   11|      0|        case let .seconds(val): return val < 2 ? .milliseconds(Int(Float(val)/2*1000)) : .seconds(val/2)
   12|      0|        case let .milliseconds(val): return .milliseconds(val/2)
   13|      0|        case let .microseconds(val): return .microseconds(val/2)
   14|      0|        case let .nanoseconds(val): return .nanoseconds(val/2)
   15|      0|        case .never: return .never
   16|      0|        @unknown default: fatalError("Unknown DispatchTimeInterval value")
   17|      0|        }
   18|      0|    }
   19|       |
   20|      0|    var description: String {
   21|      0|        switch self {
   22|      0|        case let .seconds(val): return val == 1 ? "\(Float(val)) second" : "\(Float(val)) seconds"
   23|      0|        case let .milliseconds(val): return "\(Float(val)/1_000) seconds"
   24|      0|        case let .microseconds(val): return "\(Float(val)/1_000_000) seconds"
   25|      0|        case let .nanoseconds(val): return "\(Float(val)/1_000_000_000) seconds"
   26|      0|        default: fatalError("Unknown DispatchTimeInterval value")
   27|      0|        }
   28|      0|    }
   29|       |}
   30|       |
   31|       |#if canImport(Foundation)
   32|       |import typealias Foundation.TimeInterval
   33|       |
   34|       |extension TimeInterval {
   35|      0|    var dispatchInterval: DispatchTimeInterval {
   36|      0|        let microseconds = Int64(self * TimeInterval(USEC_PER_SEC))
   37|      0|        // perhaps use nanoseconds, though would more often be > Int.max
   38|      0|        return microseconds < Int.max ? .microseconds(Int(microseconds)) : .seconds(Int(self))
   39|      0|    }
   40|       |}
   41|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Utils/Errors.swift:
    1|       |// Generic
    2|       |
    3|       |internal func messageForError<T: Error>(
    4|       |    postfixMessageVerb: String = "throw",
    5|       |    actualError: Error?,
    6|       |    error: T? = nil,
    7|       |    errorType: T.Type? = nil,
    8|       |    closure: ((T) -> Void)? = nil
    9|      0|) -> ExpectationMessage {
   10|      0|    var rawMessage = "\(postfixMessageVerb) error"
   11|      0|
   12|      0|    if let error = error {
   13|      0|        rawMessage += " <\(error)>"
   14|      0|    } else if errorType != nil || closure != nil {
   15|      0|        rawMessage += " from type <\(T.self)>"
   16|      0|    }
   17|      0|    if closure != nil {
   18|      0|        rawMessage += " that satisfies block"
   19|      0|    }
   20|      0|    if error == nil && errorType == nil && closure == nil {
   21|      0|        rawMessage = "\(postfixMessageVerb) any error"
   22|      0|    }
   23|      0|
   24|      0|    let actual: String
   25|      0|    if let actualError = actualError {
   26|      0|        actual = "<\(actualError)>"
   27|      0|    } else {
   28|      0|        actual = "no error"
   29|      0|    }
   30|      0|
   31|      0|    return .expectedCustomValueTo(rawMessage, actual: actual)
   32|      0|}
   33|       |
   34|       |internal func errorMatchesExpectedError<T: Error>(
   35|       |    _ actualError: Error,
   36|      0|    expectedError: T) -> Bool {
   37|      0|    return actualError._domain == expectedError._domain
   38|      0|        && actualError._code   == expectedError._code
   39|      0|}
   40|       |
   41|       |// Non-generic
   42|       |
   43|       |internal func messageForError(
   44|       |    actualError: Error?,
   45|       |    closure: ((Error) -> Void)?
   46|      0|) -> ExpectationMessage {
   47|      0|    var rawMessage = "throw error"
   48|      0|
   49|      0|    if closure != nil {
   50|      0|        rawMessage += " that satisfies block"
   51|      0|    } else {
   52|      0|        rawMessage = "throw any error"
   53|      0|    }
   54|      0|
   55|      0|    let actual: String
   56|      0|    if let actualError = actualError {
   57|      0|        actual = "<\(actualError)>"
   58|      0|    } else {
   59|      0|        actual = "no error"
   60|      0|    }
   61|      0|
   62|      0|    return .expectedCustomValueTo(rawMessage, actual: actual)
   63|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Utils/SourceLocation.swift:
    1|       |import Foundation
    2|       |
    3|       |// Ideally we would always use `StaticString` as the type for tracking the file name
    4|       |// that expectations originate from, for consistency with `assert` etc. from the
    5|       |// stdlib, and because recent versions of the XCTest overlay require `StaticString`
    6|       |// when calling `XCTFail`. Under the Objective-C runtime (i.e. building on Mac), we
    7|       |// have to use `String` instead because StaticString can't be generated from Objective-C
    8|       |#if SWIFT_PACKAGE
    9|       |public typealias FileString = StaticString
   10|       |#else
   11|       |public typealias FileString = String
   12|       |#endif
   13|       |
   14|       |public final class SourceLocation: NSObject {
   15|       |    public let file: FileString
   16|       |    public let line: UInt
   17|       |
   18|      0|    override init() {
   19|      0|        file = "Unknown File"
   20|      0|        line = 0
   21|      0|    }
   22|       |
   23|     19|    init(file: FileString, line: UInt) {
   24|     19|        self.file = file
   25|     19|        self.line = line
   26|     19|    }
   27|       |
   28|      0|    override public var description: String {
   29|      0|        return "\(file):\(line)"
   30|      0|    }
   31|       |}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/Nimble/Utils/Stringers.swift:
    1|       |import Foundation
    2|       |
    3|      0|internal func identityAsString(_ value: Any?) -> String {
    4|      0|    let anyObject = value as AnyObject?
    5|      0|    if let value = anyObject {
    6|      0|        return NSString(format: "<%p>", unsafeBitCast(value, to: Int.self)).description
    7|      0|    } else {
    8|      0|        return "nil"
    9|      0|    }
   10|      0|}
   11|       |
   12|      0|internal func arrayAsString<T>(_ items: [T], joiner: String = ", ") -> String {
   13|      0|    return items.reduce("") { accum, item in
   14|      0|        let prefix = (accum.isEmpty ? "" : joiner)
   15|      0|        return accum + prefix + "\(stringify(item))"
   16|      0|    }
   17|      0|}
   18|       |
   19|       |/// A type with a customized test output text representation.
   20|       |///
   21|       |/// This textual representation is produced when values will be
   22|       |/// printed in test runs, and may be useful when producing
   23|       |/// error messages in custom matchers.
   24|       |///
   25|       |/// - SeeAlso: `CustomDebugStringConvertible`
   26|       |public protocol TestOutputStringConvertible {
   27|       |    var testDescription: String { get }
   28|       |}
   29|       |
   30|       |extension Double: TestOutputStringConvertible {
   31|      0|    public var testDescription: String {
   32|      0|        return NSNumber(value: self).testDescription
   33|      0|    }
   34|       |}
   35|       |
   36|       |extension Float: TestOutputStringConvertible {
   37|      0|    public var testDescription: String {
   38|      0|        return NSNumber(value: self).testDescription
   39|      0|    }
   40|       |}
   41|       |
   42|       |extension NSNumber: TestOutputStringConvertible {
   43|      0|    public var testDescription: String {
   44|      0|        let description = self.description
   45|      0|
   46|      0|        if description.contains(".") {
   47|      0|            let decimalPlaces = description.split(separator: ".")[1]
   48|      0|            switch decimalPlaces.count {
   49|      0|            case 1:
   50|      0|                return String(format: "%0.1f", doubleValue)
   51|      0|            case 2:
   52|      0|                return String(format: "%0.2f", doubleValue)
   53|      0|            case 3:
   54|      0|                return String(format: "%0.3f", doubleValue)
   55|      0|            default:
   56|      0|                return String(format: "%0.4f", doubleValue)
   57|      0|            }
   58|      0|        }
   59|      0|
   60|      0|        return description
   61|      0|    }
   62|       |}
   63|       |
   64|       |extension Array: TestOutputStringConvertible {
   65|      0|    public var testDescription: String {
   66|      0|        let list = self.map(Nimble.stringify).joined(separator: ", ")
   67|      0|        return "[\(list)]"
   68|      0|    }
   69|       |}
   70|       |
   71|       |extension AnySequence: TestOutputStringConvertible {
   72|      0|    public var testDescription: String {
   73|      0|        let generator = self.makeIterator()
   74|      0|        var strings = [String]()
   75|      0|        var value: AnySequence.Element?
   76|      0|
   77|      0|        repeat {
   78|      0|            value = generator.next()
   79|      0|            if let value = value {
   80|      0|                strings.append(stringify(value))
   81|      0|            }
   82|      0|        } while value != nil
   83|      0|
   84|      0|        let list = strings.joined(separator: ", ")
   85|      0|        return "[\(list)]"
   86|      0|    }
   87|       |}
   88|       |
   89|       |extension NSArray: TestOutputStringConvertible {
   90|      0|    public var testDescription: String {
   91|      0|        let list = Array(self).map(Nimble.stringify).joined(separator: ", ")
   92|      0|        return "(\(list))"
   93|      0|    }
   94|       |}
   95|       |
   96|       |extension NSIndexSet: TestOutputStringConvertible {
   97|      0|    public var testDescription: String {
   98|      0|        let list = Array(self).map(Nimble.stringify).joined(separator: ", ")
   99|      0|        return "(\(list))"
  100|      0|    }
  101|       |}
  102|       |
  103|       |extension String: TestOutputStringConvertible {
  104|      8|    public var testDescription: String {
  105|      8|        return self
  106|      8|    }
  107|       |}
  108|       |
  109|       |extension Data: TestOutputStringConvertible {
  110|      0|    public var testDescription: String {
  111|      0|        return "Data<hash=\((self as NSData).hash),length=\(count)>"
  112|      0|    }
  113|       |}
  114|       |
  115|       |///
  116|       |/// Returns a string appropriate for displaying in test output
  117|       |/// from the provided value.
  118|       |///
  119|       |/// - parameter value: A value that will show up in a test's output.
  120|       |///
  121|       |/// - returns: The string that is returned can be
  122|       |///     customized per type by conforming a type to the `TestOutputStringConvertible`
  123|       |///     protocol. When stringifying a non-`TestOutputStringConvertible` type, this
  124|       |///     function will return the value's debug description and then its
  125|       |///     normal description if available and in that order. Otherwise it
  126|       |///     will return the result of constructing a string from the value.
  127|       |///
  128|       |/// - SeeAlso: `TestOutputStringConvertible`
  129|     36|public func stringify<T>(_ value: T?) -> String {
  130|     34|    guard let value = value else { return "nil" }
  131|     34|
  132|      8|    if let value = value as? TestOutputStringConvertible {
  133|      8|        return value.testDescription
  134|     26|    }
  135|     26|
  136|      0|    if let value = value as? CustomDebugStringConvertible {
  137|      0|        return value.debugDescription
  138|     26|    }
  139|     26|
  140|     26|    return String(describing: value)
  141|     26|}
  142|       |
  143|       |#if canImport(Darwin)
  144|       |@objc public class NMBStringer: NSObject {
  145|      0|    @objc public class func stringify(_ obj: Any?) -> String {
  146|      0|        return Nimble.stringify(obj)
  147|      0|    }
  148|       |}
  149|       |#endif
  150|       |
  151|       |// MARK: Collection Type Stringers
  152|       |
  153|       |/// Attempts to generate a pretty type string for a given value. If the value is of a Objective-C
  154|       |/// collection type, or a subclass thereof, (e.g. `NSArray`, `NSDictionary`, etc.). 
  155|       |/// This function will return the type name of the root class of the class cluster for better
  156|       |/// readability (e.g. `NSArray` instead of `__NSArrayI`).
  157|       |///
  158|       |/// For values that don't have a type of an Objective-C collection, this function returns the
  159|       |/// default type description.
  160|       |///
  161|       |/// - parameter value: A value that will be used to determine a type name.
  162|       |///
  163|       |/// - returns: The name of the class cluster root class for Objective-C collection types, or the
  164|       |/// the `dynamicType` of the value for values of any other type.
  165|      0|public func prettyCollectionType<T>(_ value: T) -> String {
  166|      0|    switch value {
  167|      0|    case is NSArray:
  168|      0|        return String(describing: NSArray.self)
  169|      0|    case is NSDictionary:
  170|      0|        return String(describing: NSDictionary.self)
  171|      0|    case is NSSet:
  172|      0|        return String(describing: NSSet.self)
  173|      0|    case is NSIndexSet:
  174|      0|        return String(describing: NSIndexSet.self)
  175|      0|    default:
  176|      0|        return String(describing: value)
  177|      0|    }
  178|      0|}
  179|       |
  180|       |/// Returns the type name for a given collection type. This overload is used by Swift
  181|       |/// collection types.
  182|       |///
  183|       |/// - parameter collection: A Swift `CollectionType` value.
  184|       |///
  185|       |/// - returns: A string representing the `dynamicType` of the value.
  186|      0|public func prettyCollectionType<T: Collection>(_ collection: T) -> String {
  187|      0|    return String(describing: type(of: collection))
  188|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/NimbleObjectiveC/DSL.h:
    1|       |#import <Foundation/Foundation.h>
    2|       |
    3|       |@class NMBExpectation;
    4|       |@class NMBPredicate;
    5|       |@class NMBObjCBeCloseToPredicate;
    6|       |@class NMBObjCRaiseExceptionPredicate;
    7|       |
    8|       |
    9|       |NS_ASSUME_NONNULL_BEGIN
   10|       |
   11|       |
   12|       |#define NIMBLE_OVERLOADABLE __attribute__((overloadable))
   13|       |#define NIMBLE_EXPORT FOUNDATION_EXPORT
   14|       |#define NIMBLE_EXPORT_INLINE FOUNDATION_STATIC_INLINE
   15|       |
   16|       |#define NIMBLE_VALUE_OF(VAL) ({ \
   17|       |    __typeof__((VAL)) val = (VAL); \
   18|       |    [NSValue valueWithBytes:&val objCType:@encode(__typeof__((VAL)))]; \
   19|       |})
   20|       |
   21|       |#ifdef NIMBLE_DISABLE_SHORT_SYNTAX
   22|       |#define NIMBLE_SHORT(PROTO, ORIGINAL)
   23|       |#define NIMBLE_SHORT_OVERLOADED(PROTO, ORIGINAL)
   24|       |#else
   25|      0|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | Unexecuted instantiation: DSL.m:beIdenticalTo
  ------------------
  | Unexecuted instantiation: DSL.m:be
  ------------------
  | Unexecuted instantiation: DSL.m:beTruthy
  ------------------
  | Unexecuted instantiation: DSL.m:beFalsy
  ------------------
  | Unexecuted instantiation: DSL.m:beTrue
  ------------------
  | Unexecuted instantiation: DSL.m:beFalse
  ------------------
  | Unexecuted instantiation: DSL.m:beNil
  ------------------
  | Unexecuted instantiation: DSL.m:beEmpty
  ------------------
  | Unexecuted instantiation: DSL.m:containElementSatisfying
  ------------------
  | Unexecuted instantiation: DSL.m:endWith
  ------------------
  | Unexecuted instantiation: DSL.m:raiseException
  ------------------
  | Unexecuted instantiation: DSL.m:match
  ------------------
  | Unexecuted instantiation: DSL.m:allPass
  ------------------
   26|      0|#define NIMBLE_SHORT_OVERLOADED(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE NIMBLE_OVERLOADABLE PROTO { return (ORIGINAL); }
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL5equalP11objc_object
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL5equalPv
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL5equal8_NSRange
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL5equall
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL5equalm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL5equali
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL5equalj
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL5equalf
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL5equald
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL5equalx
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL5equaly
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL5equalc
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL5equalh
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL5equalb
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL5equalPc
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9haveCountP11objc_object
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9haveCountl
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9haveCountm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9haveCounti
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9haveCountj
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9haveCountx
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9haveCounty
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9haveCountc
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9haveCounth
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9beCloseToP8NSNumber
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9beCloseTol
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9beCloseTom
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9beCloseToi
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9beCloseToj
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9beCloseTof
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9beCloseTod
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9beCloseTox
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9beCloseToy
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9beCloseToc
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9beCloseToh
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13beGreaterThanl
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13beGreaterThanm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13beGreaterThani
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13beGreaterThanj
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13beGreaterThanf
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13beGreaterThand
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13beGreaterThanx
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13beGreaterThany
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13beGreaterThanc
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13beGreaterThanh
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL22beGreaterThanOrEqualTol
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL22beGreaterThanOrEqualTom
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL22beGreaterThanOrEqualToi
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL22beGreaterThanOrEqualToj
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL22beGreaterThanOrEqualTof
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL22beGreaterThanOrEqualTod
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL22beGreaterThanOrEqualTox
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL22beGreaterThanOrEqualToy
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL22beGreaterThanOrEqualToc
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL22beGreaterThanOrEqualToh
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10beLessThanl
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10beLessThanm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10beLessThani
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10beLessThanj
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10beLessThanf
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10beLessThand
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10beLessThanx
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10beLessThany
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10beLessThanc
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10beLessThanh
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL19beLessThanOrEqualTol
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL19beLessThanOrEqualTom
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL19beLessThanOrEqualToi
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL19beLessThanOrEqualToj
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL19beLessThanOrEqualTof
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL19beLessThanOrEqualTod
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL19beLessThanOrEqualTox
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL19beLessThanOrEqualToy
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL19beLessThanOrEqualToc
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL19beLessThanOrEqualToh
  ------------------
   27|       |#endif
   28|       |
   29|       |
   30|       |
   31|       |#define DEFINE_NMB_EXPECT_OVERLOAD(TYPE, EXPR) \
   32|       |        NIMBLE_EXPORT_INLINE NIMBLE_OVERLOADABLE \
   33|      0|        NMBExpectation *NMB_expect(TYPE(^actualBlock)(void), NSString *file, NSUInteger line) { \
   34|      0|            return NMB_expect(^id { return EXPR; }, file, line); \
   35|      0|        }
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10NMB_expectU13block_pointerFPvvEP8NSStringm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10NMB_expectU13block_pointerF8_NSRangevEP8NSStringm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10NMB_expectU13block_pointerFlvEP8NSStringm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10NMB_expectU13block_pointerFmvEP8NSStringm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10NMB_expectU13block_pointerFivEP8NSStringm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10NMB_expectU13block_pointerFjvEP8NSStringm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10NMB_expectU13block_pointerFfvEP8NSStringm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10NMB_expectU13block_pointerFdvEP8NSStringm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10NMB_expectU13block_pointerFxvEP8NSStringm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10NMB_expectU13block_pointerFyvEP8NSStringm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10NMB_expectU13block_pointerFcvEP8NSStringm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10NMB_expectU13block_pointerFhvEP8NSStringm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10NMB_expectU13block_pointerFbvEP8NSStringm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL10NMB_expectU13block_pointerFPcvEP8NSStringm
  ------------------
   36|       |
   37|       |    NIMBLE_EXPORT NIMBLE_OVERLOADABLE
   38|       |    NMBExpectation *NMB_expect(id(^actualBlock)(void), NSString *file, NSUInteger line);
   39|       |
   40|       |    // overloaded dispatch for nils - expect(nil)
   41|       |    DEFINE_NMB_EXPECT_OVERLOAD(void*, nil)
   42|       |    DEFINE_NMB_EXPECT_OVERLOAD(NSRange, NIMBLE_VALUE_OF(actualBlock()))
   43|       |    DEFINE_NMB_EXPECT_OVERLOAD(long, @(actualBlock()))
   44|       |    DEFINE_NMB_EXPECT_OVERLOAD(unsigned long, @(actualBlock()))
   45|       |    DEFINE_NMB_EXPECT_OVERLOAD(int, @(actualBlock()))
   46|       |    DEFINE_NMB_EXPECT_OVERLOAD(unsigned int, @(actualBlock()))
   47|       |    DEFINE_NMB_EXPECT_OVERLOAD(float, @(actualBlock()))
   48|       |    DEFINE_NMB_EXPECT_OVERLOAD(double, @(actualBlock()))
   49|       |    DEFINE_NMB_EXPECT_OVERLOAD(long long, @(actualBlock()))
   50|       |    DEFINE_NMB_EXPECT_OVERLOAD(unsigned long long, @(actualBlock()))
   51|       |    DEFINE_NMB_EXPECT_OVERLOAD(char, @(actualBlock()))
   52|       |    DEFINE_NMB_EXPECT_OVERLOAD(unsigned char, @(actualBlock()))
   53|       |    // bool doesn't get the compiler to dispatch to BOOL types, but using BOOL here seems to allow
   54|       |    // the compiler to dispatch to bool.
   55|       |    DEFINE_NMB_EXPECT_OVERLOAD(BOOL, @(actualBlock()))
   56|       |    DEFINE_NMB_EXPECT_OVERLOAD(char *, @(actualBlock()))
   57|       |
   58|       |
   59|       |#undef DEFINE_NMB_EXPECT_OVERLOAD
   60|       |
   61|       |
   62|       |
   63|       |NIMBLE_EXPORT NMBExpectation *NMB_expectAction(void(^actualBlock)(void), NSString *file, NSUInteger line);
   64|       |
   65|       |
   66|       |
   67|       |#define DEFINE_OVERLOAD(TYPE, EXPR) \
   68|       |        NIMBLE_EXPORT_INLINE NIMBLE_OVERLOADABLE \
   69|      0|        NMBPredicate *NMB_equal(TYPE expectedValue) { \
   70|      0|            return NMB_equal((EXPR)); \
   71|      0|        } \
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9NMB_equalPv
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9NMB_equal8_NSRange
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9NMB_equall
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9NMB_equalm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9NMB_equali
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9NMB_equalj
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9NMB_equalf
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9NMB_equald
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9NMB_equalx
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9NMB_equaly
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9NMB_equalc
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9NMB_equalh
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9NMB_equalb
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL9NMB_equalPc
  ------------------
   72|       |        NIMBLE_SHORT_OVERLOADED(NMBPredicate *equal(TYPE expectedValue), NMB_equal(expectedValue));
   73|       |
   74|       |
   75|       |    NIMBLE_EXPORT NIMBLE_OVERLOADABLE
   76|       |    NMBPredicate *NMB_equal(__nullable id expectedValue);
   77|       |
   78|       |    NIMBLE_SHORT_OVERLOADED(NMBPredicate *equal(__nullable id expectedValue),
   79|       |                            NMB_equal(expectedValue));
   80|       |
   81|       |    // overloaded dispatch for nils - expect(nil)
   82|       |    DEFINE_OVERLOAD(void*__nullable, (id)nil)
   83|       |    DEFINE_OVERLOAD(NSRange, NIMBLE_VALUE_OF(expectedValue))
   84|       |    DEFINE_OVERLOAD(long, @(expectedValue))
   85|       |    DEFINE_OVERLOAD(unsigned long, @(expectedValue))
   86|       |    DEFINE_OVERLOAD(int, @(expectedValue))
   87|       |    DEFINE_OVERLOAD(unsigned int, @(expectedValue))
   88|       |    DEFINE_OVERLOAD(float, @(expectedValue))
   89|       |    DEFINE_OVERLOAD(double, @(expectedValue))
   90|       |    DEFINE_OVERLOAD(long long, @(expectedValue))
   91|       |    DEFINE_OVERLOAD(unsigned long long, @(expectedValue))
   92|       |    DEFINE_OVERLOAD(char, @(expectedValue))
   93|       |    DEFINE_OVERLOAD(unsigned char, @(expectedValue))
   94|       |    // bool doesn't get the compiler to dispatch to BOOL types, but using BOOL here seems to allow
   95|       |    // the compiler to dispatch to bool.
   96|       |    DEFINE_OVERLOAD(BOOL, @(expectedValue))
   97|       |    DEFINE_OVERLOAD(char *, @(expectedValue))
   98|       |
   99|       |#undef DEFINE_OVERLOAD
  100|       |
  101|       |
  102|       |#define DEFINE_OVERLOAD(TYPE, EXPR) \
  103|       |        NIMBLE_EXPORT_INLINE NIMBLE_OVERLOADABLE \
  104|      0|        NMBPredicate *NMB_haveCount(TYPE expectedValue) { \
  105|      0|            return NMB_haveCount((EXPR)); \
  106|      0|        } \
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_haveCountl
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_haveCountm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_haveCounti
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_haveCountj
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_haveCountx
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_haveCounty
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_haveCountc
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_haveCounth
  ------------------
  107|       |        NIMBLE_SHORT_OVERLOADED(NMBPredicate *haveCount(TYPE expectedValue), \
  108|       |            NMB_haveCount(expectedValue));
  109|       |
  110|       |
  111|       |    NIMBLE_EXPORT NIMBLE_OVERLOADABLE
  112|       |    NMBPredicate *NMB_haveCount(id expectedValue);
  113|       |
  114|       |    NIMBLE_SHORT_OVERLOADED(NMBPredicate *haveCount(id expectedValue),
  115|       |                            NMB_haveCount(expectedValue));
  116|       |
  117|       |    DEFINE_OVERLOAD(long, @(expectedValue))
  118|       |    DEFINE_OVERLOAD(unsigned long, @(expectedValue))
  119|       |    DEFINE_OVERLOAD(int, @(expectedValue))
  120|       |    DEFINE_OVERLOAD(unsigned int, @(expectedValue))
  121|       |    DEFINE_OVERLOAD(long long, @(expectedValue))
  122|       |    DEFINE_OVERLOAD(unsigned long long, @(expectedValue))
  123|       |    DEFINE_OVERLOAD(char, @(expectedValue))
  124|       |    DEFINE_OVERLOAD(unsigned char, @(expectedValue))
  125|       |
  126|       |#undef DEFINE_OVERLOAD
  127|       |
  128|       |#define DEFINE_OVERLOAD(TYPE, EXPR) \
  129|       |        NIMBLE_EXPORT_INLINE NIMBLE_OVERLOADABLE \
  130|      0|        NMBObjCBeCloseToPredicate *NMB_beCloseTo(TYPE expectedValue) { \
  131|      0|            return NMB_beCloseTo((NSNumber *)(EXPR)); \
  132|      0|        } \
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_beCloseTol
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_beCloseTom
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_beCloseToi
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_beCloseToj
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_beCloseTof
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_beCloseTod
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_beCloseTox
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_beCloseToy
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_beCloseToc
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL13NMB_beCloseToh
  ------------------
  133|       |        NIMBLE_SHORT_OVERLOADED(NMBObjCBeCloseToPredicate *beCloseTo(TYPE expectedValue), \
  134|       |            NMB_beCloseTo(expectedValue));
  135|       |
  136|       |    NIMBLE_EXPORT NIMBLE_OVERLOADABLE NMBObjCBeCloseToPredicate *NMB_beCloseTo(NSNumber *expectedValue);
  137|       |    NIMBLE_SHORT_OVERLOADED(NMBObjCBeCloseToPredicate *beCloseTo(NSNumber *expectedValue),
  138|       |                            NMB_beCloseTo(expectedValue));
  139|       |
  140|       |    // it would be better to only overload float & double, but zero becomes ambigious
  141|       |
  142|       |    DEFINE_OVERLOAD(long, @(expectedValue))
  143|       |    DEFINE_OVERLOAD(unsigned long, @(expectedValue))
  144|       |    DEFINE_OVERLOAD(int, @(expectedValue))
  145|       |    DEFINE_OVERLOAD(unsigned int, @(expectedValue))
  146|       |    DEFINE_OVERLOAD(float, @(expectedValue))
  147|       |    DEFINE_OVERLOAD(double, @(expectedValue))
  148|       |    DEFINE_OVERLOAD(long long, @(expectedValue))
  149|       |    DEFINE_OVERLOAD(unsigned long long, @(expectedValue))
  150|       |    DEFINE_OVERLOAD(char, @(expectedValue))
  151|       |    DEFINE_OVERLOAD(unsigned char, @(expectedValue))
  152|       |
  153|       |#undef DEFINE_OVERLOAD
  154|       |
  155|       |NIMBLE_EXPORT NMBPredicate *NMB_beAnInstanceOf(Class expectedClass);
  156|      0|NIMBLE_EXPORT_INLINE NMBPredicate *beAnInstanceOf(Class expectedClass) {
  157|      0|    return NMB_beAnInstanceOf(expectedClass);
  158|      0|}
  159|       |
  160|       |NIMBLE_EXPORT NMBPredicate *NMB_beAKindOf(Class expectedClass);
  161|      0|NIMBLE_EXPORT_INLINE NMBPredicate *beAKindOf(Class expectedClass) {
  162|      0|    return NMB_beAKindOf(expectedClass);
  163|      0|}
  164|       |
  165|       |NIMBLE_EXPORT NMBPredicate *NMB_beginWith(id itemElementOrSubstring);
  166|      0|NIMBLE_EXPORT_INLINE NMBPredicate *beginWith(id itemElementOrSubstring) {
  167|      0|    return NMB_beginWith(itemElementOrSubstring);
  168|      0|}
  169|       |
  170|       |#define DEFINE_OVERLOAD(TYPE, EXPR) \
  171|       |        NIMBLE_EXPORT_INLINE NIMBLE_OVERLOADABLE \
  172|      0|        NMBPredicate *NMB_beGreaterThan(TYPE expectedValue) { \
  173|      0|            return NMB_beGreaterThan((EXPR)); \
  174|      0|        } \
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL17NMB_beGreaterThanl
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL17NMB_beGreaterThanm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL17NMB_beGreaterThani
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL17NMB_beGreaterThanj
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL17NMB_beGreaterThanf
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL17NMB_beGreaterThand
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL17NMB_beGreaterThanx
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL17NMB_beGreaterThany
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL17NMB_beGreaterThanc
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL17NMB_beGreaterThanh
  ------------------
  175|       |        NIMBLE_SHORT_OVERLOADED(NMBPredicate *beGreaterThan(TYPE expectedValue), NMB_beGreaterThan(expectedValue));
  176|       |
  177|       |    NIMBLE_EXPORT NIMBLE_OVERLOADABLE
  178|       |    NMBPredicate *NMB_beGreaterThan(NSNumber *expectedValue);
  179|       |
  180|       |    NIMBLE_EXPORT_INLINE NIMBLE_OVERLOADABLE
  181|      0|    NMBPredicate *beGreaterThan(NSNumber *expectedValue) {
  182|      0|        return NMB_beGreaterThan(expectedValue);
  183|      0|    }
  184|       |
  185|       |    DEFINE_OVERLOAD(long, @(expectedValue))
  186|       |    DEFINE_OVERLOAD(unsigned long, @(expectedValue))
  187|       |    DEFINE_OVERLOAD(int, @(expectedValue))
  188|       |    DEFINE_OVERLOAD(unsigned int, @(expectedValue))
  189|       |    DEFINE_OVERLOAD(float, @(expectedValue))
  190|       |    DEFINE_OVERLOAD(double, @(expectedValue))
  191|       |    DEFINE_OVERLOAD(long long, @(expectedValue))
  192|       |    DEFINE_OVERLOAD(unsigned long long, @(expectedValue))
  193|       |    DEFINE_OVERLOAD(char, @(expectedValue))
  194|       |    DEFINE_OVERLOAD(unsigned char, @(expectedValue))
  195|       |
  196|       |#undef DEFINE_OVERLOAD
  197|       |
  198|       |#define DEFINE_OVERLOAD(TYPE, EXPR) \
  199|       |        NIMBLE_EXPORT_INLINE NIMBLE_OVERLOADABLE \
  200|      0|        NMBPredicate *NMB_beGreaterThanOrEqualTo(TYPE expectedValue) { \
  201|      0|            return NMB_beGreaterThanOrEqualTo((EXPR)); \
  202|      0|        } \
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL26NMB_beGreaterThanOrEqualTol
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL26NMB_beGreaterThanOrEqualTom
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL26NMB_beGreaterThanOrEqualToi
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL26NMB_beGreaterThanOrEqualToj
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL26NMB_beGreaterThanOrEqualTof
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL26NMB_beGreaterThanOrEqualTod
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL26NMB_beGreaterThanOrEqualTox
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL26NMB_beGreaterThanOrEqualToy
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL26NMB_beGreaterThanOrEqualToc
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL26NMB_beGreaterThanOrEqualToh
  ------------------
  203|       |        NIMBLE_SHORT_OVERLOADED(NMBPredicate *beGreaterThanOrEqualTo(TYPE expectedValue), \
  204|       |            NMB_beGreaterThanOrEqualTo(expectedValue));
  205|       |
  206|       |    NIMBLE_EXPORT NIMBLE_OVERLOADABLE
  207|       |    NMBPredicate *NMB_beGreaterThanOrEqualTo(NSNumber *expectedValue);
  208|       |
  209|       |    NIMBLE_EXPORT_INLINE NIMBLE_OVERLOADABLE
  210|      0|    NMBPredicate *beGreaterThanOrEqualTo(NSNumber *expectedValue) {
  211|      0|        return NMB_beGreaterThanOrEqualTo(expectedValue);
  212|      0|    }
  213|       |
  214|       |    DEFINE_OVERLOAD(long, @(expectedValue))
  215|       |    DEFINE_OVERLOAD(unsigned long, @(expectedValue))
  216|       |    DEFINE_OVERLOAD(int, @(expectedValue))
  217|       |    DEFINE_OVERLOAD(unsigned int, @(expectedValue))
  218|       |    DEFINE_OVERLOAD(float, @(expectedValue))
  219|       |    DEFINE_OVERLOAD(double, @(expectedValue))
  220|       |    DEFINE_OVERLOAD(long long, @(expectedValue))
  221|       |    DEFINE_OVERLOAD(unsigned long long, @(expectedValue))
  222|       |    DEFINE_OVERLOAD(char, @(expectedValue))
  223|       |    DEFINE_OVERLOAD(unsigned char, @(expectedValue))
  224|       |
  225|       |
  226|       |#undef DEFINE_OVERLOAD
  227|       |
  228|       |NIMBLE_EXPORT NMBPredicate *NMB_beIdenticalTo(id expectedInstance);
  229|       |NIMBLE_SHORT(NMBPredicate *beIdenticalTo(id expectedInstance),
  230|       |             NMB_beIdenticalTo(expectedInstance));
  231|       |
  232|       |NIMBLE_EXPORT NMBPredicate *NMB_be(id expectedInstance);
  233|       |NIMBLE_SHORT(NMBPredicate *be(id expectedInstance),
  234|       |             NMB_be(expectedInstance));
  235|       |
  236|       |
  237|       |#define DEFINE_OVERLOAD(TYPE, EXPR) \
  238|       |        NIMBLE_EXPORT_INLINE NIMBLE_OVERLOADABLE \
  239|      0|        NMBPredicate *NMB_beLessThan(TYPE expectedValue) { \
  240|      0|            return NMB_beLessThan((EXPR)); \
  241|      0|        } \
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL14NMB_beLessThanl
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL14NMB_beLessThanm
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL14NMB_beLessThani
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL14NMB_beLessThanj
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL14NMB_beLessThanf
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL14NMB_beLessThand
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL14NMB_beLessThanx
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL14NMB_beLessThany
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL14NMB_beLessThanc
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL14NMB_beLessThanh
  ------------------
  242|       |        NIMBLE_SHORT_OVERLOADED(NMBPredicate *beLessThan(TYPE expectedValue), \
  243|       |            NMB_beLessThan(expectedValue));
  244|       |
  245|       |    NIMBLE_EXPORT NIMBLE_OVERLOADABLE
  246|       |    NMBPredicate *NMB_beLessThan(NSNumber *expectedValue);
  247|       |
  248|       |    NIMBLE_EXPORT_INLINE NIMBLE_OVERLOADABLE
  249|      0|    NMBPredicate *beLessThan(NSNumber *expectedValue) {
  250|      0|        return NMB_beLessThan(expectedValue);
  251|      0|    }
  252|       |
  253|       |    DEFINE_OVERLOAD(long, @(expectedValue))
  254|       |    DEFINE_OVERLOAD(unsigned long, @(expectedValue))
  255|       |    DEFINE_OVERLOAD(int, @(expectedValue))
  256|       |    DEFINE_OVERLOAD(unsigned int, @(expectedValue))
  257|       |    DEFINE_OVERLOAD(float, @(expectedValue))
  258|       |    DEFINE_OVERLOAD(double, @(expectedValue))
  259|       |    DEFINE_OVERLOAD(long long, @(expectedValue))
  260|       |    DEFINE_OVERLOAD(unsigned long long, @(expectedValue))
  261|       |    DEFINE_OVERLOAD(char, @(expectedValue))
  262|       |    DEFINE_OVERLOAD(unsigned char, @(expectedValue))
  263|       |
  264|       |#undef DEFINE_OVERLOAD
  265|       |
  266|       |
  267|       |#define DEFINE_OVERLOAD(TYPE, EXPR) \
  268|       |    NIMBLE_EXPORT_INLINE NIMBLE_OVERLOADABLE \
  269|      0|    NMBPredicate *NMB_beLessThanOrEqualTo(TYPE expectedValue) { \
  270|      0|        return NMB_beLessThanOrEqualTo((EXPR)); \
  271|      0|    } \
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL23NMB_beLessThanOrEqualTol
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL23NMB_beLessThanOrEqualTom
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL23NMB_beLessThanOrEqualToi
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL23NMB_beLessThanOrEqualToj
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL23NMB_beLessThanOrEqualTof
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL23NMB_beLessThanOrEqualTod
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL23NMB_beLessThanOrEqualTox
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL23NMB_beLessThanOrEqualToy
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL23NMB_beLessThanOrEqualToc
  ------------------
  | Unexecuted instantiation: DSL.m:_ZL23NMB_beLessThanOrEqualToh
  ------------------
  272|       |    NIMBLE_SHORT_OVERLOADED(NMBPredicate *beLessThanOrEqualTo(TYPE expectedValue), \
  273|       |        NMB_beLessThanOrEqualTo(expectedValue));
  274|       |
  275|       |
  276|       |    NIMBLE_EXPORT NIMBLE_OVERLOADABLE
  277|       |    NMBPredicate *NMB_beLessThanOrEqualTo(NSNumber *expectedValue);
  278|       |
  279|       |    NIMBLE_EXPORT_INLINE NIMBLE_OVERLOADABLE
  280|      0|    NMBPredicate *beLessThanOrEqualTo(NSNumber *expectedValue) {
  281|      0|        return NMB_beLessThanOrEqualTo(expectedValue);
  282|      0|    }
  283|       |
  284|       |    DEFINE_OVERLOAD(long, @(expectedValue))
  285|       |    DEFINE_OVERLOAD(unsigned long, @(expectedValue))
  286|       |    DEFINE_OVERLOAD(int, @(expectedValue))
  287|       |    DEFINE_OVERLOAD(unsigned int, @(expectedValue))
  288|       |    DEFINE_OVERLOAD(float, @(expectedValue))
  289|       |    DEFINE_OVERLOAD(double, @(expectedValue))
  290|       |    DEFINE_OVERLOAD(long long, @(expectedValue))
  291|       |    DEFINE_OVERLOAD(unsigned long long, @(expectedValue))
  292|       |    DEFINE_OVERLOAD(char, @(expectedValue))
  293|       |    DEFINE_OVERLOAD(unsigned char, @(expectedValue))
  294|       |
  295|       |#undef DEFINE_OVERLOAD
  296|       |
  297|       |NIMBLE_EXPORT NMBPredicate *NMB_beTruthy(void);
  298|       |NIMBLE_SHORT(NMBPredicate *beTruthy(void),
  299|       |             NMB_beTruthy());
  300|       |
  301|       |NIMBLE_EXPORT NMBPredicate *NMB_beFalsy(void);
  302|       |NIMBLE_SHORT(NMBPredicate *beFalsy(void),
  303|       |             NMB_beFalsy());
  304|       |
  305|       |NIMBLE_EXPORT NMBPredicate *NMB_beTrue(void);
  306|       |NIMBLE_SHORT(NMBPredicate *beTrue(void),
  307|       |             NMB_beTrue());
  308|       |
  309|       |NIMBLE_EXPORT NMBPredicate *NMB_beFalse(void);
  310|       |NIMBLE_SHORT(NMBPredicate *beFalse(void),
  311|       |             NMB_beFalse());
  312|       |
  313|       |NIMBLE_EXPORT NMBPredicate *NMB_beNil(void);
  314|       |NIMBLE_SHORT(NMBPredicate *beNil(void),
  315|       |             NMB_beNil());
  316|       |
  317|       |NIMBLE_EXPORT NMBPredicate *NMB_beEmpty(void);
  318|       |NIMBLE_SHORT(NMBPredicate *beEmpty(void),
  319|       |             NMB_beEmpty());
  320|       |
  321|       |NIMBLE_EXPORT NMBPredicate *NMB_containWithNilTermination(id itemOrSubstring, ...) NS_REQUIRES_NIL_TERMINATION;
  322|       |#define NMB_contain(...) NMB_containWithNilTermination(__VA_ARGS__, nil)
  323|       |#ifndef NIMBLE_DISABLE_SHORT_SYNTAX
  324|       |#define contain(...) NMB_contain(__VA_ARGS__)
  325|       |#endif
  326|       |
  327|       |NIMBLE_EXPORT NMBPredicate *NMB_containElementSatisfying(BOOL(^predicate)(id));
  328|       |NIMBLE_SHORT(NMBPredicate *containElementSatisfying(BOOL(^predicate)(id)),
  329|       |             NMB_containElementSatisfying(predicate));
  330|       |
  331|       |NIMBLE_EXPORT NMBPredicate *NMB_endWith(id itemElementOrSubstring);
  332|       |NIMBLE_SHORT(NMBPredicate *endWith(id itemElementOrSubstring),
  333|       |             NMB_endWith(itemElementOrSubstring));
  334|       |
  335|       |NIMBLE_EXPORT NMBObjCRaiseExceptionPredicate *NMB_raiseException(void);
  336|       |NIMBLE_SHORT(NMBObjCRaiseExceptionPredicate *raiseException(void),
  337|       |             NMB_raiseException());
  338|       |
  339|       |NIMBLE_EXPORT NMBPredicate *NMB_match(id expectedValue);
  340|       |NIMBLE_SHORT(NMBPredicate *match(id expectedValue),
  341|       |             NMB_match(expectedValue));
  342|       |
  343|       |NIMBLE_EXPORT NMBPredicate *NMB_allPass(id matcher);
  344|       |NIMBLE_SHORT(NMBPredicate *allPass(id matcher),
  345|       |             NMB_allPass(matcher));
  346|       |
  347|       |NIMBLE_EXPORT NMBPredicate *NMB_satisfyAnyOfWithMatchers(id matchers);
  348|       |#define NMB_satisfyAnyOf(...) NMB_satisfyAnyOfWithMatchers(@[__VA_ARGS__])
  349|       |#ifndef NIMBLE_DISABLE_SHORT_SYNTAX
  350|       |#define satisfyAnyOf(...) NMB_satisfyAnyOf(__VA_ARGS__)
  351|       |#endif
  352|       |
  353|       |NIMBLE_EXPORT NMBPredicate *NMB_satisfyAllOfWithMatchers(id matchers);
  354|       |#define NMB_satisfyAllOf(...) NMB_satisfyAllOfWithMatchers(@[__VA_ARGS__])
  355|       |#ifndef NIMBLE_DISABLE_SHORT_SYNTAX
  356|       |#define satisfyAllOf(...) NMB_satisfyAllOf(__VA_ARGS__)
  357|       |#endif
  358|       |
  359|       |// In order to preserve breakpoint behavior despite using macros to fill in __FILE__ and __LINE__,
  360|       |// define a builder that populates __FILE__ and __LINE__, and returns a block that takes timeout
  361|       |// and action arguments. See https://github.com/Quick/Quick/pull/185 for details.
  362|       |typedef void (^NMBWaitUntilTimeoutBlock)(NSTimeInterval timeout, void (^action)(void (^)(void)));
  363|       |typedef void (^NMBWaitUntilBlock)(void (^action)(void (^)(void)));
  364|       |
  365|       |NIMBLE_EXPORT void NMB_failWithMessage(NSString *msg, NSString *file, NSUInteger line);
  366|       |
  367|       |NIMBLE_EXPORT NMBWaitUntilTimeoutBlock NMB_waitUntilTimeoutBuilder(NSString *file, NSUInteger line);
  368|       |NIMBLE_EXPORT NMBWaitUntilBlock NMB_waitUntilBuilder(NSString *file, NSUInteger line);
  369|       |
  370|       |NIMBLE_EXPORT void NMB_failWithMessage(NSString *msg, NSString *file, NSUInteger line);
  371|       |
  372|       |#define NMB_waitUntilTimeout NMB_waitUntilTimeoutBuilder(@(__FILE__), __LINE__)
  373|       |#define NMB_waitUntil NMB_waitUntilBuilder(@(__FILE__), __LINE__)
  374|       |
  375|       |#ifndef NIMBLE_DISABLE_SHORT_SYNTAX
  376|       |#define expect(...) NMB_expect(^{ return (__VA_ARGS__); }, @(__FILE__), __LINE__)
  377|       |#define expectAction(BLOCK) NMB_expectAction((BLOCK), @(__FILE__), __LINE__)
  378|       |#define failWithMessage(msg) NMB_failWithMessage(msg, @(__FILE__), __LINE__)
  379|       |#define fail() failWithMessage(@"fail() always fails")
  380|       |
  381|       |
  382|       |#define waitUntilTimeout NMB_waitUntilTimeout
  383|       |#define waitUntil NMB_waitUntil
  384|       |
  385|       |#undef NIMBLE_VALUE_OF
  386|       |
  387|       |#endif
  388|       |
  389|       |NS_ASSUME_NONNULL_END

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/NimbleObjectiveC/DSL.m:
    1|       |#import <Nimble/DSL.h>
    2|       |
    3|       |#if __has_include("Nimble-Swift.h")
    4|       |#import "Nimble-Swift.h"
    5|       |#else
    6|       |#import <Nimble/Nimble-Swift.h>
    7|       |#endif
    8|       |
    9|       |
   10|       |NS_ASSUME_NONNULL_BEGIN
   11|       |
   12|       |
   13|      0|NIMBLE_EXPORT NIMBLE_OVERLOADABLE NMBExpectation *__nonnull NMB_expect(id __nullable(^actualBlock)(void), NSString *__nonnull file, NSUInteger line) {
   14|      0|    return [[NMBExpectation alloc] initWithActualBlock:actualBlock
   15|      0|                                              negative:NO
   16|      0|                                                  file:file
   17|      0|                                                  line:line];
   18|      0|}
   19|       |
   20|      0|NIMBLE_EXPORT NMBExpectation *NMB_expectAction(void(^actualBlock)(void), NSString *file, NSUInteger line) {
   21|      0|    return NMB_expect(^id{
   22|      0|        actualBlock();
   23|      0|        return nil;
   24|      0|    }, file, line);
   25|      0|}
   26|       |
   27|      0|NIMBLE_EXPORT void NMB_failWithMessage(NSString *msg, NSString *file, NSUInteger line) {
   28|      0|    return [NMBExpectation failWithMessage:msg file:file line:line];
   29|      0|}
   30|       |
   31|      0|NIMBLE_EXPORT NMBPredicate *NMB_beAnInstanceOf(Class expectedClass) {
   32|      0|    return [NMBPredicate beAnInstanceOfMatcher:expectedClass];
   33|      0|}
   34|       |
   35|      0|NIMBLE_EXPORT NMBPredicate *NMB_beAKindOf(Class expectedClass) {
   36|      0|    return [NMBPredicate beAKindOfMatcher:expectedClass];
   37|      0|}
   38|       |
   39|      0|NIMBLE_EXPORT NIMBLE_OVERLOADABLE NMBObjCBeCloseToPredicate *NMB_beCloseTo(NSNumber *expectedValue) {
   40|      0|    return [NMBPredicate beCloseToMatcher:expectedValue within:0.001];
   41|      0|}
   42|       |
   43|      0|NIMBLE_EXPORT NMBPredicate *NMB_beginWith(id itemElementOrSubstring) {
   44|      0|    return [NMBPredicate beginWithMatcher:itemElementOrSubstring];
   45|      0|}
   46|       |
   47|      0|NIMBLE_EXPORT NIMBLE_OVERLOADABLE NMBPredicate *NMB_beGreaterThan(NSNumber *expectedValue) {
   48|      0|    return [NMBPredicate beGreaterThanMatcher:expectedValue];
   49|      0|}
   50|       |
   51|      0|NIMBLE_EXPORT NIMBLE_OVERLOADABLE NMBPredicate *NMB_beGreaterThanOrEqualTo(NSNumber *expectedValue) {
   52|      0|    return [NMBPredicate beGreaterThanOrEqualToMatcher:expectedValue];
   53|      0|}
   54|       |
   55|      0|NIMBLE_EXPORT NMBPredicate *NMB_beIdenticalTo(id expectedInstance) {
   56|      0|    return [NMBPredicate beIdenticalToMatcher:expectedInstance];
   57|      0|}
   58|       |
   59|      0|NIMBLE_EXPORT NMBPredicate *NMB_be(id expectedInstance) {
   60|      0|    return [NMBPredicate beIdenticalToMatcher:expectedInstance];
   61|      0|}
   62|       |
   63|      0|NIMBLE_EXPORT NIMBLE_OVERLOADABLE NMBPredicate *NMB_beLessThan(NSNumber *expectedValue) {
   64|      0|    return [NMBPredicate beLessThanMatcher:expectedValue];
   65|      0|}
   66|       |
   67|      0|NIMBLE_EXPORT NIMBLE_OVERLOADABLE NMBPredicate *NMB_beLessThanOrEqualTo(NSNumber *expectedValue) {
   68|      0|    return [NMBPredicate beLessThanOrEqualToMatcher:expectedValue];
   69|      0|}
   70|       |
   71|      0|NIMBLE_EXPORT NMBPredicate *NMB_beTruthy() {
   72|      0|    return [NMBPredicate beTruthyMatcher];
   73|      0|}
   74|       |
   75|      0|NIMBLE_EXPORT NMBPredicate *NMB_beFalsy() {
   76|      0|    return [NMBPredicate beFalsyMatcher];
   77|      0|}
   78|       |
   79|      0|NIMBLE_EXPORT NMBPredicate *NMB_beTrue() {
   80|      0|    return [NMBPredicate beTrueMatcher];
   81|      0|}
   82|       |
   83|      0|NIMBLE_EXPORT NMBPredicate *NMB_beFalse() {
   84|      0|    return [NMBPredicate beFalseMatcher];
   85|      0|}
   86|       |
   87|      0|NIMBLE_EXPORT NMBPredicate *NMB_beNil() {
   88|      0|    return [NMBPredicate beNilMatcher];
   89|      0|}
   90|       |
   91|      0|NIMBLE_EXPORT NMBPredicate *NMB_beEmpty() {
   92|      0|    return [NMBPredicate beEmptyMatcher];
   93|      0|}
   94|       |
   95|      0|NIMBLE_EXPORT NMBPredicate *NMB_containWithNilTermination(id itemOrSubstring, ...) {
   96|      0|    NSMutableArray *itemOrSubstringArray = [NSMutableArray array];
   97|       |
   98|      0|    if (itemOrSubstring) {
   99|      0|        [itemOrSubstringArray addObject:itemOrSubstring];
  100|       |
  101|      0|        va_list args;
  102|      0|        va_start(args, itemOrSubstring);
  103|      0|        id next;
  104|      0|        while ((next = va_arg(args, id))) {
  105|      0|            [itemOrSubstringArray addObject:next];
  106|      0|        }
  107|      0|        va_end(args);
  108|      0|    }
  109|       |
  110|      0|    return [NMBPredicate containMatcher:itemOrSubstringArray];
  111|      0|}
  112|       |
  113|      0|NIMBLE_EXPORT NMBPredicate *NMB_containElementSatisfying(BOOL(^predicate)(id)) {
  114|      0|    return [NMBPredicate containElementSatisfyingMatcher:predicate];
  115|      0|}
  116|       |
  117|      0|NIMBLE_EXPORT NMBPredicate *NMB_endWith(id itemElementOrSubstring) {
  118|      0|    return [NMBPredicate endWithMatcher:itemElementOrSubstring];
  119|      0|}
  120|       |
  121|      0|NIMBLE_EXPORT NIMBLE_OVERLOADABLE NMBPredicate *NMB_equal(__nullable id expectedValue) {
  122|      0|    return [NMBPredicate equalMatcher:expectedValue];
  123|      0|}
  124|       |
  125|      0|NIMBLE_EXPORT NIMBLE_OVERLOADABLE NMBPredicate *NMB_haveCount(id expectedValue) {
  126|      0|    return [NMBPredicate haveCountMatcher:expectedValue];
  127|      0|}
  128|       |
  129|      0|NIMBLE_EXPORT NMBPredicate *NMB_match(id expectedValue) {
  130|      0|    return [NMBPredicate matchMatcher:expectedValue];
  131|      0|}
  132|       |
  133|      0|NIMBLE_EXPORT NMBPredicate *NMB_allPass(id expectedValue) {
  134|      0|    return [NMBPredicate allPassMatcher:expectedValue];
  135|      0|}
  136|       |
  137|      0|NIMBLE_EXPORT NMBPredicate *NMB_satisfyAnyOfWithMatchers(id matchers) {
  138|      0|    return [NMBPredicate satisfyAnyOfMatcher:matchers];
  139|      0|}
  140|       |
  141|      0|NIMBLE_EXPORT NMBPredicate *NMB_satisfyAllOfWithMatchers(id matchers) {
  142|      0|    return [NMBPredicate satisfyAllOfMatcher:matchers];
  143|      0|}
  144|       |
  145|      0|NIMBLE_EXPORT NMBObjCRaiseExceptionPredicate *NMB_raiseException() {
  146|      0|    return [NMBPredicate raiseExceptionMatcher];
  147|      0|}
  148|       |
  149|      0|NIMBLE_EXPORT NMBWaitUntilTimeoutBlock NMB_waitUntilTimeoutBuilder(NSString *file, NSUInteger line) {
  150|      0|    return ^(NSTimeInterval timeout, void (^ _Nonnull action)(void (^ _Nonnull)(void))) {
  151|      0|        [NMBWait untilTimeout:timeout file:file line:line action:action];
  152|      0|    };
  153|      0|}
  154|       |
  155|      0|NIMBLE_EXPORT NMBWaitUntilBlock NMB_waitUntilBuilder(NSString *file, NSUInteger line) {
  156|      0|  return ^(void (^ _Nonnull action)(void (^ _Nonnull)(void))) {
  157|      0|    [NMBWait untilFile:file line:line action:action];
  158|      0|  };
  159|      0|}
  160|       |
  161|       |NS_ASSUME_NONNULL_END

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/NimbleObjectiveC/NMBExceptionCapture.m:
    1|       |#import "NMBExceptionCapture.h"
    2|       |
    3|       |@interface NMBExceptionCapture ()
    4|       |@property (nonatomic, copy) void(^ _Nullable handler)(NSException * _Nullable);
    5|       |@property (nonatomic, copy) void(^ _Nullable finally)(void);
    6|       |@end
    7|       |
    8|       |@implementation NMBExceptionCapture
    9|       |
   10|     19|- (nonnull instancetype)initWithHandler:(void(^ _Nullable)(NSException * _Nonnull))handler finally:(void(^ _Nullable)(void))finally {
   11|     19|    self = [super init];
   12|     19|    if (self) {
   13|     19|        self.handler = handler;
   14|     19|        self.finally = finally;
   15|     19|    }
   16|     19|    return self;
   17|     19|}
   18|       |
   19|     19|- (void)tryBlock:(__attribute__((noescape)) void(^ _Nonnull)(void))unsafeBlock {
   20|     19|    @try {
   21|     19|        unsafeBlock();
   22|     19|    }
   23|     19|    @catch (NSException *exception) {
   24|     19|        if (self.handler) {
   25|      0|            self.handler(exception);
   26|      0|        }
   27|     19|    }
   28|     19|    @finally {
   29|     19|        if (self.finally) {
   30|      0|            self.finally();
   31|      0|        }
   32|     19|    }
   33|     19|}
   34|       |
   35|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/NimbleObjectiveC/NMBStringify.m:
    1|       |#import "NMBStringify.h"
    2|       |
    3|       |#if __has_include("Nimble-Swift.h")
    4|       |#import "Nimble-Swift.h"
    5|       |#else
    6|       |#import <Nimble/Nimble-Swift.h>
    7|       |#endif
    8|       |
    9|      0|NSString *_Nonnull NMBStringify(id _Nullable anyObject) {
   10|      0|    return [NMBStringer stringify:anyObject];
   11|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/Nimble/Sources/NimbleObjectiveC/XCTestObservationCenter+Register.m:
    1|       |#import <XCTest/XCTest.h>
    2|       |
    3|       |#if __has_include("Nimble-Swift.h")
    4|       |#import "Nimble-Swift.h"
    5|       |#else
    6|       |#import <Nimble/Nimble-Swift.h>
    7|       |#endif
    8|       |
    9|       |#pragma mark - Private
   10|       |
   11|       |@implementation XCTestObservationCenter (Register)
   12|       |
   13|      1|+ (void)load {
   14|      1|    [[XCTestObservationCenter sharedTestObservationCenter] addTestObserver:[CurrentTestCaseTracker sharedInstance]];
   15|      1|}
   16|       |
   17|       |@end

