/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCCTLibrary/GDTCCTCompressionHelper.m:
    1|       |/*
    2|       | * Copyright 2020 Google LLC
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCCTLibrary/Private/GDTCCTCompressionHelper.h"
   18|       |
   19|       |#import <zlib.h>
   20|       |
   21|       |@implementation GDTCCTCompressionHelper
   22|       |
   23|      0|+ (nullable NSData *)gzippedData:(NSData *)data {
   24|      0|#if defined(__LP64__) && __LP64__
   25|       |  // Don't support > 32bit length for 64 bit, see note in header.
   26|      0|  if (data.length > UINT_MAX) {
   27|      0|    return nil;
   28|      0|  }
   29|      0|#endif
   30|       |
   31|      0|  enum { kChunkSize = 1024 };
   32|       |
   33|      0|  const void *bytes = [data bytes];
   34|      0|  NSUInteger length = [data length];
   35|       |
   36|      0|  int level = Z_DEFAULT_COMPRESSION;
   37|      0|  if (!bytes || !length) {
   38|      0|    return nil;
   39|      0|  }
   40|       |
   41|      0|  z_stream strm;
   42|      0|  bzero(&strm, sizeof(z_stream));
   43|       |
   44|      0|  int memLevel = 8;          // Default.
   45|      0|  int windowBits = 15 + 16;  // Enable gzip header instead of zlib header.
   46|       |
   47|      0|  int retCode;
   48|      0|  if (deflateInit2(&strm, level, Z_DEFLATED, windowBits, memLevel, Z_DEFAULT_STRATEGY) != Z_OK) {
   49|      0|    return nil;
   50|      0|  }
   51|       |
   52|       |  // Hint the size at 1/4 the input size.
   53|      0|  NSMutableData *result = [NSMutableData dataWithCapacity:(length / 4)];
   54|      0|  unsigned char output[kChunkSize];
   55|       |
   56|       |  // Setup the input.
   57|      0|  strm.avail_in = (unsigned int)length;
   58|      0|  strm.next_in = (unsigned char *)bytes;
   59|       |
   60|       |  // Collect the data.
   61|      0|  do {
   62|       |    // update what we're passing in
   63|      0|    strm.avail_out = kChunkSize;
   64|      0|    strm.next_out = output;
   65|      0|    retCode = deflate(&strm, Z_FINISH);
   66|      0|    if ((retCode != Z_OK) && (retCode != Z_STREAM_END)) {
   67|      0|      deflateEnd(&strm);
   68|      0|      return nil;
   69|      0|    }
   70|       |    // Collect what we got.
   71|      0|    unsigned gotBack = kChunkSize - strm.avail_out;
   72|      0|    if (gotBack > 0) {
   73|      0|      [result appendBytes:output length:gotBack];
   74|      0|    }
   75|       |
   76|      0|  } while (retCode == Z_OK);
   77|       |
   78|       |  // If the loop exits, it used all input and the stream ended.
   79|      0|  NSAssert(strm.avail_in == 0,
   80|      0|           @"Should have finished deflating without using all input, %u bytes left", strm.avail_in);
   81|      0|  NSAssert(retCode == Z_STREAM_END,
   82|      0|           @"thought we finished deflate w/o getting a result of stream end, code %d", retCode);
   83|       |
   84|       |  // Clean up.
   85|      0|  deflateEnd(&strm);
   86|       |
   87|      0|  return result;
   88|      0|}
   89|       |
   90|      0|+ (BOOL)isGzipped:(NSData *)data {
   91|      0|  const UInt8 *bytes = (const UInt8 *)data.bytes;
   92|      0|  return (data.length >= 2 && bytes[0] == 0x1f && bytes[1] == 0x8b);
   93|      0|}
   94|       |
   95|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCCTLibrary/GDTCCTNanopbHelpers.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCCTLibrary/Private/GDTCCTNanopbHelpers.h"
   18|       |
   19|       |#if TARGET_OS_IOS || TARGET_OS_TV
   20|       |#import <UIKit/UIKit.h>
   21|       |#elif TARGET_OS_OSX
   22|       |#import <AppKit/AppKit.h>
   23|       |#endif  // TARGET_OS_IOS || TARGET_OS_TV
   24|       |
   25|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORPlatform.h"
   26|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORClock.h"
   27|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORConsoleLogger.h"
   28|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCOREvent.h"
   29|       |
   30|       |#import <nanopb/pb.h>
   31|       |#import <nanopb/pb_decode.h>
   32|       |#import <nanopb/pb_encode.h>
   33|       |
   34|       |#import "GoogleDataTransport/GDTCCTLibrary/Public/GDTCOREvent+GDTCCTSupport.h"
   35|       |
   36|       |#pragma mark - General purpose encoders
   37|       |
   38|      0|pb_bytes_array_t *GDTCCTEncodeString(NSString *string) {
   39|      0|  NSData *stringBytes = [string dataUsingEncoding:NSUTF8StringEncoding];
   40|      0|  return GDTCCTEncodeData(stringBytes);
   41|      0|}
   42|       |
   43|      0|pb_bytes_array_t *GDTCCTEncodeData(NSData *data) {
   44|      0|  pb_bytes_array_t *pbBytesArray = calloc(1, PB_BYTES_ARRAY_T_ALLOCSIZE(data.length));
   45|      0|  if (pbBytesArray != NULL) {
   46|      0|    [data getBytes:pbBytesArray->bytes length:data.length];
   47|      0|    pbBytesArray->size = (pb_size_t)data.length;
   48|      0|  }
   49|      0|  return pbBytesArray;
   50|      0|}
   51|       |
   52|       |#pragma mark - CCT object constructors
   53|       |
   54|      0|NSData *_Nullable GDTCCTEncodeBatchedLogRequest(gdt_cct_BatchedLogRequest *batchedLogRequest) {
   55|      0|  pb_ostream_t sizestream = PB_OSTREAM_SIZING;
   56|       |  // Encode 1 time to determine the size.
   57|      0|  if (!pb_encode(&sizestream, gdt_cct_BatchedLogRequest_fields, batchedLogRequest)) {
   58|      0|    GDTCORLogError(GDTCORMCEGeneralError, @"Error in nanopb encoding for size: %s",
   59|      0|                   PB_GET_ERROR(&sizestream));
   60|      0|  }
   61|       |
   62|       |  // Encode a 2nd time to actually get the bytes from it.
   63|      0|  size_t bufferSize = sizestream.bytes_written;
   64|      0|  CFMutableDataRef dataRef = CFDataCreateMutable(CFAllocatorGetDefault(), bufferSize);
   65|      0|  CFDataSetLength(dataRef, bufferSize);
   66|      0|  pb_ostream_t ostream = pb_ostream_from_buffer((void *)CFDataGetBytePtr(dataRef), bufferSize);
   67|      0|  if (!pb_encode(&ostream, gdt_cct_BatchedLogRequest_fields, batchedLogRequest)) {
   68|      0|    GDTCORLogError(GDTCORMCEGeneralError, @"Error in nanopb encoding for bytes: %s",
   69|      0|                   PB_GET_ERROR(&ostream));
   70|      0|  }
   71|       |
   72|      0|  return CFBridgingRelease(dataRef);
   73|      0|}
   74|       |
   75|       |gdt_cct_BatchedLogRequest GDTCCTConstructBatchedLogRequest(
   76|      0|    NSDictionary<NSString *, NSSet<GDTCOREvent *> *> *logMappingIDToLogSet) {
   77|      0|  gdt_cct_BatchedLogRequest batchedLogRequest = gdt_cct_BatchedLogRequest_init_default;
   78|      0|  NSUInteger numberOfLogRequests = logMappingIDToLogSet.count;
   79|      0|  gdt_cct_LogRequest *logRequests = calloc(numberOfLogRequests, sizeof(gdt_cct_LogRequest));
   80|      0|  if (logRequests == NULL) {
   81|      0|    return batchedLogRequest;
   82|      0|  }
   83|       |
   84|      0|  __block int i = 0;
   85|      0|  [logMappingIDToLogSet enumerateKeysAndObjectsUsingBlock:^(NSString *_Nonnull logMappingID,
   86|      0|                                                            NSSet<GDTCOREvent *> *_Nonnull logSet,
   87|      0|                                                            BOOL *_Nonnull stop) {
   88|      0|    int32_t logSource = [logMappingID intValue];
   89|      0|    gdt_cct_LogRequest logRequest = GDTCCTConstructLogRequest(logSource, logSet);
   90|      0|    logRequests[i] = logRequest;
   91|      0|    i++;
   92|      0|  }];
   93|       |
   94|      0|  batchedLogRequest.log_request = logRequests;
   95|      0|  batchedLogRequest.log_request_count = (pb_size_t)numberOfLogRequests;
   96|      0|  return batchedLogRequest;
   97|      0|}
   98|       |
   99|       |gdt_cct_LogRequest GDTCCTConstructLogRequest(int32_t logSource,
  100|      0|                                             NSSet<GDTCOREvent *> *_Nonnull logSet) {
  101|      0|  if (logSet.count == 0) {
  102|      0|    GDTCORLogError(GDTCORMCEGeneralError, @"%@",
  103|      0|                   @"An empty event set can't be serialized to proto.");
  104|      0|    gdt_cct_LogRequest logRequest = gdt_cct_LogRequest_init_default;
  105|      0|    return logRequest;
  106|      0|  }
  107|      0|  gdt_cct_LogRequest logRequest = gdt_cct_LogRequest_init_default;
  108|      0|  logRequest.log_source = logSource;
  109|      0|  logRequest.has_log_source = 1;
  110|      0|  logRequest.client_info = GDTCCTConstructClientInfo();
  111|      0|  logRequest.has_client_info = 1;
  112|      0|  logRequest.log_event = calloc(logSet.count, sizeof(gdt_cct_LogEvent));
  113|      0|  if (logRequest.log_event == NULL) {
  114|      0|    return logRequest;
  115|      0|  }
  116|      0|  int i = 0;
  117|      0|  for (GDTCOREvent *log in logSet) {
  118|      0|    gdt_cct_LogEvent logEvent = GDTCCTConstructLogEvent(log);
  119|      0|    logRequest.log_event[i] = logEvent;
  120|      0|    i++;
  121|      0|  }
  122|      0|  logRequest.log_event_count = (pb_size_t)logSet.count;
  123|       |
  124|      0|  GDTCORClock *currentTime = [GDTCORClock snapshot];
  125|      0|  logRequest.request_time_ms = currentTime.timeMillis;
  126|      0|  logRequest.has_request_time_ms = 1;
  127|      0|  logRequest.request_uptime_ms = [currentTime uptimeMilliseconds];
  128|      0|  logRequest.has_request_uptime_ms = 1;
  129|       |
  130|      0|  return logRequest;
  131|      0|}
  132|       |
  133|      0|gdt_cct_LogEvent GDTCCTConstructLogEvent(GDTCOREvent *event) {
  134|      0|  gdt_cct_LogEvent logEvent = gdt_cct_LogEvent_init_default;
  135|      0|  logEvent.event_time_ms = event.clockSnapshot.timeMillis;
  136|      0|  logEvent.has_event_time_ms = 1;
  137|      0|  logEvent.event_uptime_ms = [event.clockSnapshot uptimeMilliseconds];
  138|      0|  logEvent.has_event_uptime_ms = 1;
  139|      0|  logEvent.timezone_offset_seconds = event.clockSnapshot.timezoneOffsetSeconds;
  140|      0|  logEvent.has_timezone_offset_seconds = 1;
  141|      0|  if (event.customBytes) {
  142|      0|    NSData *networkConnectionInfoData = event.networkConnectionInfoData;
  143|      0|    if (networkConnectionInfoData) {
  144|      0|      [networkConnectionInfoData getBytes:&logEvent.network_connection_info
  145|      0|                                   length:networkConnectionInfoData.length];
  146|      0|      logEvent.has_network_connection_info = 1;
  147|      0|    }
  148|      0|    NSNumber *eventCode = event.eventCode;
  149|      0|    if (eventCode != nil) {
  150|      0|      logEvent.has_event_code = 1;
  151|      0|      logEvent.event_code = [eventCode intValue];
  152|      0|    }
  153|      0|  }
  154|      0|  NSError *error;
  155|      0|  NSData *extensionBytes;
  156|      0|  extensionBytes = event.serializedDataObjectBytes;
  157|      0|  if (error) {
  158|      0|    GDTCORLogWarning(GDTCORMCWFileReadError,
  159|      0|                     @"There was an error reading extension bytes from disk: %@", error);
  160|      0|    return logEvent;
  161|      0|  }
  162|      0|  logEvent.source_extension = GDTCCTEncodeData(extensionBytes);  // read bytes from the file.
  163|      0|  return logEvent;
  164|      0|}
  165|       |
  166|      0|gdt_cct_ClientInfo GDTCCTConstructClientInfo() {
  167|      0|  gdt_cct_ClientInfo clientInfo = gdt_cct_ClientInfo_init_default;
  168|      0|  clientInfo.client_type = gdt_cct_ClientInfo_ClientType_IOS_FIREBASE;
  169|      0|  clientInfo.has_client_type = 1;
  170|      0|#if TARGET_OS_IOS || TARGET_OS_TV
  171|      0|  clientInfo.ios_client_info = GDTCCTConstructiOSClientInfo();
  172|      0|  clientInfo.has_ios_client_info = 1;
  173|       |#elif TARGET_OS_OSX
  174|       |  // TODO(mikehaney24): Expand the proto to include macOS client info.
  175|       |#endif
  176|      0|  return clientInfo;
  177|      0|}
  178|       |
  179|      0|gdt_cct_IosClientInfo GDTCCTConstructiOSClientInfo() {
  180|      0|  gdt_cct_IosClientInfo iOSClientInfo = gdt_cct_IosClientInfo_init_default;
  181|      0|#if TARGET_OS_IOS || TARGET_OS_TV
  182|      0|  UIDevice *device = [UIDevice currentDevice];
  183|      0|  NSBundle *bundle = [NSBundle mainBundle];
  184|      0|  NSLocale *locale = [NSLocale currentLocale];
  185|      0|  iOSClientInfo.os_full_version = GDTCCTEncodeString(device.systemVersion);
  186|      0|  NSArray *versionComponents = [device.systemVersion componentsSeparatedByString:@"."];
  187|      0|  iOSClientInfo.os_major_version = GDTCCTEncodeString(versionComponents[0]);
  188|      0|  NSString *version = [bundle objectForInfoDictionaryKey:(NSString *)kCFBundleVersionKey];
  189|      0|  if (version) {
  190|      0|    iOSClientInfo.application_build = GDTCCTEncodeString(version);
  191|      0|  }
  192|      0|  NSString *countryCode = [locale objectForKey:NSLocaleCountryCode];
  193|      0|  if (countryCode) {
  194|      0|    iOSClientInfo.country = GDTCCTEncodeString([locale objectForKey:NSLocaleCountryCode]);
  195|      0|  }
  196|      0|  iOSClientInfo.model = GDTCCTEncodeString(GDTCORDeviceModel());
  197|      0|  NSString *languageCode = bundle.preferredLocalizations.firstObject;
  198|      0|  iOSClientInfo.language_code =
  199|      0|      languageCode ? GDTCCTEncodeString(languageCode) : GDTCCTEncodeString(@"en");
  200|      0|  iOSClientInfo.application_bundle_id = GDTCCTEncodeString(bundle.bundleIdentifier);
  201|      0|#endif
  202|      0|  return iOSClientInfo;
  203|      0|}
  204|       |
  205|      0|NSData *GDTCCTConstructNetworkConnectionInfoData() {
  206|      0|  gdt_cct_NetworkConnectionInfo networkConnectionInfo = gdt_cct_NetworkConnectionInfo_init_default;
  207|      0|  NSInteger currentNetworkType = GDTCORNetworkTypeMessage();
  208|      0|  if (currentNetworkType) {
  209|      0|    networkConnectionInfo.has_network_type = 1;
  210|      0|    if (currentNetworkType == GDTCORNetworkTypeMobile) {
  211|      0|      networkConnectionInfo.network_type = gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE;
  212|      0|      networkConnectionInfo.mobile_subtype = GDTCCTNetworkConnectionInfoNetworkMobileSubtype();
  213|      0|      if (networkConnectionInfo.mobile_subtype !=
  214|      0|          gdt_cct_NetworkConnectionInfo_MobileSubtype_UNKNOWN_MOBILE_SUBTYPE) {
  215|      0|        networkConnectionInfo.has_mobile_subtype = 1;
  216|      0|      }
  217|      0|    } else {
  218|      0|      networkConnectionInfo.network_type = gdt_cct_NetworkConnectionInfo_NetworkType_WIFI;
  219|      0|    }
  220|      0|  }
  221|      0|  NSData *networkConnectionInfoData = [NSData dataWithBytes:&networkConnectionInfo
  222|      0|                                                     length:sizeof(networkConnectionInfo)];
  223|      0|  return networkConnectionInfoData;
  224|      0|}
  225|       |
  226|      0|gdt_cct_NetworkConnectionInfo_MobileSubtype GDTCCTNetworkConnectionInfoNetworkMobileSubtype() {
  227|      0|  NSNumber *networkMobileSubtypeMessage = @(GDTCORNetworkMobileSubTypeMessage());
  228|      0|  if (!networkMobileSubtypeMessage.intValue) {
  229|      0|    return gdt_cct_NetworkConnectionInfo_MobileSubtype_UNKNOWN_MOBILE_SUBTYPE;
  230|      0|  }
  231|      0|  static NSDictionary<NSNumber *, NSNumber *> *MessageToNetworkSubTypeMessage;
  232|      0|  static dispatch_once_t onceToken;
  233|      0|  dispatch_once(&onceToken, ^{
  234|      0|    MessageToNetworkSubTypeMessage = @{
  235|      0|      @(GDTCORNetworkMobileSubtypeGPRS) : @(gdt_cct_NetworkConnectionInfo_MobileSubtype_GPRS),
  236|      0|      @(GDTCORNetworkMobileSubtypeEdge) : @(gdt_cct_NetworkConnectionInfo_MobileSubtype_EDGE),
  237|      0|      @(GDTCORNetworkMobileSubtypeWCDMA) :
  238|      0|          @(gdt_cct_NetworkConnectionInfo_MobileSubtype_UNKNOWN_MOBILE_SUBTYPE),
  239|      0|      @(GDTCORNetworkMobileSubtypeHSDPA) : @(gdt_cct_NetworkConnectionInfo_MobileSubtype_HSDPA),
  240|      0|      @(GDTCORNetworkMobileSubtypeHSUPA) : @(gdt_cct_NetworkConnectionInfo_MobileSubtype_HSUPA),
  241|      0|      @(GDTCORNetworkMobileSubtypeCDMA1x) : @(gdt_cct_NetworkConnectionInfo_MobileSubtype_CDMA),
  242|      0|      @(GDTCORNetworkMobileSubtypeCDMAEVDORev0) :
  243|      0|          @(gdt_cct_NetworkConnectionInfo_MobileSubtype_EVDO_0),
  244|      0|      @(GDTCORNetworkMobileSubtypeCDMAEVDORevA) :
  245|      0|          @(gdt_cct_NetworkConnectionInfo_MobileSubtype_EVDO_A),
  246|      0|      @(GDTCORNetworkMobileSubtypeCDMAEVDORevB) :
  247|      0|          @(gdt_cct_NetworkConnectionInfo_MobileSubtype_EVDO_B),
  248|      0|      @(GDTCORNetworkMobileSubtypeHRPD) : @(gdt_cct_NetworkConnectionInfo_MobileSubtype_EHRPD),
  249|      0|      @(GDTCORNetworkMobileSubtypeLTE) : @(gdt_cct_NetworkConnectionInfo_MobileSubtype_LTE),
  250|      0|    };
  251|      0|  });
  252|      0|  NSNumber *networkMobileSubtype = MessageToNetworkSubTypeMessage[networkMobileSubtypeMessage];
  253|      0|  return networkMobileSubtype.intValue;
  254|      0|}
  255|       |
  256|       |#pragma mark - CCT Object decoders
  257|       |
  258|      0|gdt_cct_LogResponse GDTCCTDecodeLogResponse(NSData *data, NSError **error) {
  259|      0|  gdt_cct_LogResponse response = gdt_cct_LogResponse_init_default;
  260|      0|  pb_istream_t istream = pb_istream_from_buffer([data bytes], [data length]);
  261|      0|  if (!pb_decode(&istream, gdt_cct_LogResponse_fields, &response)) {
  262|      0|    NSString *nanopb_error = [NSString stringWithFormat:@"%s", PB_GET_ERROR(&istream)];
  263|      0|    NSDictionary *userInfo = @{@"nanopb error:" : nanopb_error};
  264|      0|    if (error != NULL) {
  265|      0|      *error = [NSError errorWithDomain:NSURLErrorDomain code:-1 userInfo:userInfo];
  266|      0|    }
  267|      0|    response = (gdt_cct_LogResponse)gdt_cct_LogResponse_init_default;
  268|      0|  }
  269|      0|  return response;
  270|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCCTLibrary/GDTCCTUploadOperation.m:
    1|       |/*
    2|       | * Copyright 2020 Google LLC
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCCTLibrary/Private/GDTCCTUploadOperation.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORPlatform.h"
   26|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORRegistrar.h"
   27|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORStorageProtocol.h"
   28|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORUploadBatch.h"
   29|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORConsoleLogger.h"
   30|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCOREvent.h"
   31|       |
   32|       |#import <nanopb/pb.h>
   33|       |#import <nanopb/pb_decode.h>
   34|       |#import <nanopb/pb_encode.h>
   35|       |
   36|       |#import <GoogleUtilities/GULURLSessionDataResponse.h>
   37|       |#import <GoogleUtilities/NSURLSession+GULPromises.h>
   38|       |#import "GoogleDataTransport/GDTCCTLibrary/Private/GDTCCTCompressionHelper.h"
   39|       |#import "GoogleDataTransport/GDTCCTLibrary/Private/GDTCCTNanopbHelpers.h"
   40|       |
   41|       |#import "GoogleDataTransport/GDTCCTLibrary/Protogen/nanopb/cct.nanopb.h"
   42|       |
   43|       |NS_ASSUME_NONNULL_BEGIN
   44|       |
   45|       |#ifdef GDTCOR_VERSION
   46|       |#define STR(x) STR_EXPAND(x)
   47|       |#define STR_EXPAND(x) #x
   48|       |static NSString *const kGDTCCTSupportSDKVersion = @STR(GDTCOR_VERSION);
   49|       |#else
   50|       |static NSString *const kGDTCCTSupportSDKVersion = @"UNKNOWN";
   51|       |#endif  // GDTCOR_VERSION
   52|       |
   53|       |typedef void (^GDTCCTUploaderURLTaskCompletion)(NSNumber *batchID,
   54|       |                                                NSSet<GDTCOREvent *> *_Nullable events,
   55|       |                                                NSData *_Nullable data,
   56|       |                                                NSURLResponse *_Nullable response,
   57|       |                                                NSError *_Nullable error);
   58|       |
   59|       |typedef void (^GDTCCTUploaderEventBatchBlock)(NSNumber *_Nullable batchID,
   60|       |                                              NSSet<GDTCOREvent *> *_Nullable events);
   61|       |
   62|       |@interface GDTCCTUploadOperation () <NSURLSessionDelegate>
   63|       |
   64|       |/// The properties to store parameters passed in the initializer. See the initialized docs for
   65|       |/// details.
   66|       |@property(nonatomic, readonly) GDTCORTarget target;
   67|       |@property(nonatomic, readonly) GDTCORUploadConditions conditions;
   68|       |@property(nonatomic, readonly) NSURL *uploadURL;
   69|       |@property(nonatomic, readonly) id<GDTCORStoragePromiseProtocol> storage;
   70|       |@property(nonatomic, readonly) id<GDTCCTUploadMetadataProvider> metadataProvider;
   71|       |
   72|       |/** The URL session that will attempt upload. */
   73|       |@property(nonatomic) NSURLSession *uploaderSession;
   74|       |
   75|       |/// NSOperation state properties implementation.
   76|       |@property(nonatomic, readwrite, getter=isExecuting) BOOL executing;
   77|       |@property(nonatomic, readwrite, getter=isFinished) BOOL finished;
   78|       |
   79|       |@property(nonatomic, readwrite) BOOL uploadAttempted;
   80|       |
   81|       |@end
   82|       |
   83|       |@implementation GDTCCTUploadOperation
   84|       |
   85|       |- (instancetype)initWithTarget:(GDTCORTarget)target
   86|       |                    conditions:(GDTCORUploadConditions)conditions
   87|       |                     uploadURL:(NSURL *)uploadURL
   88|       |                         queue:(dispatch_queue_t)queue
   89|       |                       storage:(id<GDTCORStoragePromiseProtocol>)storage
   90|      4|              metadataProvider:(id<GDTCCTUploadMetadataProvider>)metadataProvider {
   91|      4|  self = [super init];
   92|      4|  if (self) {
   93|      4|    _uploaderQueue = queue;
   94|      4|    _target = target;
   95|      4|    _conditions = conditions;
   96|      4|    _uploadURL = uploadURL;
   97|      4|    _storage = storage;
   98|      4|    _metadataProvider = metadataProvider;
   99|      4|  }
  100|      4|  return self;
  101|      4|}
  102|       |
  103|      0|- (NSURLSession *)uploaderSessionCreateIfNeeded {
  104|      0|  if (_uploaderSession == nil) {
  105|      0|    NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];
  106|      0|    _uploaderSession = [NSURLSession sessionWithConfiguration:config
  107|      0|                                                     delegate:self
  108|      0|                                                delegateQueue:nil];
  109|      0|  }
  110|      0|  return _uploaderSession;
  111|      0|}
  112|       |
  113|      4|- (void)uploadTarget:(GDTCORTarget)target withConditions:(GDTCORUploadConditions)conditions {
  114|      4|  __block GDTCORBackgroundIdentifier backgroundTaskID = GDTCORBackgroundIdentifierInvalid;
  115|       |
  116|      4|  dispatch_block_t backgroundTaskCompletion = ^{
  117|       |    // End the background task if there was one.
  118|      4|    if (backgroundTaskID != GDTCORBackgroundIdentifierInvalid) {
  119|      4|      [[GDTCORApplication sharedApplication] endBackgroundTask:backgroundTaskID];
  120|      4|      backgroundTaskID = GDTCORBackgroundIdentifierInvalid;
  121|      4|    }
  122|      4|  };
  123|       |
  124|      4|  backgroundTaskID = [[GDTCORApplication sharedApplication]
  125|      4|      beginBackgroundTaskWithName:@"GDTCCTUploader-upload"
  126|      0|                expirationHandler:^{
  127|      0|                  if (backgroundTaskID != GDTCORBackgroundIdentifierInvalid) {
  128|       |                    // Cancel the upload and complete delivery.
  129|      0|                    [self.currentTask cancel];
  130|       |
  131|       |                    // End the background task.
  132|      0|                    backgroundTaskCompletion();
  133|      0|                  }
  134|      0|                }];
  135|       |
  136|      4|  id<GDTCORStoragePromiseProtocol> storage = self.storage;
  137|       |
  138|       |  // 1. Check if the conditions for the target are suitable.
  139|      4|  [self isReadyToUploadTarget:target conditions:conditions]
  140|      4|      .thenOn(self.uploaderQueue,
  141|      4|              ^id(id result) {
  142|       |                // 2. Remove previously attempted batches
  143|      4|                return [storage removeAllBatchesForTarget:target deleteEvents:NO];
  144|      4|              })
  145|      4|      .thenOn(self.uploaderQueue,
  146|      4|              ^FBLPromise<NSNumber *> *(id result) {
  147|       |                // There may be a big amount of events stored, so creating a batch may be an
  148|       |                // expensive operation.
  149|       |
  150|       |                // 3. Do a lightweight check if there are any events for the target first to
  151|       |                // finish early if there are no.
  152|      4|                return [storage hasEventsForTarget:target];
  153|      4|              })
  154|      4|      .validateOn(self.uploaderQueue,
  155|      4|                  ^BOOL(NSNumber *hasEvents) {
  156|       |                    // Stop operation if there are no events to upload.
  157|      4|                    return hasEvents.boolValue;
  158|      4|                  })
  159|      4|      .thenOn(self.uploaderQueue,
  160|      0|              ^FBLPromise<GDTCORUploadBatch *> *(id result) {
  161|      0|                if (self.isCancelled) {
  162|      0|                  return nil;
  163|      0|                }
  164|       |
  165|       |                // 4. Fetch events to upload.
  166|      0|                GDTCORStorageEventSelector *eventSelector = [self eventSelectorTarget:target
  167|      0|                                                                       withConditions:conditions];
  168|      0|                return [storage batchWithEventSelector:eventSelector
  169|      0|                                       batchExpiration:[NSDate dateWithTimeIntervalSinceNow:600]];
  170|      0|              })
  171|      4|      .validateOn(self.uploaderQueue,
  172|      0|                  ^BOOL(GDTCORUploadBatch *batch) {
  173|       |                    // 5. Validate batch.
  174|      0|                    return batch.batchID != nil && batch.events.count > 0;
  175|      0|                  })
  176|      4|      .thenOn(self.uploaderQueue,
  177|      0|              ^FBLPromise *(GDTCORUploadBatch *batch) {
  178|       |                // A non-empty batch has been created, consider it as an upload attempt.
  179|      0|                self.uploadAttempted = YES;
  180|       |
  181|       |                // 6. Perform upload URL request.
  182|      0|                return [self sendURLRequestWithBatch:batch target:target storage:storage];
  183|      0|              })
  184|      4|      .thenOn(self.uploaderQueue,
  185|      0|              ^id(id result) {
  186|       |                // 7. Finish operation.
  187|      0|                [self finishOperation];
  188|      0|                backgroundTaskCompletion();
  189|      0|                return nil;
  190|      0|              })
  191|      4|      .catchOn(self.uploaderQueue, ^(NSError *error) {
  192|       |        // TODO: Maybe report the error to the client.
  193|      4|        [self finishOperation];
  194|      4|        backgroundTaskCompletion();
  195|      4|      });
  196|      4|}
  197|       |
  198|       |#pragma mark - Upload implementation details
  199|       |
  200|       |/** Sends URL request to upload the provided batch and handle the response. */
  201|       |- (FBLPromise<NSNull *> *)sendURLRequestWithBatch:(GDTCORUploadBatch *)batch
  202|       |                                           target:(GDTCORTarget)target
  203|      0|                                          storage:(id<GDTCORStoragePromiseProtocol>)storage {
  204|      0|  NSNumber *batchID = batch.batchID;
  205|       |
  206|       |  // 1. Send URL request.
  207|      0|  return [self sendURLRequestWithBatch:batch target:target]
  208|      0|      .thenOn(
  209|      0|          self.uploaderQueue,
  210|      0|          ^FBLPromise<NSNull *> *(GULURLSessionDataResponse *response) {
  211|       |            // 2. Parse response and update the next upload time if can.
  212|      0|            [self updateNextUploadTimeWithResponse:response forTarget:target];
  213|       |
  214|       |            // 3. Cleanup batch.
  215|       |
  216|       |            // Only retry if one of these codes is returned:
  217|       |            // 429 - Too many requests;
  218|       |            // 5xx - Server errors.
  219|      0|            NSInteger statusCode = response.HTTPResponse.statusCode;
  220|      0|            if (statusCode == 429 || (statusCode >= 500 && statusCode < 600)) {
  221|       |              // Move the events back to the main storage to be uploaded on the next attempt.
  222|      0|              return [storage removeBatchWithID:batchID deleteEvents:NO];
  223|      0|            } else {
  224|      0|              if (statusCode >= 200 && statusCode <= 300) {
  225|      0|                GDTCORLogDebug(@"CCT: batch %@ delivered", batchID);
  226|      0|              } else {
  227|      0|                GDTCORLogDebug(
  228|      0|                    @"CCT: batch %@ was rejected by the server and will be deleted with all events",
  229|      0|                    batchID);
  230|      0|              }
  231|       |
  232|       |              // The events are either delivered or unrecoverable broken, so remove the batch with
  233|       |              // events.
  234|      0|              return [storage removeBatchWithID:batch.batchID deleteEvents:YES];
  235|      0|            }
  236|      0|          })
  237|      0|      .recoverOn(self.uploaderQueue, ^id(NSError *error) {
  238|       |        // In the case of a network error move the events back to the main storage to be uploaded on
  239|       |        // the next attempt.
  240|      0|        return [storage removeBatchWithID:batchID deleteEvents:NO];
  241|      0|      });
  242|      0|}
  243|       |
  244|       |/** Composes and sends URL request. */
  245|       |- (FBLPromise<GULURLSessionDataResponse *> *)sendURLRequestWithBatch:(GDTCORUploadBatch *)batch
  246|      0|                                                              target:(GDTCORTarget)target {
  247|      0|  return [FBLPromise
  248|      0|             onQueue:self.uploaderQueue
  249|      0|                  do:^NSURLRequest * {
  250|       |                    // 1. Prepare URL request.
  251|      0|                    NSData *requestProtoData = [self constructRequestProtoWithEvents:batch.events];
  252|      0|                    NSData *gzippedData = [GDTCCTCompressionHelper gzippedData:requestProtoData];
  253|      0|                    BOOL usingGzipData =
  254|      0|                        gzippedData != nil && gzippedData.length < requestProtoData.length;
  255|      0|                    NSData *dataToSend = usingGzipData ? gzippedData : requestProtoData;
  256|      0|                    NSURLRequest *request = [self constructRequestWithURL:self.uploadURL
  257|      0|                                                                forTarget:target
  258|      0|                                                                     data:dataToSend];
  259|      0|                    GDTCORLogDebug(@"CTT: request containing %lu events for batch: %@ for target: "
  260|      0|                                   @"%ld created: %@",
  261|      0|                                   (unsigned long)batch.events.count, batch.batchID, (long)target,
  262|      0|                                   request);
  263|      0|                    return request;
  264|      0|                  }]
  265|      0|      .thenOn(self.uploaderQueue,
  266|      0|              ^FBLPromise<GULURLSessionDataResponse *> *(NSURLRequest *request) {
  267|       |                // 2. Send URL request.
  268|      0|                return
  269|      0|                    [[self uploaderSessionCreateIfNeeded] gul_dataTaskPromiseWithRequest:request];
  270|      0|              })
  271|      0|      .thenOn(self.uploaderQueue,
  272|      0|              ^GULURLSessionDataResponse *(GULURLSessionDataResponse *response) {
  273|       |                // Invalidate session to release the delegate (which is `self`) to break the retain
  274|       |                // cycle.
  275|      0|                [self.uploaderSession finishTasksAndInvalidate];
  276|      0|                return response;
  277|      0|              })
  278|      0|      .recoverOn(self.uploaderQueue, ^id(NSError *error) {
  279|       |        // Invalidate session to release the delegate (which is `self`) to break the retain cycle.
  280|      0|        [self.uploaderSession finishTasksAndInvalidate];
  281|       |        // Re-throw the error.
  282|      0|        return error;
  283|      0|      });
  284|      0|}
  285|       |
  286|       |/** Parses server response and update next upload time for the specified target based on it. */
  287|       |- (void)updateNextUploadTimeWithResponse:(GULURLSessionDataResponse *)response
  288|      0|                               forTarget:(GDTCORTarget)target {
  289|      0|  GDTCORClock *futureUploadTime;
  290|      0|  if (response.HTTPBody) {
  291|      0|    NSError *decodingError;
  292|      0|    gdt_cct_LogResponse logResponse = GDTCCTDecodeLogResponse(response.HTTPBody, &decodingError);
  293|      0|    if (!decodingError && logResponse.has_next_request_wait_millis) {
  294|      0|      GDTCORLogDebug(@"CCT: The backend responded asking to not upload for %lld millis from now.",
  295|      0|                     logResponse.next_request_wait_millis);
  296|      0|      futureUploadTime =
  297|      0|          [GDTCORClock clockSnapshotInTheFuture:logResponse.next_request_wait_millis];
  298|      0|    } else if (decodingError) {
  299|      0|      GDTCORLogDebug(@"There was a response decoding error: %@", decodingError);
  300|      0|    }
  301|      0|    pb_release(gdt_cct_LogResponse_fields, &logResponse);
  302|      0|  }
  303|       |
  304|       |  // If no futureUploadTime was parsed from the response body, then check
  305|       |  // [Retry-After](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) header.
  306|      0|  if (!futureUploadTime) {
  307|      0|    NSString *retryAfterHeader = response.HTTPResponse.allHeaderFields[@"Retry-After"];
  308|      0|    if (retryAfterHeader.length > 0) {
  309|      0|      NSNumberFormatter *formatter = [[NSNumberFormatter alloc] init];
  310|      0|      formatter.numberStyle = NSNumberFormatterDecimalStyle;
  311|      0|      NSNumber *retryAfterSeconds = [formatter numberFromString:retryAfterHeader];
  312|      0|      if (retryAfterSeconds != nil) {
  313|      0|        uint64_t retryAfterMillis = retryAfterSeconds.unsignedIntegerValue * 1000u;
  314|      0|        futureUploadTime = [GDTCORClock clockSnapshotInTheFuture:retryAfterMillis];
  315|      0|      }
  316|      0|    }
  317|      0|  }
  318|       |
  319|      0|  if (!futureUploadTime) {
  320|      0|    GDTCORLogDebug(@"%@", @"CCT: The backend response failed to parse, so the next request "
  321|      0|                          @"won't occur until 15 minutes from now");
  322|       |    // 15 minutes from now.
  323|      0|    futureUploadTime = [GDTCORClock clockSnapshotInTheFuture:15 * 60 * 1000];
  324|      0|  }
  325|       |
  326|      0|  [self.metadataProvider setNextUploadTime:futureUploadTime forTarget:target];
  327|      0|}
  328|       |
  329|       |#pragma mark - Private helper methods
  330|       |
  331|       |/** @return A resolved promise if is ready and a rejected promise if not. */
  332|       |- (FBLPromise<NSNull *> *)isReadyToUploadTarget:(GDTCORTarget)target
  333|      4|                                     conditions:(GDTCORUploadConditions)conditions {
  334|      4|  FBLPromise<NSNull *> *promise = [FBLPromise pendingPromise];
  335|      4|  if ([self readyToUploadTarget:target conditions:conditions]) {
  336|      4|    [promise fulfill:[NSNull null]];
  337|      0|  } else {
  338|      0|    NSString *reason =
  339|      0|        [NSString stringWithFormat:@"Target %ld is not ready to upload with condition: %ld",
  340|      0|                                   (long)target, (long)conditions];
  341|      0|    [promise reject:[self genericRejectedPromiseErrorWithReason:reason]];
  342|      0|  }
  343|      4|  return promise;
  344|      4|}
  345|       |
  346|       |// TODO: Move to a separate class/extension/file when needed in other files.
  347|       |/** Returns an error object with the specified failure reason. */
  348|      0|- (NSError *)genericRejectedPromiseErrorWithReason:(NSString *)reason {
  349|      0|  return [NSError errorWithDomain:@"GDTCCTUploader"
  350|      0|                             code:-1
  351|      0|                         userInfo:@{NSLocalizedFailureReasonErrorKey : reason}];
  352|      0|}
  353|       |
  354|       |/** Returns if the specified target is ready to be uploaded based on the specified conditions. */
  355|      4|- (BOOL)readyToUploadTarget:(GDTCORTarget)target conditions:(GDTCORUploadConditions)conditions {
  356|       |  // Not ready to upload with no network connection.
  357|       |  // TODO: Reconsider using reachability to prevent an upload attempt.
  358|       |  // See https://developer.apple.com/videos/play/wwdc2019/712/ (49:40) for more details.
  359|      4|  if (conditions & GDTCORUploadConditionNoNetwork) {
  360|      0|    GDTCORLogDebug(@"%@", @"CCT: Not ready to upload without a network connection.");
  361|      0|    return NO;
  362|      0|  }
  363|       |
  364|       |  // Upload events with no additional conditions if high priority.
  365|      4|  if ((conditions & GDTCORUploadConditionHighPriority) == GDTCORUploadConditionHighPriority) {
  366|      0|    GDTCORLogDebug(@"%@", @"CCT: a high priority event is allowing an upload");
  367|      0|    return YES;
  368|      0|  }
  369|       |
  370|       |  // Check next upload time for the target.
  371|      4|  BOOL isAfterNextUploadTime = YES;
  372|      4|  GDTCORClock *nextUploadTime = [self.metadataProvider nextUploadTimeForTarget:target];
  373|      4|  if (nextUploadTime) {
  374|      0|    isAfterNextUploadTime = [[GDTCORClock snapshot] isAfter:nextUploadTime];
  375|      0|  }
  376|       |
  377|      4|  if (isAfterNextUploadTime) {
  378|      4|    GDTCORLogDebug(@"CCT: can upload to target %ld because the request wait time has transpired",
  379|      4|                   (long)target);
  380|      0|  } else {
  381|      0|    GDTCORLogDebug(@"CCT: can't upload to target %ld because the backend asked to wait",
  382|      0|                   (long)target);
  383|      0|  }
  384|       |
  385|      4|  return isAfterNextUploadTime;
  386|      4|}
  387|       |
  388|       |/** Constructs data given an upload package.
  389|       | *
  390|       | * @param events The events used to construct the request proto bytes.
  391|       | * @return Proto bytes representing a gdt_cct_LogRequest object.
  392|       | */
  393|      0|- (nonnull NSData *)constructRequestProtoWithEvents:(NSSet<GDTCOREvent *> *)events {
  394|       |  // Segment the log events by log type.
  395|      0|  NSMutableDictionary<NSString *, NSMutableSet<GDTCOREvent *> *> *logMappingIDToLogSet =
  396|      0|      [[NSMutableDictionary alloc] init];
  397|      0|  [events enumerateObjectsUsingBlock:^(GDTCOREvent *_Nonnull event, BOOL *_Nonnull stop) {
  398|      0|    NSMutableSet *logSet = logMappingIDToLogSet[event.mappingID];
  399|      0|    logSet = logSet ? logSet : [[NSMutableSet alloc] init];
  400|      0|    [logSet addObject:event];
  401|      0|    logMappingIDToLogSet[event.mappingID] = logSet;
  402|      0|  }];
  403|       |
  404|      0|  gdt_cct_BatchedLogRequest batchedLogRequest =
  405|      0|      GDTCCTConstructBatchedLogRequest(logMappingIDToLogSet);
  406|       |
  407|      0|  NSData *data = GDTCCTEncodeBatchedLogRequest(&batchedLogRequest);
  408|      0|  pb_release(gdt_cct_BatchedLogRequest_fields, &batchedLogRequest);
  409|      0|  return data ? data : [[NSData alloc] init];
  410|      0|}
  411|       |
  412|       |/** Constructs a request to the given URL and target with the specified request body data.
  413|       | *
  414|       | * @param target The target backend to send the request to.
  415|       | * @param data The request body data.
  416|       | * @return A new NSURLRequest ready to be sent to FLL.
  417|       | */
  418|       |- (nullable NSURLRequest *)constructRequestWithURL:(NSURL *)URL
  419|       |                                         forTarget:(GDTCORTarget)target
  420|      0|                                              data:(NSData *)data {
  421|      0|  if (data == nil || data.length == 0) {
  422|      0|    GDTCORLogDebug(@"There was no data to construct a request for target %ld.", (long)target);
  423|      0|    return nil;
  424|      0|  }
  425|       |
  426|      0|  NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL];
  427|      0|  NSString *targetString;
  428|      0|  switch (target) {
  429|      0|    case kGDTCORTargetCCT:
  430|      0|      targetString = @"cct";
  431|      0|      break;
  432|       |
  433|      0|    case kGDTCORTargetFLL:
  434|      0|      targetString = @"fll";
  435|      0|      break;
  436|       |
  437|      0|    case kGDTCORTargetCSH:
  438|      0|      targetString = @"csh";
  439|      0|      break;
  440|      0|    case kGDTCORTargetINT:
  441|      0|      targetString = @"int";
  442|      0|      break;
  443|       |
  444|      0|    default:
  445|      0|      targetString = @"unknown";
  446|      0|      break;
  447|      0|  }
  448|      0|  NSString *userAgent =
  449|      0|      [NSString stringWithFormat:@"datatransport/%@ %@support/%@ apple/", kGDTCORVersion,
  450|      0|                                 targetString, kGDTCCTSupportSDKVersion];
  451|       |
  452|      0|  [request setValue:[self.metadataProvider APIKeyForTarget:target]
  453|      0|      forHTTPHeaderField:@"X-Goog-Api-Key"];
  454|       |
  455|      0|  if ([GDTCCTCompressionHelper isGzipped:data]) {
  456|      0|    [request setValue:@"gzip" forHTTPHeaderField:@"Content-Encoding"];
  457|      0|  }
  458|      0|  [request setValue:@"application/x-protobuf" forHTTPHeaderField:@"Content-Type"];
  459|      0|  [request setValue:@"gzip" forHTTPHeaderField:@"Accept-Encoding"];
  460|      0|  [request setValue:userAgent forHTTPHeaderField:@"User-Agent"];
  461|      0|  request.HTTPMethod = @"POST";
  462|      0|  [request setHTTPBody:data];
  463|      0|  return request;
  464|      0|}
  465|       |
  466|       |/** Creates and returns a storage event selector for the specified target and conditions. */
  467|       |- (GDTCORStorageEventSelector *)eventSelectorTarget:(GDTCORTarget)target
  468|      0|                                     withConditions:(GDTCORUploadConditions)conditions {
  469|      0|  if ((conditions & GDTCORUploadConditionHighPriority) == GDTCORUploadConditionHighPriority) {
  470|      0|    return [GDTCORStorageEventSelector eventSelectorForTarget:target];
  471|      0|  }
  472|      0|  NSMutableSet<NSNumber *> *qosTiers = [[NSMutableSet alloc] init];
  473|      0|  if (conditions & GDTCORUploadConditionWifiData) {
  474|      0|    [qosTiers addObjectsFromArray:@[
  475|      0|      @(GDTCOREventQoSFast), @(GDTCOREventQoSWifiOnly), @(GDTCOREventQosDefault),
  476|      0|      @(GDTCOREventQoSTelemetry), @(GDTCOREventQoSUnknown)
  477|      0|    ]];
  478|      0|  }
  479|      0|  if (conditions & GDTCORUploadConditionMobileData) {
  480|      0|    [qosTiers addObjectsFromArray:@[ @(GDTCOREventQoSFast), @(GDTCOREventQosDefault) ]];
  481|      0|  }
  482|       |
  483|      0|  return [[GDTCORStorageEventSelector alloc] initWithTarget:target
  484|      0|                                                   eventIDs:nil
  485|      0|                                                 mappingIDs:nil
  486|      0|                                                   qosTiers:qosTiers];
  487|      0|}
  488|       |
  489|       |#pragma mark - NSURLSessionDelegate
  490|       |
  491|       |- (void)URLSession:(NSURLSession *)session
  492|       |                          task:(NSURLSessionTask *)task
  493|       |    willPerformHTTPRedirection:(NSHTTPURLResponse *)response
  494|       |                    newRequest:(NSURLRequest *)request
  495|      0|             completionHandler:(void (^)(NSURLRequest *_Nullable))completionHandler {
  496|      0|  if (!completionHandler) {
  497|      0|    return;
  498|      0|  }
  499|      0|  if (response.statusCode == 302 || response.statusCode == 301) {
  500|      0|    NSURLRequest *newRequest = [self constructRequestWithURL:request.URL
  501|      0|                                                   forTarget:kGDTCORTargetCCT
  502|      0|                                                        data:task.originalRequest.HTTPBody];
  503|      0|    completionHandler(newRequest);
  504|      0|  } else {
  505|      0|    completionHandler(request);
  506|      0|  }
  507|      0|}
  508|       |
  509|       |#pragma mark - NSOperation methods
  510|       |
  511|       |@synthesize executing = _executing;
  512|       |@synthesize finished = _finished;
  513|       |
  514|     20|- (BOOL)isFinished {
  515|     20|  @synchronized(self) {
  516|     20|    return _finished;
  517|     20|  }
  518|     20|}
  519|       |
  520|     16|- (BOOL)isExecuting {
  521|     16|  @synchronized(self) {
  522|     16|    return _executing;
  523|     16|  }
  524|     16|}
  525|       |
  526|      0|- (BOOL)isAsynchronous {
  527|      0|  return YES;
  528|      0|}
  529|       |
  530|      4|- (void)startOperation {
  531|      4|  @synchronized(self) {
  532|      4|    [self willChangeValueForKey:@"isExecuting"];
  533|      4|    [self willChangeValueForKey:@"isFinished"];
  534|      4|    self->_executing = YES;
  535|      4|    self->_finished = NO;
  536|      4|    [self didChangeValueForKey:@"isExecuting"];
  537|      4|    [self didChangeValueForKey:@"isFinished"];
  538|      4|  }
  539|      4|}
  540|       |
  541|      4|- (void)finishOperation {
  542|      4|  @synchronized(self) {
  543|      4|    [self willChangeValueForKey:@"isExecuting"];
  544|      4|    [self willChangeValueForKey:@"isFinished"];
  545|      4|    self->_executing = NO;
  546|      4|    self->_finished = YES;
  547|      4|    [self didChangeValueForKey:@"isExecuting"];
  548|      4|    [self didChangeValueForKey:@"isFinished"];
  549|      4|  }
  550|      4|}
  551|       |
  552|      4|- (void)start {
  553|      4|  [self startOperation];
  554|       |
  555|      4|  GDTCORLogDebug(@"Upload operation started: %@", self);
  556|      4|  [self uploadTarget:self.target withConditions:self.conditions];
  557|      4|}
  558|       |
  559|      0|- (void)cancel {
  560|      0|  @synchronized(self) {
  561|      0|    [super cancel];
  562|       |
  563|       |    // If the operation hasn't been started we can set `isFinished = YES` straight away.
  564|      0|    if (!_executing) {
  565|      0|      _executing = NO;
  566|      0|      _finished = YES;
  567|      0|    }
  568|      0|  }
  569|      0|}
  570|       |
  571|       |@end
  572|       |
  573|       |NS_ASSUME_NONNULL_END

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCCTLibrary/GDTCCTUploader.m:
    1|       |/*
    2|       | * Copyright 2020 Google LLC
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCCTLibrary/Private/GDTCCTUploader.h"
   18|       |
   19|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORPlatform.h"
   20|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORRegistrar.h"
   21|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORConsoleLogger.h"
   22|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCOREndpoints.h"
   23|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCOREvent.h"
   24|       |
   25|       |#import "GoogleDataTransport/GDTCCTLibrary/Private/GDTCCTUploadOperation.h"
   26|       |
   27|       |NS_ASSUME_NONNULL_BEGIN
   28|       |
   29|       |@interface GDTCCTUploader () <NSURLSessionDelegate, GDTCCTUploadMetadataProvider>
   30|       |
   31|       |@property(nonatomic, readonly) NSOperationQueue *uploadOperationQueue;
   32|       |@property(nonatomic, readonly) dispatch_queue_t uploadQueue;
   33|       |
   34|       |@property(nonatomic, readonly)
   35|       |    NSMutableDictionary<NSNumber * /*GDTCORTarget*/, GDTCORClock *> *nextUploadTimeByTarget;
   36|       |
   37|       |@end
   38|       |
   39|       |@implementation GDTCCTUploader
   40|       |
   41|       |static NSURL *_testServerURL = nil;
   42|       |
   43|      1|+ (void)load {
   44|      1|  GDTCCTUploader *uploader = [GDTCCTUploader sharedInstance];
   45|      1|  [[GDTCORRegistrar sharedInstance] registerUploader:uploader target:kGDTCORTargetCCT];
   46|      1|  [[GDTCORRegistrar sharedInstance] registerUploader:uploader target:kGDTCORTargetFLL];
   47|      1|  [[GDTCORRegistrar sharedInstance] registerUploader:uploader target:kGDTCORTargetCSH];
   48|      1|  [[GDTCORRegistrar sharedInstance] registerUploader:uploader target:kGDTCORTargetINT];
   49|      1|}
   50|       |
   51|      1|+ (instancetype)sharedInstance {
   52|      1|  static GDTCCTUploader *sharedInstance;
   53|      1|  static dispatch_once_t onceToken;
   54|      1|  dispatch_once(&onceToken, ^{
   55|      1|    sharedInstance = [[GDTCCTUploader alloc] init];
   56|      1|  });
   57|      1|  return sharedInstance;
   58|      1|}
   59|       |
   60|      1|- (instancetype)init {
   61|      1|  self = [super init];
   62|      1|  if (self) {
   63|      1|    _uploadQueue = dispatch_queue_create("com.google.GDTCCTUploader", DISPATCH_QUEUE_SERIAL);
   64|      1|    _uploadOperationQueue = [[NSOperationQueue alloc] init];
   65|      1|    _uploadOperationQueue.maxConcurrentOperationCount = 1;
   66|      1|    _nextUploadTimeByTarget = [[NSMutableDictionary alloc] init];
   67|      1|  }
   68|      1|  return self;
   69|      1|}
   70|       |
   71|      4|- (void)uploadTarget:(GDTCORTarget)target withConditions:(GDTCORUploadConditions)conditions {
   72|       |  // Current GDTCCTUploader expected behaviour:
   73|       |  // 1. Accept multiple upload request
   74|       |  // 2. Verify if there are events eligible for upload and start upload for the first suitable
   75|       |  // target
   76|       |  // 3. Ignore other requests while an upload is in-progress.
   77|       |
   78|       |  // TODO: Revisit expected behaviour.
   79|       |  // Potentially better option:
   80|       |  // 1. Accept and enqueue all upload requests
   81|       |  // 2. Notify the client of upload stages
   82|       |  // 3. Allow the client cancelling upload requests as needed.
   83|       |
   84|      4|  id<GDTCORStoragePromiseProtocol> storage = GDTCORStoragePromiseInstanceForTarget(target);
   85|      4|  if (storage == nil) {
   86|      0|    GDTCORLogError(GDTCORMCEGeneralError,
   87|      0|                   @"Failed to upload target: %ld - could not find corresponding storage instance.",
   88|      0|                   (long)target);
   89|      0|    return;
   90|      0|  }
   91|       |
   92|      4|  GDTCCTUploadOperation *uploadOperation =
   93|      4|      [[GDTCCTUploadOperation alloc] initWithTarget:target
   94|      4|                                         conditions:conditions
   95|      4|                                          uploadURL:[[self class] serverURLForTarget:target]
   96|      4|                                              queue:self.uploadQueue
   97|      4|                                            storage:storage
   98|      4|                                   metadataProvider:self];
   99|       |
  100|      4|  GDTCORLogDebug(@"Upload operation created: %@, target: %@", uploadOperation, @(target));
  101|       |
  102|      4|  __weak __auto_type weakSelf = self;
  103|      4|  __weak GDTCCTUploadOperation *weakOperation = uploadOperation;
  104|      4|  uploadOperation.completionBlock = ^{
  105|      4|    __auto_type strongSelf = weakSelf;
  106|      4|    GDTCCTUploadOperation *strongOperation = weakOperation;
  107|      4|    if (strongSelf == nil || strongOperation == nil) {
  108|      0|      GDTCORLogDebug(@"Internal inconsistency: GDTCCTUploader was deallocated during upload.", nil);
  109|      0|      return;
  110|      0|    }
  111|       |
  112|      4|    GDTCORLogDebug(@"Upload operation finished: %@, uploadAttempted: %@", strongOperation,
  113|      4|                   @(strongOperation.uploadAttempted));
  114|       |
  115|      4|    if (strongOperation.uploadAttempted) {
  116|       |      // Ignore all upload requests received when the upload was in progress.
  117|      0|      [strongSelf.uploadOperationQueue cancelAllOperations];
  118|      0|    }
  119|      4|  };
  120|       |
  121|      4|  [self.uploadOperationQueue addOperation:uploadOperation];
  122|      4|  GDTCORLogDebug(@"Upload operation scheduled: %@, operation count: %@", uploadOperation,
  123|      4|                 @(self.uploadOperationQueue.operationCount));
  124|      4|}
  125|       |
  126|       |#pragma mark - URLs
  127|       |
  128|      0|+ (void)setTestServerURL:(NSURL *_Nullable)serverURL {
  129|      0|  _testServerURL = serverURL;
  130|      0|}
  131|       |
  132|      0|+ (NSURL *_Nullable)testServerURL {
  133|      0|  return _testServerURL;
  134|      0|}
  135|       |
  136|      4|+ (nullable NSURL *)serverURLForTarget:(GDTCORTarget)target {
  137|      4|#if !NDEBUG
  138|      4|  if (_testServerURL) {
  139|      0|    return _testServerURL;
  140|      0|  }
  141|      4|#endif  // !NDEBUG
  142|       |
  143|      4|  return [GDTCOREndpoints uploadURLForTarget:target];
  144|      4|}
  145|       |
  146|      0|- (NSString *)FLLAndCSHAndINTAPIKey {
  147|      0|  static NSString *defaultServerKey;
  148|      0|  static dispatch_once_t onceToken;
  149|      0|  dispatch_once(&onceToken, ^{
  150|       |    // These strings should be interleaved to construct the real key.
  151|      0|    const char *p1 = "AzSBG0honD6A-PxV5nBc";
  152|      0|    const char *p2 = "Iay44Iwtu2vV0AOrz1C";
  153|      0|    const char defaultKey[40] = {p1[0],  p2[0],  p1[1],  p2[1],  p1[2],  p2[2],  p1[3],  p2[3],
  154|      0|                                 p1[4],  p2[4],  p1[5],  p2[5],  p1[6],  p2[6],  p1[7],  p2[7],
  155|      0|                                 p1[8],  p2[8],  p1[9],  p2[9],  p1[10], p2[10], p1[11], p2[11],
  156|      0|                                 p1[12], p2[12], p1[13], p2[13], p1[14], p2[14], p1[15], p2[15],
  157|      0|                                 p1[16], p2[16], p1[17], p2[17], p1[18], p2[18], p1[19], '\0'};
  158|      0|    defaultServerKey = [NSString stringWithUTF8String:defaultKey];
  159|      0|  });
  160|      0|  return defaultServerKey;
  161|      0|}
  162|       |
  163|       |#pragma mark - GDTCCTUploadMetadataProvider
  164|       |
  165|      4|- (nullable GDTCORClock *)nextUploadTimeForTarget:(GDTCORTarget)target {
  166|      4|  @synchronized(self.nextUploadTimeByTarget) {
  167|      4|    return self.nextUploadTimeByTarget[@(target)];
  168|      4|  }
  169|      4|}
  170|       |
  171|      0|- (void)setNextUploadTime:(nullable GDTCORClock *)time forTarget:(GDTCORTarget)target {
  172|      0|  @synchronized(self.nextUploadTimeByTarget) {
  173|      0|    self.nextUploadTimeByTarget[@(target)] = time;
  174|      0|  }
  175|      0|}
  176|       |
  177|      0|- (nullable NSString *)APIKeyForTarget:(GDTCORTarget)target {
  178|      0|  if (target == kGDTCORTargetFLL || target == kGDTCORTargetCSH) {
  179|      0|    return [self FLLAndCSHAndINTAPIKey];
  180|      0|  }
  181|       |
  182|      0|  if (target == kGDTCORTargetINT) {
  183|      0|    return [self FLLAndCSHAndINTAPIKey];
  184|      0|  }
  185|       |
  186|      0|  return nil;
  187|      0|}
  188|       |
  189|       |#if !NDEBUG
  190|       |
  191|      0|- (BOOL)waitForUploadFinishedWithTimeout:(NSTimeInterval)timeout {
  192|      0|  NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:timeout];
  193|      0|  while ([expirationDate compare:[NSDate date]] == NSOrderedDescending) {
  194|      0|    if (self.uploadOperationQueue.operationCount == 0) {
  195|      0|      return YES;
  196|      0|    } else {
  197|      0|      [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.1]];
  198|      0|    }
  199|      0|  }
  200|       |
  201|      0|  GDTCORLogDebug(@"Uploader wait for finish timeout exceeded. Operations still in queue: %@",
  202|      0|                 self.uploadOperationQueue.operations);
  203|      0|  return NO;
  204|      0|}
  205|       |
  206|       |#endif  // !NDEBUG
  207|       |
  208|       |@end
  209|       |
  210|       |NS_ASSUME_NONNULL_END

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCCTLibrary/GDTCOREvent+GDTCCTSupport.m:
    1|       |/*
    2|       | * Copyright 2020 Google LLC
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCCTLibrary/Public/GDTCOREvent+GDTCCTSupport.h"
   18|       |
   19|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORConsoleLogger.h"
   20|       |
   21|       |NSString *const GDTCCTNeedsNetworkConnectionInfo = @"needs_network_connection_info";
   22|       |
   23|       |NSString *const GDTCCTNetworkConnectionInfo = @"network_connection_info";
   24|       |
   25|       |NSString *const GDTCCTEventCodeInfo = @"event_code_info";
   26|       |
   27|       |@implementation GDTCOREvent (GDTCCTSupport)
   28|       |
   29|      0|- (void)setNeedsNetworkConnectionInfoPopulated:(BOOL)needsNetworkConnectionInfoPopulated {
   30|      0|  if (!needsNetworkConnectionInfoPopulated) {
   31|      0|    if (!self.customBytes) {
   32|      0|      return;
   33|      0|    }
   34|       |
   35|       |    // Make sure we don't destroy the eventCode data, if any is present.
   36|      0|    @try {
   37|      0|      NSError *error;
   38|      0|      NSMutableDictionary *bytesDict =
   39|      0|          [[NSJSONSerialization JSONObjectWithData:self.customBytes options:0
   40|      0|                                             error:&error] mutableCopy];
   41|      0|      if (error) {
   42|      0|        GDTCORLogDebug(@"Error when setting an event's event_code: %@", error);
   43|      0|        return;
   44|      0|      }
   45|      0|      NSNumber *eventCode = bytesDict[GDTCCTEventCodeInfo];
   46|      0|      if (eventCode != nil) {
   47|      0|        self.customBytes =
   48|      0|            [NSJSONSerialization dataWithJSONObject:@{GDTCCTEventCodeInfo : eventCode}
   49|      0|                                            options:0
   50|      0|                                              error:&error];
   51|      0|      }
   52|      0|    } @catch (NSException *exception) {
   53|      0|      GDTCORLogDebug(@"Error when setting the event for needs_network_connection_info: %@",
   54|      0|                     exception);
   55|      0|    }
   56|      0|  } else {
   57|      0|    @try {
   58|      0|      NSError *error;
   59|      0|      NSMutableDictionary *bytesDict;
   60|      0|      if (self.customBytes) {
   61|      0|        bytesDict = [[NSJSONSerialization JSONObjectWithData:self.customBytes
   62|      0|                                                     options:0
   63|      0|                                                       error:&error] mutableCopy];
   64|      0|        if (error) {
   65|      0|          GDTCORLogDebug(@"Error when setting an even'ts event_code: %@", error);
   66|      0|          return;
   67|      0|        }
   68|      0|      } else {
   69|      0|        bytesDict = [[NSMutableDictionary alloc] init];
   70|      0|      }
   71|      0|      [bytesDict setObject:@YES forKey:GDTCCTNeedsNetworkConnectionInfo];
   72|      0|      self.customBytes = [NSJSONSerialization dataWithJSONObject:bytesDict options:0 error:&error];
   73|      0|    } @catch (NSException *exception) {
   74|      0|      GDTCORLogDebug(@"Error when setting the event for needs_network_connection_info: %@",
   75|      0|                     exception);
   76|      0|    }
   77|      0|  }
   78|      0|}
   79|       |
   80|      0|- (BOOL)needsNetworkConnectionInfoPopulated {
   81|      0|  if (self.customBytes) {
   82|      0|    @try {
   83|      0|      NSError *error;
   84|      0|      NSDictionary *bytesDict = [NSJSONSerialization JSONObjectWithData:self.customBytes
   85|      0|                                                                options:0
   86|      0|                                                                  error:&error];
   87|      0|      return bytesDict && !error && [bytesDict[GDTCCTNeedsNetworkConnectionInfo] boolValue];
   88|      0|    } @catch (NSException *exception) {
   89|      0|      GDTCORLogDebug(@"Error when checking the event for needs_network_connection_info: %@",
   90|      0|                     exception);
   91|      0|    }
   92|      0|  }
   93|      0|  return NO;
   94|      0|}
   95|       |
   96|      0|- (void)setNetworkConnectionInfoData:(NSData *)networkConnectionInfoData {
   97|      0|  @try {
   98|      0|    NSError *error;
   99|      0|    NSString *dataString = [networkConnectionInfoData base64EncodedStringWithOptions:0];
  100|      0|    if (dataString != nil) {
  101|      0|      NSMutableDictionary *bytesDict;
  102|      0|      if (self.customBytes) {
  103|      0|        bytesDict = [[NSJSONSerialization JSONObjectWithData:self.customBytes
  104|      0|                                                     options:0
  105|      0|                                                       error:&error] mutableCopy];
  106|      0|        if (error) {
  107|      0|          GDTCORLogDebug(@"Error when setting an even'ts event_code: %@", error);
  108|      0|          return;
  109|      0|        }
  110|      0|      } else {
  111|      0|        bytesDict = [[NSMutableDictionary alloc] init];
  112|      0|      }
  113|      0|      [bytesDict setObject:dataString forKey:GDTCCTNetworkConnectionInfo];
  114|      0|      self.customBytes = [NSJSONSerialization dataWithJSONObject:bytesDict options:0 error:&error];
  115|      0|      if (error) {
  116|      0|        self.customBytes = nil;
  117|      0|        GDTCORLogDebug(@"Error when setting an event's network_connection_info: %@", error);
  118|      0|      }
  119|      0|    }
  120|      0|  } @catch (NSException *exception) {
  121|      0|    GDTCORLogDebug(@"Error when setting an event's network_connection_info: %@", exception);
  122|      0|  }
  123|      0|}
  124|       |
  125|      0|- (nullable NSData *)networkConnectionInfoData {
  126|      0|  if (self.customBytes) {
  127|      0|    @try {
  128|      0|      NSError *error;
  129|      0|      NSDictionary *bytesDict = [NSJSONSerialization JSONObjectWithData:self.customBytes
  130|      0|                                                                options:0
  131|      0|                                                                  error:&error];
  132|      0|      NSString *base64Data = bytesDict[GDTCCTNetworkConnectionInfo];
  133|      0|      if (base64Data == nil) {
  134|      0|        return nil;
  135|      0|      }
  136|       |
  137|      0|      NSData *networkConnectionInfoData = [[NSData alloc] initWithBase64EncodedString:base64Data
  138|      0|                                                                              options:0];
  139|      0|      if (error) {
  140|      0|        GDTCORLogDebug(@"Error when getting an event's network_connection_info: %@", error);
  141|      0|        return nil;
  142|      0|      } else {
  143|      0|        return networkConnectionInfoData;
  144|      0|      }
  145|      0|    } @catch (NSException *exception) {
  146|      0|      GDTCORLogDebug(@"Error when getting an event's network_connection_info: %@", exception);
  147|      0|    }
  148|      0|  }
  149|      0|  return nil;
  150|      0|}
  151|       |
  152|      0|- (NSNumber *)eventCode {
  153|      0|  if (self.customBytes) {
  154|      0|    @try {
  155|      0|      NSError *error;
  156|      0|      NSDictionary *bytesDict = [NSJSONSerialization JSONObjectWithData:self.customBytes
  157|      0|                                                                options:0
  158|      0|                                                                  error:&error];
  159|      0|      NSString *eventCodeString = bytesDict[GDTCCTEventCodeInfo];
  160|       |
  161|      0|      if (!eventCodeString) {
  162|      0|        return nil;
  163|      0|      }
  164|       |
  165|      0|      NSNumberFormatter *formatter = [[NSNumberFormatter alloc] init];
  166|      0|      formatter.numberStyle = NSNumberFormatterDecimalStyle;
  167|      0|      NSNumber *eventCode = [formatter numberFromString:eventCodeString];
  168|       |
  169|      0|      if (error) {
  170|      0|        GDTCORLogDebug(@"Error when getting an event's network_connection_info: %@", error);
  171|      0|        return nil;
  172|      0|      } else {
  173|      0|        return eventCode;
  174|      0|      }
  175|      0|    } @catch (NSException *exception) {
  176|      0|      GDTCORLogDebug(@"Error when getting an event's event_code: %@", exception);
  177|      0|    }
  178|      0|  }
  179|      0|  return nil;
  180|      0|}
  181|       |
  182|      0|- (void)setEventCode:(NSNumber *)eventCode {
  183|      0|  if (eventCode == nil) {
  184|      0|    if (!self.customBytes) {
  185|      0|      return;
  186|      0|    }
  187|       |
  188|      0|    NSError *error;
  189|      0|    NSMutableDictionary *bytesDict = [[NSJSONSerialization JSONObjectWithData:self.customBytes
  190|      0|                                                                      options:0
  191|      0|                                                                        error:&error] mutableCopy];
  192|      0|    if (error) {
  193|      0|      GDTCORLogDebug(@"Error when setting an event's event_code: %@", error);
  194|      0|      return;
  195|      0|    }
  196|       |
  197|      0|    [bytesDict removeObjectForKey:GDTCCTEventCodeInfo];
  198|      0|    self.customBytes = [NSJSONSerialization dataWithJSONObject:bytesDict options:0 error:&error];
  199|      0|    if (error) {
  200|      0|      self.customBytes = nil;
  201|      0|      GDTCORLogDebug(@"Error when setting an event's event_code: %@", error);
  202|      0|      return;
  203|      0|    }
  204|      0|    return;
  205|      0|  }
  206|       |
  207|      0|  @try {
  208|      0|    NSMutableDictionary *bytesDict;
  209|      0|    NSError *error;
  210|      0|    if (self.customBytes) {
  211|      0|      bytesDict = [[NSJSONSerialization JSONObjectWithData:self.customBytes options:0
  212|      0|                                                     error:&error] mutableCopy];
  213|      0|      if (error) {
  214|      0|        GDTCORLogDebug(@"Error when setting an event's event_code: %@", error);
  215|      0|        return;
  216|      0|      }
  217|      0|    } else {
  218|      0|      bytesDict = [[NSMutableDictionary alloc] init];
  219|      0|    }
  220|       |
  221|      0|    NSString *eventCodeString = [eventCode stringValue];
  222|      0|    if (eventCodeString == nil) {
  223|      0|      return;
  224|      0|    }
  225|       |
  226|      0|    [bytesDict setObject:eventCodeString forKey:GDTCCTEventCodeInfo];
  227|       |
  228|      0|    self.customBytes = [NSJSONSerialization dataWithJSONObject:bytesDict options:0 error:&error];
  229|      0|    if (error) {
  230|      0|      self.customBytes = nil;
  231|      0|      GDTCORLogDebug(@"Error when setting an event's network_connection_info: %@", error);
  232|      0|      return;
  233|      0|    }
  234|       |
  235|      0|  } @catch (NSException *exception) {
  236|      0|    GDTCORLogDebug(@"Error when getting an event's network_connection_info: %@", exception);
  237|      0|  }
  238|      0|}
  239|       |
  240|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCCTLibrary/Protogen/nanopb/cct.nanopb.h:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |/* Automatically generated nanopb header */
   18|       |/* Generated by nanopb-0.3.9.7 */
   19|       |
   20|       |#ifndef PB_GDT_CCT_CCT_NANOPB_H_INCLUDED
   21|       |#define PB_GDT_CCT_CCT_NANOPB_H_INCLUDED
   22|       |#include <nanopb/pb.h>
   23|       |
   24|       |/* @@protoc_insertion_point(includes) */
   25|       |#if PB_PROTO_HEADER_VERSION != 30
   26|       |#error Regenerate this file with the current version of nanopb generator.
   27|       |#endif
   28|       |
   29|       |
   30|       |/* Enum definitions */
   31|       |typedef enum _gdt_cct_NetworkConnectionInfo_NetworkType {
   32|       |    gdt_cct_NetworkConnectionInfo_NetworkType_NONE = -1,
   33|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE = 0,
   34|       |    gdt_cct_NetworkConnectionInfo_NetworkType_WIFI = 1,
   35|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_MMS = 2,
   36|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_SUPL = 3,
   37|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_DUN = 4,
   38|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_HIPRI = 5,
   39|       |    gdt_cct_NetworkConnectionInfo_NetworkType_WIMAX = 6,
   40|       |    gdt_cct_NetworkConnectionInfo_NetworkType_BLUETOOTH = 7,
   41|       |    gdt_cct_NetworkConnectionInfo_NetworkType_DUMMY = 8,
   42|       |    gdt_cct_NetworkConnectionInfo_NetworkType_ETHERNET = 9,
   43|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_FOTA = 10,
   44|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_IMS = 11,
   45|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_CBS = 12,
   46|       |    gdt_cct_NetworkConnectionInfo_NetworkType_WIFI_P2P = 13,
   47|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_IA = 14,
   48|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_EMERGENCY = 15,
   49|       |    gdt_cct_NetworkConnectionInfo_NetworkType_PROXY = 16,
   50|       |    gdt_cct_NetworkConnectionInfo_NetworkType_VPN = 17
   51|       |} gdt_cct_NetworkConnectionInfo_NetworkType;
   52|       |#define _gdt_cct_NetworkConnectionInfo_NetworkType_MIN gdt_cct_NetworkConnectionInfo_NetworkType_NONE
   53|       |#define _gdt_cct_NetworkConnectionInfo_NetworkType_MAX gdt_cct_NetworkConnectionInfo_NetworkType_VPN
   54|       |#define _gdt_cct_NetworkConnectionInfo_NetworkType_ARRAYSIZE ((gdt_cct_NetworkConnectionInfo_NetworkType)(gdt_cct_NetworkConnectionInfo_NetworkType_VPN+1))
   55|       |
   56|       |typedef enum _gdt_cct_NetworkConnectionInfo_MobileSubtype {
   57|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_UNKNOWN_MOBILE_SUBTYPE = 0,
   58|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_GPRS = 1,
   59|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_EDGE = 2,
   60|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_UMTS = 3,
   61|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_CDMA = 4,
   62|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_EVDO_0 = 5,
   63|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_EVDO_A = 6,
   64|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_RTT = 7,
   65|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_HSDPA = 8,
   66|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_HSUPA = 9,
   67|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_HSPA = 10,
   68|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_IDEN = 11,
   69|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_EVDO_B = 12,
   70|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_LTE = 13,
   71|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_EHRPD = 14,
   72|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_HSPAP = 15,
   73|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_GSM = 16,
   74|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_TD_SCDMA = 17,
   75|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_IWLAN = 18,
   76|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_LTE_CA = 19,
   77|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_COMBINED = 100
   78|       |} gdt_cct_NetworkConnectionInfo_MobileSubtype;
   79|       |#define _gdt_cct_NetworkConnectionInfo_MobileSubtype_MIN gdt_cct_NetworkConnectionInfo_MobileSubtype_UNKNOWN_MOBILE_SUBTYPE
   80|       |#define _gdt_cct_NetworkConnectionInfo_MobileSubtype_MAX gdt_cct_NetworkConnectionInfo_MobileSubtype_COMBINED
   81|       |#define _gdt_cct_NetworkConnectionInfo_MobileSubtype_ARRAYSIZE ((gdt_cct_NetworkConnectionInfo_MobileSubtype)(gdt_cct_NetworkConnectionInfo_MobileSubtype_COMBINED+1))
   82|       |
   83|       |typedef enum _gdt_cct_ClientInfo_ClientType {
   84|       |    gdt_cct_ClientInfo_ClientType_CLIENT_UNKNOWN = 0,
   85|       |    gdt_cct_ClientInfo_ClientType_IOS_FIREBASE = 15
   86|       |} gdt_cct_ClientInfo_ClientType;
   87|      0|#define _gdt_cct_ClientInfo_ClientType_MIN gdt_cct_ClientInfo_ClientType_CLIENT_UNKNOWN
   88|       |#define _gdt_cct_ClientInfo_ClientType_MAX gdt_cct_ClientInfo_ClientType_IOS_FIREBASE
   89|       |#define _gdt_cct_ClientInfo_ClientType_ARRAYSIZE ((gdt_cct_ClientInfo_ClientType)(gdt_cct_ClientInfo_ClientType_IOS_FIREBASE+1))
   90|       |
   91|       |typedef enum _gdt_cct_QosTierConfiguration_QosTier {
   92|       |    gdt_cct_QosTierConfiguration_QosTier_DEFAULT = 0,
   93|       |    gdt_cct_QosTierConfiguration_QosTier_UNMETERED_ONLY = 1,
   94|       |    gdt_cct_QosTierConfiguration_QosTier_UNMETERED_OR_DAILY = 2,
   95|       |    gdt_cct_QosTierConfiguration_QosTier_FAST_IF_RADIO_AWAKE = 3,
   96|       |    gdt_cct_QosTierConfiguration_QosTier_NEVER = 4
   97|       |} gdt_cct_QosTierConfiguration_QosTier;
   98|       |#define _gdt_cct_QosTierConfiguration_QosTier_MIN gdt_cct_QosTierConfiguration_QosTier_DEFAULT
   99|       |#define _gdt_cct_QosTierConfiguration_QosTier_MAX gdt_cct_QosTierConfiguration_QosTier_NEVER
  100|       |#define _gdt_cct_QosTierConfiguration_QosTier_ARRAYSIZE ((gdt_cct_QosTierConfiguration_QosTier)(gdt_cct_QosTierConfiguration_QosTier_NEVER+1))
  101|       |
  102|       |/* Struct definitions */
  103|       |typedef struct _gdt_cct_BatchedLogRequest {
  104|       |    pb_size_t log_request_count;
  105|       |    struct _gdt_cct_LogRequest *log_request;
  106|       |/* @@protoc_insertion_point(struct:gdt_cct_BatchedLogRequest) */
  107|       |} gdt_cct_BatchedLogRequest;
  108|       |
  109|       |typedef struct _gdt_cct_IosClientInfo {
  110|       |    pb_bytes_array_t *os_major_version;
  111|       |    pb_bytes_array_t *os_full_version;
  112|       |    pb_bytes_array_t *application_build;
  113|       |    pb_bytes_array_t *country;
  114|       |    pb_bytes_array_t *model;
  115|       |    pb_bytes_array_t *language_code;
  116|       |    pb_bytes_array_t *application_bundle_id;
  117|       |/* @@protoc_insertion_point(struct:gdt_cct_IosClientInfo) */
  118|       |} gdt_cct_IosClientInfo;
  119|       |
  120|       |typedef struct _gdt_cct_ClientInfo {
  121|       |    bool has_client_type;
  122|       |    gdt_cct_ClientInfo_ClientType client_type;
  123|       |    bool has_ios_client_info;
  124|       |    gdt_cct_IosClientInfo ios_client_info;
  125|       |/* @@protoc_insertion_point(struct:gdt_cct_ClientInfo) */
  126|       |} gdt_cct_ClientInfo;
  127|       |
  128|       |typedef struct _gdt_cct_NetworkConnectionInfo {
  129|       |    bool has_network_type;
  130|       |    gdt_cct_NetworkConnectionInfo_NetworkType network_type;
  131|       |    bool has_mobile_subtype;
  132|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype mobile_subtype;
  133|       |/* @@protoc_insertion_point(struct:gdt_cct_NetworkConnectionInfo) */
  134|       |} gdt_cct_NetworkConnectionInfo;
  135|       |
  136|       |typedef struct _gdt_cct_QosTierConfiguration {
  137|       |    bool has_qos_tier;
  138|       |    gdt_cct_QosTierConfiguration_QosTier qos_tier;
  139|       |    bool has_log_source;
  140|       |    int32_t log_source;
  141|       |/* @@protoc_insertion_point(struct:gdt_cct_QosTierConfiguration) */
  142|       |} gdt_cct_QosTierConfiguration;
  143|       |
  144|       |typedef struct _gdt_cct_QosTiersOverride {
  145|       |    pb_size_t qos_tier_configuration_count;
  146|       |    struct _gdt_cct_QosTierConfiguration *qos_tier_configuration;
  147|       |    bool has_qos_tier_fingerprint;
  148|       |    int64_t qos_tier_fingerprint;
  149|       |/* @@protoc_insertion_point(struct:gdt_cct_QosTiersOverride) */
  150|       |} gdt_cct_QosTiersOverride;
  151|       |
  152|       |typedef struct _gdt_cct_LogEvent {
  153|       |    bool has_event_time_ms;
  154|       |    int64_t event_time_ms;
  155|       |    pb_bytes_array_t *source_extension;
  156|       |    bool has_event_code;
  157|       |    int32_t event_code;
  158|       |    bool has_timezone_offset_seconds;
  159|       |    int64_t timezone_offset_seconds;
  160|       |    bool has_event_uptime_ms;
  161|       |    int64_t event_uptime_ms;
  162|       |    bool has_network_connection_info;
  163|       |    gdt_cct_NetworkConnectionInfo network_connection_info;
  164|       |/* @@protoc_insertion_point(struct:gdt_cct_LogEvent) */
  165|       |} gdt_cct_LogEvent;
  166|       |
  167|       |typedef struct _gdt_cct_LogRequest {
  168|       |    bool has_client_info;
  169|       |    gdt_cct_ClientInfo client_info;
  170|       |    bool has_log_source;
  171|       |    int32_t log_source;
  172|       |    pb_size_t log_event_count;
  173|       |    struct _gdt_cct_LogEvent *log_event;
  174|       |    bool has_request_time_ms;
  175|       |    int64_t request_time_ms;
  176|       |    bool has_request_uptime_ms;
  177|       |    int64_t request_uptime_ms;
  178|       |    bool has_qos_tier;
  179|       |    gdt_cct_QosTierConfiguration_QosTier qos_tier;
  180|       |/* @@protoc_insertion_point(struct:gdt_cct_LogRequest) */
  181|       |} gdt_cct_LogRequest;
  182|       |
  183|       |typedef struct _gdt_cct_LogResponse {
  184|       |    bool has_next_request_wait_millis;
  185|       |    int64_t next_request_wait_millis;
  186|       |    bool has_qos_tier;
  187|       |    gdt_cct_QosTiersOverride qos_tier;
  188|       |/* @@protoc_insertion_point(struct:gdt_cct_LogResponse) */
  189|       |} gdt_cct_LogResponse;
  190|       |
  191|       |/* Default values for struct fields */
  192|       |extern const gdt_cct_NetworkConnectionInfo_NetworkType gdt_cct_NetworkConnectionInfo_network_type_default;
  193|       |extern const gdt_cct_NetworkConnectionInfo_MobileSubtype gdt_cct_NetworkConnectionInfo_mobile_subtype_default;
  194|       |extern const gdt_cct_QosTierConfiguration_QosTier gdt_cct_LogRequest_qos_tier_default;
  195|       |extern const int32_t gdt_cct_QosTierConfiguration_log_source_default;
  196|       |
  197|       |/* Initializer values for message structs */
  198|      0|#define gdt_cct_LogEvent_init_default            {false, 0, NULL, false, 0, false, 0, false, 0, false, gdt_cct_NetworkConnectionInfo_init_default}
  199|      0|#define gdt_cct_NetworkConnectionInfo_init_default {false, gdt_cct_NetworkConnectionInfo_NetworkType_NONE, false, gdt_cct_NetworkConnectionInfo_MobileSubtype_UNKNOWN_MOBILE_SUBTYPE}
  200|      0|#define gdt_cct_IosClientInfo_init_default       {NULL, NULL, NULL, NULL, NULL, NULL, NULL}
  201|      0|#define gdt_cct_ClientInfo_init_default          {false, _gdt_cct_ClientInfo_ClientType_MIN, false, gdt_cct_IosClientInfo_init_default}
  202|      0|#define gdt_cct_BatchedLogRequest_init_default   {0, NULL}
  203|      0|#define gdt_cct_LogRequest_init_default          {false, gdt_cct_ClientInfo_init_default, false, 0, 0, NULL, false, 0, false, 0, false, gdt_cct_QosTierConfiguration_QosTier_DEFAULT}
  204|       |#define gdt_cct_QosTierConfiguration_init_default {false, _gdt_cct_QosTierConfiguration_QosTier_MIN, false, 0}
  205|      0|#define gdt_cct_QosTiersOverride_init_default    {0, NULL, false, 0}
  206|      0|#define gdt_cct_LogResponse_init_default         {false, 0, false, gdt_cct_QosTiersOverride_init_default}
  207|       |#define gdt_cct_LogEvent_init_zero               {false, 0, NULL, false, 0, false, 0, false, 0, false, gdt_cct_NetworkConnectionInfo_init_zero}
  208|       |#define gdt_cct_NetworkConnectionInfo_init_zero  {false, _gdt_cct_NetworkConnectionInfo_NetworkType_MIN, false, _gdt_cct_NetworkConnectionInfo_MobileSubtype_MIN}
  209|       |#define gdt_cct_IosClientInfo_init_zero          {NULL, NULL, NULL, NULL, NULL, NULL, NULL}
  210|       |#define gdt_cct_ClientInfo_init_zero             {false, _gdt_cct_ClientInfo_ClientType_MIN, false, gdt_cct_IosClientInfo_init_zero}
  211|       |#define gdt_cct_BatchedLogRequest_init_zero      {0, NULL}
  212|       |#define gdt_cct_LogRequest_init_zero             {false, gdt_cct_ClientInfo_init_zero, false, 0, 0, NULL, false, 0, false, 0, false, _gdt_cct_QosTierConfiguration_QosTier_MIN}
  213|       |#define gdt_cct_QosTierConfiguration_init_zero   {false, _gdt_cct_QosTierConfiguration_QosTier_MIN, false, 0}
  214|       |#define gdt_cct_QosTiersOverride_init_zero       {0, NULL, false, 0}
  215|       |#define gdt_cct_LogResponse_init_zero            {false, 0, false, gdt_cct_QosTiersOverride_init_zero}
  216|       |
  217|       |/* Field tags (for use in manual encoding/decoding) */
  218|       |#define gdt_cct_BatchedLogRequest_log_request_tag 1
  219|       |#define gdt_cct_IosClientInfo_os_major_version_tag 3
  220|       |#define gdt_cct_IosClientInfo_os_full_version_tag 4
  221|       |#define gdt_cct_IosClientInfo_application_build_tag 5
  222|       |#define gdt_cct_IosClientInfo_country_tag        6
  223|       |#define gdt_cct_IosClientInfo_model_tag          7
  224|       |#define gdt_cct_IosClientInfo_language_code_tag  8
  225|       |#define gdt_cct_IosClientInfo_application_bundle_id_tag 11
  226|       |#define gdt_cct_ClientInfo_client_type_tag       1
  227|       |#define gdt_cct_ClientInfo_ios_client_info_tag   4
  228|       |#define gdt_cct_NetworkConnectionInfo_network_type_tag 1
  229|       |#define gdt_cct_NetworkConnectionInfo_mobile_subtype_tag 2
  230|       |#define gdt_cct_QosTierConfiguration_qos_tier_tag 2
  231|       |#define gdt_cct_QosTierConfiguration_log_source_tag 3
  232|       |#define gdt_cct_QosTiersOverride_qos_tier_configuration_tag 1
  233|       |#define gdt_cct_QosTiersOverride_qos_tier_fingerprint_tag 2
  234|       |#define gdt_cct_LogEvent_event_time_ms_tag       1
  235|       |#define gdt_cct_LogEvent_event_code_tag          11
  236|       |#define gdt_cct_LogEvent_event_uptime_ms_tag     17
  237|       |#define gdt_cct_LogEvent_source_extension_tag    6
  238|       |#define gdt_cct_LogEvent_timezone_offset_seconds_tag 15
  239|       |#define gdt_cct_LogEvent_network_connection_info_tag 23
  240|       |#define gdt_cct_LogRequest_request_time_ms_tag   4
  241|       |#define gdt_cct_LogRequest_request_uptime_ms_tag 8
  242|       |#define gdt_cct_LogRequest_client_info_tag       1
  243|       |#define gdt_cct_LogRequest_log_source_tag        2
  244|       |#define gdt_cct_LogRequest_log_event_tag         3
  245|       |#define gdt_cct_LogRequest_qos_tier_tag          9
  246|       |#define gdt_cct_LogResponse_next_request_wait_millis_tag 1
  247|       |#define gdt_cct_LogResponse_qos_tier_tag         3
  248|       |
  249|       |/* Struct field encoding specification for nanopb */
  250|       |extern const pb_field_t gdt_cct_LogEvent_fields[7];
  251|       |extern const pb_field_t gdt_cct_NetworkConnectionInfo_fields[3];
  252|       |extern const pb_field_t gdt_cct_IosClientInfo_fields[8];
  253|       |extern const pb_field_t gdt_cct_ClientInfo_fields[3];
  254|       |extern const pb_field_t gdt_cct_BatchedLogRequest_fields[2];
  255|       |extern const pb_field_t gdt_cct_LogRequest_fields[7];
  256|       |extern const pb_field_t gdt_cct_QosTierConfiguration_fields[3];
  257|       |extern const pb_field_t gdt_cct_QosTiersOverride_fields[3];
  258|       |extern const pb_field_t gdt_cct_LogResponse_fields[3];
  259|       |
  260|       |/* Maximum encoded size of messages (where known) */
  261|       |/* gdt_cct_LogEvent_size depends on runtime parameters */
  262|       |#define gdt_cct_NetworkConnectionInfo_size       13
  263|       |/* gdt_cct_IosClientInfo_size depends on runtime parameters */
  264|       |/* gdt_cct_ClientInfo_size depends on runtime parameters */
  265|       |/* gdt_cct_BatchedLogRequest_size depends on runtime parameters */
  266|       |/* gdt_cct_LogRequest_size depends on runtime parameters */
  267|       |#define gdt_cct_QosTierConfiguration_size        13
  268|       |/* gdt_cct_QosTiersOverride_size depends on runtime parameters */
  269|       |/* gdt_cct_LogResponse_size depends on runtime parameters */
  270|       |
  271|       |/* Message IDs (where set with "msgid" option) */
  272|       |#ifdef PB_MSGID
  273|       |
  274|       |#define CCT_MESSAGES \
  275|       |
  276|       |
  277|       |#endif
  278|       |
  279|       |/* @@protoc_insertion_point(eof) */
  280|       |
  281|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORAssert.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORAssert.h"
   18|       |
   19|      0|GDTCORAssertionBlock GDTCORAssertionBlockToRunInstead(void) {
   20|       |  // This class is only compiled in by unit tests, and this should fail quickly in optimized builds.
   21|      0|  Class GDTCORAssertClass = NSClassFromString(@"GDTCORAssertHelper");
   22|      0|  if (__builtin_expect(!!GDTCORAssertClass, 0)) {
   23|      0|    SEL assertionBlockSEL = NSSelectorFromString(@"assertionBlock");
   24|      0|    if (assertionBlockSEL) {
   25|      0|      IMP assertionBlockIMP = [GDTCORAssertClass methodForSelector:assertionBlockSEL];
   26|      0|      if (assertionBlockIMP) {
   27|      0|        GDTCORAssertionBlock assertionBlock = ((GDTCORAssertionBlock(*)(id, SEL))assertionBlockIMP)(
   28|      0|            GDTCORAssertClass, assertionBlockSEL);
   29|      0|        if (assertionBlock) {
   30|      0|          return assertionBlock;
   31|      0|        }
   32|      0|      }
   33|      0|    }
   34|      0|  }
   35|      0|  return NULL;
   36|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORClock.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORClock.h"
   18|       |
   19|       |#import <sys/sysctl.h>
   20|       |
   21|       |// Using a monotonic clock is necessary because CFAbsoluteTimeGetCurrent(), NSDate, and related all
   22|       |// are subject to drift. That it to say, multiple consecutive calls do not always result in a
   23|       |// time that is in the future. Clocks may be adjusted by the user, NTP, or any number of external
   24|       |// factors. This class attempts to determine the wall-clock time at the time of the event by
   25|       |// capturing the kernel start and time since boot to determine a wallclock time in UTC.
   26|       |//
   27|       |// Timezone offsets at the time of a snapshot are also captured in order to provide local-time
   28|       |// details. Other classes in this library depend on comparing times at some time in the future to
   29|       |// a time captured in the past, and this class needs to provide a mechanism to do that.
   30|       |//
   31|       |// TL;DR: This class attempts to accomplish two things: 1. Provide accurate event times. 2. Provide
   32|       |// a monotonic clock mechanism to accurately check if some clock snapshot was before or after
   33|       |// by using a shared reference point (kernel boot time).
   34|       |//
   35|       |// Note: Much of the mach time stuff doesn't work properly in the simulator. So this class can be
   36|       |// difficult to unit test.
   37|       |
   38|       |/** Returns the kernel boottime property from sysctl.
   39|       | *
   40|       | * Inspired by https://stackoverflow.com/a/40497811
   41|       | *
   42|       | * @return The KERN_BOOTTIME property from sysctl, in nanoseconds.
   43|       | */
   44|      0|static int64_t KernelBootTimeInNanoseconds() {
   45|       |  // Caching the result is not possible because clock drift would not be accounted for.
   46|      0|  struct timeval boottime;
   47|      0|  int mib[2] = {CTL_KERN, KERN_BOOTTIME};
   48|      0|  size_t size = sizeof(boottime);
   49|      0|  int rc = sysctl(mib, 2, &boottime, &size, NULL, 0);
   50|      0|  if (rc != 0) {
   51|      0|    return 0;
   52|      0|  }
   53|      0|  return (int64_t)boottime.tv_sec * NSEC_PER_SEC + (int64_t)boottime.tv_usec * NSEC_PER_USEC;
   54|      0|}
   55|       |
   56|       |/** Returns value of gettimeofday, in nanoseconds.
   57|       | *
   58|       | * Inspired by https://stackoverflow.com/a/40497811
   59|       | *
   60|       | * @return The value of gettimeofday, in nanoseconds.
   61|       | */
   62|      0|static int64_t UptimeInNanoseconds() {
   63|      0|  int64_t before_now_nsec;
   64|      0|  int64_t after_now_nsec;
   65|      0|  struct timeval now;
   66|       |
   67|      0|  before_now_nsec = KernelBootTimeInNanoseconds();
   68|       |  // Addresses a race condition in which the system time has updated, but the boottime has not.
   69|      0|  do {
   70|      0|    gettimeofday(&now, NULL);
   71|      0|    after_now_nsec = KernelBootTimeInNanoseconds();
   72|      0|  } while (after_now_nsec != before_now_nsec);
   73|      0|  return (int64_t)now.tv_sec * NSEC_PER_SEC + (int64_t)now.tv_usec * NSEC_PER_USEC -
   74|      0|         before_now_nsec;
   75|      0|}
   76|       |
   77|       |// TODO: Consider adding a 'trustedTime' property that can be populated by the response from a BE.
   78|       |@implementation GDTCORClock
   79|       |
   80|      0|- (instancetype)init {
   81|      0|  self = [super init];
   82|      0|  if (self) {
   83|      0|    _kernelBootTimeNanoseconds = KernelBootTimeInNanoseconds();
   84|      0|    _uptimeNanoseconds = UptimeInNanoseconds();
   85|      0|    _timeMillis =
   86|      0|        (int64_t)((CFAbsoluteTimeGetCurrent() + kCFAbsoluteTimeIntervalSince1970) * NSEC_PER_USEC);
   87|      0|    _timezoneOffsetSeconds = [[NSTimeZone systemTimeZone] secondsFromGMT];
   88|      0|  }
   89|      0|  return self;
   90|      0|}
   91|       |
   92|      0|+ (GDTCORClock *)snapshot {
   93|      0|  return [[GDTCORClock alloc] init];
   94|      0|}
   95|       |
   96|      0|+ (instancetype)clockSnapshotInTheFuture:(uint64_t)millisInTheFuture {
   97|      0|  GDTCORClock *snapshot = [self snapshot];
   98|      0|  snapshot->_timeMillis += millisInTheFuture;
   99|      0|  return snapshot;
  100|      0|}
  101|       |
  102|      0|- (BOOL)isAfter:(GDTCORClock *)otherClock {
  103|       |  // These clocks are trivially comparable when they share a kernel boot time.
  104|      0|  if (_kernelBootTimeNanoseconds == otherClock->_kernelBootTimeNanoseconds) {
  105|      0|    int64_t timeDiff = (_timeMillis + _timezoneOffsetSeconds) -
  106|      0|                       (otherClock->_timeMillis + otherClock->_timezoneOffsetSeconds);
  107|      0|    return timeDiff > 0;
  108|      0|  } else {
  109|      0|    int64_t kernelBootTimeDiff =
  110|      0|        otherClock->_kernelBootTimeNanoseconds - _kernelBootTimeNanoseconds;
  111|       |    // This isn't a great solution, but essentially, if the other clock's boot time is 'later', NO
  112|       |    // is returned. This can be altered by changing the system time and rebooting.
  113|      0|    return kernelBootTimeDiff < 0 ? YES : NO;
  114|      0|  }
  115|      0|}
  116|       |
  117|      0|- (int64_t)uptimeMilliseconds {
  118|      0|  return self.uptimeNanoseconds / NSEC_PER_MSEC;
  119|      0|}
  120|       |
  121|      0|- (NSUInteger)hash {
  122|      0|  return [@(_kernelBootTimeNanoseconds) hash] ^ [@(_uptimeNanoseconds) hash] ^
  123|      0|         [@(_timeMillis) hash] ^ [@(_timezoneOffsetSeconds) hash];
  124|      0|}
  125|       |
  126|      0|- (BOOL)isEqual:(id)object {
  127|      0|  return [self hash] == [object hash];
  128|      0|}
  129|       |
  130|       |#pragma mark - NSSecureCoding
  131|       |
  132|       |/** NSKeyedCoder key for timeMillis property. */
  133|       |static NSString *const kGDTCORClockTimeMillisKey = @"GDTCORClockTimeMillis";
  134|       |
  135|       |/** NSKeyedCoder key for timezoneOffsetMillis property. */
  136|       |static NSString *const kGDTCORClockTimezoneOffsetSeconds = @"GDTCORClockTimezoneOffsetSeconds";
  137|       |
  138|       |/** NSKeyedCoder key for _kernelBootTime ivar. */
  139|       |static NSString *const kGDTCORClockKernelBootTime = @"GDTCORClockKernelBootTime";
  140|       |
  141|       |/** NSKeyedCoder key for _uptimeNanoseconds ivar. */
  142|       |static NSString *const kGDTCORClockUptime = @"GDTCORClockUptime";
  143|       |
  144|      0|+ (BOOL)supportsSecureCoding {
  145|      0|  return YES;
  146|      0|}
  147|       |
  148|      0|- (instancetype)initWithCoder:(NSCoder *)aDecoder {
  149|      0|  self = [super init];
  150|      0|  if (self) {
  151|       |    // TODO: If the kernelBootTimeNanoseconds is more recent, we need to change the kernel boot time
  152|       |    // and uptimeMillis ivars
  153|      0|    _timeMillis = [aDecoder decodeInt64ForKey:kGDTCORClockTimeMillisKey];
  154|      0|    _timezoneOffsetSeconds = [aDecoder decodeInt64ForKey:kGDTCORClockTimezoneOffsetSeconds];
  155|      0|    _kernelBootTimeNanoseconds = [aDecoder decodeInt64ForKey:kGDTCORClockKernelBootTime];
  156|      0|    _uptimeNanoseconds = [aDecoder decodeInt64ForKey:kGDTCORClockUptime];
  157|      0|  }
  158|      0|  return self;
  159|      0|}
  160|       |
  161|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  162|      0|  [aCoder encodeInt64:_timeMillis forKey:kGDTCORClockTimeMillisKey];
  163|      0|  [aCoder encodeInt64:_timezoneOffsetSeconds forKey:kGDTCORClockTimezoneOffsetSeconds];
  164|      0|  [aCoder encodeInt64:_kernelBootTimeNanoseconds forKey:kGDTCORClockKernelBootTime];
  165|      0|  [aCoder encodeInt64:_uptimeNanoseconds forKey:kGDTCORClockUptime];
  166|      0|}
  167|       |
  168|       |#pragma mark - Deprecated properties
  169|       |
  170|      0|- (int64_t)kernelBootTime {
  171|      0|  return self.kernelBootTimeNanoseconds;
  172|      0|}
  173|       |
  174|      0|- (int64_t)uptime {
  175|      0|  return self.uptimeNanoseconds;
  176|      0|}
  177|       |
  178|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORConsoleLogger.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORConsoleLogger.h"
   18|       |
   19|       |volatile NSInteger GDTCORConsoleLoggerLoggingLevel = GDTCORLoggingLevelErrors;
   20|       |
   21|       |/** The console logger prefix. */
   22|       |static NSString *kGDTCORConsoleLogger = @"[GoogleDataTransport]";
   23|       |
   24|      0|NSString *GDTCORMessageCodeEnumToString(GDTCORMessageCode code) {
   25|      0|  return [[NSString alloc] initWithFormat:@"I-GDTCOR%06ld", (long)code];
   26|      0|}
   27|       |
   28|     50|void GDTCORLog(GDTCORMessageCode code, GDTCORLoggingLevel logLevel, NSString *format, ...) {
   29|       |// Don't log anything in not debug builds.
   30|     50|#if !NDEBUG
   31|     50|  if (logLevel >= GDTCORConsoleLoggerLoggingLevel) {
   32|      0|    NSString *logFormat = [NSString stringWithFormat:@"%@[%@] %@", kGDTCORConsoleLogger,
   33|      0|                                                     GDTCORMessageCodeEnumToString(code), format];
   34|      0|    va_list args;
   35|      0|    va_start(args, format);
   36|      0|    NSLogv(logFormat, args);
   37|      0|    va_end(args);
   38|      0|  }
   39|     50|#endif  // !NDEBUG
   40|     50|}
   41|       |
   42|       |void GDTCORLogAssert(
   43|      0|    BOOL wasFatal, NSString *_Nonnull file, NSInteger line, NSString *_Nullable format, ...) {
   44|       |// Don't log anything in not debug builds.
   45|      0|#if !NDEBUG
   46|      0|  GDTCORMessageCode code = wasFatal ? GDTCORMCEFatalAssertion : GDTCORMCEGeneralError;
   47|      0|  NSString *logFormat =
   48|      0|      [NSString stringWithFormat:@"%@[%@] (%@:%ld) : %@", kGDTCORConsoleLogger,
   49|      0|                                 GDTCORMessageCodeEnumToString(code), file, (long)line, format];
   50|      0|  va_list args;
   51|      0|  va_start(args, format);
   52|      0|  NSLogv(logFormat, args);
   53|      0|  va_end(args);
   54|      0|#endif  // !NDEBUG
   55|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORDirectorySizeTracker.m:
    1|       |/*
    2|       | * Copyright 2020 Google LLC
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORDirectorySizeTracker.h"
   18|       |
   19|       |@interface GDTCORDirectorySizeTracker ()
   20|       |
   21|       |/** The observed directory path. */
   22|       |@property(nonatomic, readonly) NSString *directoryPath;
   23|       |
   24|       |/** The cached content size of the observed directory. */
   25|       |@property(nonatomic, nullable) NSNumber *cachedSizeBytes;
   26|       |
   27|       |@end
   28|       |
   29|       |@implementation GDTCORDirectorySizeTracker
   30|       |
   31|      1|- (instancetype)initWithDirectoryPath:(NSString *)path {
   32|      1|  self = [super init];
   33|      1|  if (self) {
   34|      1|    _directoryPath = path;
   35|      1|  }
   36|      1|  return self;
   37|      1|}
   38|       |
   39|      0|- (GDTCORStorageSizeBytes)directoryContentSize {
   40|      0|  if (self.cachedSizeBytes == nil) {
   41|      0|    self.cachedSizeBytes = @([self calculateDirectoryContentSize]);
   42|      0|  }
   43|       |
   44|      0|  return self.cachedSizeBytes.unsignedLongLongValue;
   45|      0|}
   46|       |
   47|      0|- (void)fileWasAddedAtPath:(NSString *)path withSize:(GDTCORStorageSizeBytes)fileSize {
   48|      0|  if (![path hasPrefix:self.directoryPath]) {
   49|       |    // Ignore because the file is not inside the directory.
   50|      0|    return;
   51|      0|  }
   52|       |
   53|      0|  self.cachedSizeBytes = @([self directoryContentSize] + fileSize);
   54|      0|}
   55|       |
   56|      0|- (void)fileWasRemovedAtPath:(NSString *)path withSize:(GDTCORStorageSizeBytes)fileSize {
   57|      0|  if (![path hasPrefix:self.directoryPath]) {
   58|       |    // Ignore because the file is not inside the directory.
   59|      0|    return;
   60|      0|  }
   61|       |
   62|      0|  self.cachedSizeBytes = @([self directoryContentSize] - fileSize);
   63|      0|}
   64|       |
   65|      1|- (void)resetCachedSize {
   66|      1|  self.cachedSizeBytes = nil;
   67|      1|}
   68|       |
   69|      0|- (GDTCORStorageSizeBytes)calculateDirectoryContentSize {
   70|      0|  NSArray *prefetchedProperties = @[ NSURLIsRegularFileKey, NSURLFileSizeKey ];
   71|      0|  uint64_t totalBytes = 0;
   72|      0|  NSURL *directoryURL = [NSURL fileURLWithPath:self.directoryPath];
   73|       |
   74|      0|  NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager]
   75|      0|                 enumeratorAtURL:directoryURL
   76|      0|      includingPropertiesForKeys:prefetchedProperties
   77|      0|                         options:NSDirectoryEnumerationSkipsHiddenFiles
   78|      0|                    errorHandler:^BOOL(NSURL *_Nonnull url, NSError *_Nonnull error) {
   79|      0|                      return YES;
   80|      0|                    }];
   81|       |
   82|      0|  for (NSURL *fileURL in enumerator) {
   83|      0|    @autoreleasepool {
   84|      0|      NSNumber *isRegularFile;
   85|      0|      [fileURL getResourceValue:&isRegularFile forKey:NSURLIsRegularFileKey error:nil];
   86|      0|      if (isRegularFile.boolValue) {
   87|      0|        totalBytes += [self fileSizeAtURL:fileURL];
   88|      0|      }
   89|      0|    }
   90|      0|  }
   91|       |
   92|      0|  return totalBytes;
   93|      0|}
   94|       |
   95|      0|- (GDTCORStorageSizeBytes)fileSizeAtURL:(NSURL *)fileURL {
   96|      0|  NSNumber *fileSize;
   97|      0|  [fileURL getResourceValue:&fileSize forKey:NSURLFileSizeKey error:nil];
   98|      0|  return fileSize.unsignedLongLongValue;
   99|      0|}
  100|       |
  101|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCOREndpoints.m:
    1|       |/*
    2|       | * Copyright 2020 Google LLC
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCOREndpoints.h"
   18|       |
   19|       |static NSString *const kINTServerURL =
   20|       |    @"https://dummyapiverylong-dummy.dummy.com/dummy/api/very/long";
   21|       |
   22|       |@implementation GDTCOREndpoints
   23|       |
   24|      4|+ (NSDictionary<NSNumber *, NSURL *> *)uploadURLs {
   25|       |  // These strings should be interleaved to construct the real URL. This is just to (hopefully)
   26|       |  // fool github URL scanning bots.
   27|      4|  static NSURL *CCTServerURL;
   28|      4|  static dispatch_once_t CCTOnceToken;
   29|      1|  dispatch_once(&CCTOnceToken, ^{
   30|      1|    const char *p1 = "hts/frbslgiggolai.o/0clgbth";
   31|      1|    const char *p2 = "tp:/ieaeogn.ogepscmvc/o/ac";
   32|      1|    const char URL[54] = {p1[0],  p2[0],  p1[1],  p2[1],  p1[2],  p2[2],  p1[3],  p2[3],  p1[4],
   33|      1|                          p2[4],  p1[5],  p2[5],  p1[6],  p2[6],  p1[7],  p2[7],  p1[8],  p2[8],
   34|      1|                          p1[9],  p2[9],  p1[10], p2[10], p1[11], p2[11], p1[12], p2[12], p1[13],
   35|      1|                          p2[13], p1[14], p2[14], p1[15], p2[15], p1[16], p2[16], p1[17], p2[17],
   36|      1|                          p1[18], p2[18], p1[19], p2[19], p1[20], p2[20], p1[21], p2[21], p1[22],
   37|      1|                          p2[22], p1[23], p2[23], p1[24], p2[24], p1[25], p2[25], p1[26], '\0'};
   38|      1|    CCTServerURL = [NSURL URLWithString:[NSString stringWithUTF8String:URL]];
   39|      1|  });
   40|       |
   41|      4|  static NSURL *FLLServerURL;
   42|      4|  static dispatch_once_t FLLOnceToken;
   43|      1|  dispatch_once(&FLLOnceToken, ^{
   44|      1|    const char *p1 = "hts/frbslgigp.ogepscmv/ieo/eaybtho";
   45|      1|    const char *p2 = "tp:/ieaeogn-agolai.o/1frlglgc/aclg";
   46|      1|    const char URL[69] = {p1[0],  p2[0],  p1[1],  p2[1],  p1[2],  p2[2],  p1[3],  p2[3],  p1[4],
   47|      1|                          p2[4],  p1[5],  p2[5],  p1[6],  p2[6],  p1[7],  p2[7],  p1[8],  p2[8],
   48|      1|                          p1[9],  p2[9],  p1[10], p2[10], p1[11], p2[11], p1[12], p2[12], p1[13],
   49|      1|                          p2[13], p1[14], p2[14], p1[15], p2[15], p1[16], p2[16], p1[17], p2[17],
   50|      1|                          p1[18], p2[18], p1[19], p2[19], p1[20], p2[20], p1[21], p2[21], p1[22],
   51|      1|                          p2[22], p1[23], p2[23], p1[24], p2[24], p1[25], p2[25], p1[26], p2[26],
   52|      1|                          p1[27], p2[27], p1[28], p2[28], p1[29], p2[29], p1[30], p2[30], p1[31],
   53|      1|                          p2[31], p1[32], p2[32], p1[33], p2[33], '\0'};
   54|      1|    FLLServerURL = [NSURL URLWithString:[NSString stringWithUTF8String:URL]];
   55|      1|  });
   56|       |
   57|      4|  static NSURL *CSHServerURL;
   58|      4|  static dispatch_once_t CSHOnceToken;
   59|      1|  dispatch_once(&CSHOnceToken, ^{
   60|       |    // These strings should be interleaved to construct the real URL. This is just to (hopefully)
   61|       |    // fool github URL scanning bots.
   62|      1|    const char *p1 = "hts/cahyiseot-agolai.o/1frlglgc/aclg";
   63|      1|    const char *p2 = "tp:/rsltcrprsp.ogepscmv/ieo/eaybtho";
   64|      1|    const char URL[72] = {p1[0],  p2[0],  p1[1],  p2[1],  p1[2],  p2[2],  p1[3],  p2[3],  p1[4],
   65|      1|                          p2[4],  p1[5],  p2[5],  p1[6],  p2[6],  p1[7],  p2[7],  p1[8],  p2[8],
   66|      1|                          p1[9],  p2[9],  p1[10], p2[10], p1[11], p2[11], p1[12], p2[12], p1[13],
   67|      1|                          p2[13], p1[14], p2[14], p1[15], p2[15], p1[16], p2[16], p1[17], p2[17],
   68|      1|                          p1[18], p2[18], p1[19], p2[19], p1[20], p2[20], p1[21], p2[21], p1[22],
   69|      1|                          p2[22], p1[23], p2[23], p1[24], p2[24], p1[25], p2[25], p1[26], p2[26],
   70|      1|                          p1[27], p2[27], p1[28], p2[28], p1[29], p2[29], p1[30], p2[30], p1[31],
   71|      1|                          p2[31], p1[32], p2[32], p1[33], p2[33], p1[34], p2[34], p1[35], '\0'};
   72|      1|    CSHServerURL = [NSURL URLWithString:[NSString stringWithUTF8String:URL]];
   73|      1|  });
   74|      4|  static NSDictionary<NSNumber *, NSURL *> *uploadURLs;
   75|      4|  static dispatch_once_t URLOnceToken;
   76|      1|  dispatch_once(&URLOnceToken, ^{
   77|      1|    uploadURLs = @{
   78|      1|      @(kGDTCORTargetCCT) : CCTServerURL,
   79|      1|      @(kGDTCORTargetFLL) : FLLServerURL,
   80|      1|      @(kGDTCORTargetCSH) : CSHServerURL,
   81|      1|      @(kGDTCORTargetINT) : [NSURL URLWithString:kINTServerURL]
   82|      1|    };
   83|      1|  });
   84|      4|  return uploadURLs;
   85|      4|}
   86|       |
   87|      4|+ (nullable NSURL *)uploadURLForTarget:(GDTCORTarget)target {
   88|      4|  NSDictionary<NSNumber *, NSURL *> *URLs = [self uploadURLs];
   89|      4|  return [URLs objectForKey:@(target)];
   90|      4|}
   91|       |
   92|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCOREvent.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCOREvent.h"
   18|       |
   19|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORAssert.h"
   20|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORPlatform.h"
   21|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORStorageProtocol.h"
   22|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORClock.h"
   23|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORConsoleLogger.h"
   24|       |
   25|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCOREvent_Private.h"
   26|       |
   27|       |@implementation GDTCOREvent
   28|       |
   29|      0|+ (NSString *)nextEventID {
   30|       |  // Replace special non-alphanumeric characters to avoid potential conflicts with storage logic.
   31|      0|  return [[NSUUID UUID].UUIDString stringByReplacingOccurrencesOfString:@"-" withString:@""];
   32|      0|}
   33|       |
   34|      0|- (nullable instancetype)initWithMappingID:(NSString *)mappingID target:(GDTCORTarget)target {
   35|      0|  GDTCORAssert(mappingID.length > 0, @"Please give a valid mapping ID");
   36|      0|  GDTCORAssert(target > 0, @"A target cannot be negative or 0");
   37|      0|  if (mappingID.length == 0 || target <= 0) {
   38|      0|    return nil;
   39|      0|  }
   40|      0|  self = [super init];
   41|      0|  if (self) {
   42|      0|    _eventID = [GDTCOREvent nextEventID];
   43|      0|    _mappingID = mappingID;
   44|      0|    _target = target;
   45|      0|    _qosTier = GDTCOREventQosDefault;
   46|      0|    _expirationDate = [NSDate dateWithTimeIntervalSinceNow:604800];  // 7 days.
   47|       |
   48|      0|    GDTCORLogDebug(@"Event %@ created. ID:%@ mappingID: %@ target:%ld", self, _eventID, mappingID,
   49|      0|                   (long)target);
   50|      0|  }
   51|       |
   52|      0|  return self;
   53|      0|}
   54|       |
   55|      0|- (instancetype)copy {
   56|      0|  GDTCOREvent *copy = [[GDTCOREvent alloc] initWithMappingID:_mappingID target:_target];
   57|      0|  copy->_eventID = _eventID;
   58|      0|  copy.dataObject = _dataObject;
   59|      0|  copy.qosTier = _qosTier;
   60|      0|  copy.clockSnapshot = _clockSnapshot;
   61|      0|  copy.customBytes = _customBytes;
   62|      0|  GDTCORLogDebug(@"Copying event %@ to event %@", self, copy);
   63|      0|  return copy;
   64|      0|}
   65|       |
   66|      0|- (NSUInteger)hash {
   67|       |  // This loses some precision, but it's probably fine.
   68|      0|  NSUInteger eventIDHash = [_eventID hash];
   69|      0|  NSUInteger mappingIDHash = [_mappingID hash];
   70|      0|  NSUInteger timeHash = [_clockSnapshot hash];
   71|      0|  NSInteger serializedBytesHash = [_serializedDataObjectBytes hash];
   72|       |
   73|      0|  return eventIDHash ^ mappingIDHash ^ _target ^ _qosTier ^ timeHash ^ serializedBytesHash;
   74|      0|}
   75|       |
   76|      0|- (BOOL)isEqual:(id)object {
   77|      0|  return [self hash] == [object hash];
   78|      0|}
   79|       |
   80|       |#pragma mark - Property overrides
   81|       |
   82|      0|- (void)setDataObject:(id<GDTCOREventDataObject>)dataObject {
   83|       |  // If you're looking here because of a performance issue in -transportBytes slowing the assignment
   84|       |  // of -dataObject, one way to address this is to add a queue to this class,
   85|       |  // dispatch_(barrier_ if concurrent)async here, and implement the getter with a dispatch_sync.
   86|      0|  if (dataObject != _dataObject) {
   87|      0|    _dataObject = dataObject;
   88|      0|  }
   89|      0|  self->_serializedDataObjectBytes = [dataObject transportBytes];
   90|      0|}
   91|       |
   92|       |#pragma mark - NSSecureCoding and NSCoding Protocols
   93|       |
   94|       |/** NSCoding key for eventID property. */
   95|       |static NSString *kEventIDKey = @"GDTCOREventEventIDKey";
   96|       |
   97|       |/** NSCoding key for mappingID property. */
   98|       |static NSString *kMappingIDKey = @"GDTCOREventMappingIDKey";
   99|       |
  100|       |/** NSCoding key for target property. */
  101|       |static NSString *kTargetKey = @"GDTCOREventTargetKey";
  102|       |
  103|       |/** NSCoding key for qosTier property. */
  104|       |static NSString *kQoSTierKey = @"GDTCOREventQoSTierKey";
  105|       |
  106|       |/** NSCoding key for clockSnapshot property. */
  107|       |static NSString *kClockSnapshotKey = @"GDTCOREventClockSnapshotKey";
  108|       |
  109|       |/** NSCoding key for expirationDate property. */
  110|       |static NSString *kExpirationDateKey = @"GDTCOREventExpirationDateKey";
  111|       |
  112|       |/** NSCoding key for serializedDataObjectBytes property. */
  113|       |static NSString *kSerializedDataObjectBytes = @"GDTCOREventSerializedDataObjectBytesKey";
  114|       |
  115|       |/** NSCoding key for customData property. */
  116|       |static NSString *kCustomDataKey = @"GDTCOREventCustomDataKey";
  117|       |
  118|      0|+ (BOOL)supportsSecureCoding {
  119|      0|  return YES;
  120|      0|}
  121|       |
  122|      0|- (id)initWithCoder:(NSCoder *)aDecoder {
  123|      0|  self = [self init];
  124|      0|  if (self) {
  125|      0|    _mappingID = [aDecoder decodeObjectOfClass:[NSString class] forKey:kMappingIDKey];
  126|      0|    _target = [aDecoder decodeIntegerForKey:kTargetKey];
  127|      0|    _eventID = [aDecoder decodeObjectOfClass:[NSString class] forKey:kEventIDKey]
  128|      0|                   ?: [GDTCOREvent nextEventID];
  129|      0|    _qosTier = [aDecoder decodeIntegerForKey:kQoSTierKey];
  130|      0|    _clockSnapshot = [aDecoder decodeObjectOfClass:[GDTCORClock class] forKey:kClockSnapshotKey];
  131|      0|    _customBytes = [aDecoder decodeObjectOfClass:[NSData class] forKey:kCustomDataKey];
  132|      0|    _expirationDate = [aDecoder decodeObjectOfClass:[NSDate class] forKey:kExpirationDateKey];
  133|      0|    _serializedDataObjectBytes = [aDecoder decodeObjectOfClass:[NSData class]
  134|      0|                                                        forKey:kSerializedDataObjectBytes];
  135|      0|    if (!_serializedDataObjectBytes) {
  136|      0|      return nil;
  137|      0|    }
  138|      0|  }
  139|      0|  return self;
  140|      0|}
  141|       |
  142|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  143|      0|  [aCoder encodeObject:_eventID forKey:kEventIDKey];
  144|      0|  [aCoder encodeObject:_mappingID forKey:kMappingIDKey];
  145|      0|  [aCoder encodeInteger:_target forKey:kTargetKey];
  146|      0|  [aCoder encodeInteger:_qosTier forKey:kQoSTierKey];
  147|      0|  [aCoder encodeObject:_clockSnapshot forKey:kClockSnapshotKey];
  148|      0|  [aCoder encodeObject:_customBytes forKey:kCustomDataKey];
  149|      0|  [aCoder encodeObject:_expirationDate forKey:kExpirationDateKey];
  150|      0|  [aCoder encodeObject:self.serializedDataObjectBytes forKey:kSerializedDataObjectBytes];
  151|      0|}
  152|       |
  153|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORFlatFileStorage+Promises.m:
    1|       |/*
    2|       | * Copyright 2020 Google LLC
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORFlatFileStorage+Promises.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORUploadBatch.h"
   26|       |
   27|       |@implementation GDTCORFlatFileStorage (Promises)
   28|       |
   29|      4|- (FBLPromise<NSSet<NSNumber *> *> *)batchIDsForTarget:(GDTCORTarget)target {
   30|      4|  return [FBLPromise onQueue:self.storageQueue
   31|      4|        wrapObjectCompletion:^(FBLPromiseObjectCompletion _Nonnull handler) {
   32|      4|          [self batchIDsForTarget:target onComplete:handler];
   33|      4|        }];
   34|      4|}
   35|       |
   36|      0|- (FBLPromise<NSNull *> *)removeBatchWithID:(NSNumber *)batchID deleteEvents:(BOOL)deleteEvents {
   37|      0|  return [FBLPromise onQueue:self.storageQueue
   38|      0|              wrapCompletion:^(FBLPromiseCompletion _Nonnull handler) {
   39|      0|                [self removeBatchWithID:batchID deleteEvents:deleteEvents onComplete:handler];
   40|      0|              }];
   41|      0|}
   42|       |
   43|       |- (FBLPromise<NSNull *> *)removeBatchesWithIDs:(NSSet<NSNumber *> *)batchIDs
   44|      0|                                  deleteEvents:(BOOL)deleteEvents {
   45|      0|  NSMutableArray<FBLPromise *> *removeBatchPromises =
   46|      0|      [NSMutableArray arrayWithCapacity:batchIDs.count];
   47|      0|  for (NSNumber *batchID in batchIDs) {
   48|      0|    [removeBatchPromises addObject:[self removeBatchWithID:batchID deleteEvents:deleteEvents]];
   49|      0|  }
   50|       |
   51|      0|  return [FBLPromise onQueue:self.storageQueue all:[removeBatchPromises copy]].thenOn(
   52|      0|      self.storageQueue, ^id(id result) {
   53|      0|        return [FBLPromise resolvedWith:[NSNull null]];
   54|      0|      });
   55|      0|}
   56|       |
   57|       |- (FBLPromise<NSNull *> *)removeAllBatchesForTarget:(GDTCORTarget)target
   58|      4|                                       deleteEvents:(BOOL)deleteEvents {
   59|      4|  return
   60|      4|      [self batchIDsForTarget:target].thenOn(self.storageQueue, ^id(NSSet<NSNumber *> *batchIDs) {
   61|      4|        if (batchIDs.count == 0) {
   62|      4|          return [FBLPromise resolvedWith:[NSNull null]];
   63|      0|        } else {
   64|      0|          return [self removeBatchesWithIDs:batchIDs deleteEvents:NO];
   65|      0|        }
   66|      4|      });
   67|      4|}
   68|       |
   69|      4|- (FBLPromise<NSNumber *> *)hasEventsForTarget:(GDTCORTarget)target {
   70|      4|  return [FBLPromise onQueue:self.storageQueue
   71|      4|          wrapBoolCompletion:^(FBLPromiseBoolCompletion _Nonnull handler) {
   72|      4|            [self hasEventsForTarget:target onComplete:handler];
   73|      4|          }];
   74|      4|}
   75|       |
   76|       |- (FBLPromise<GDTCORUploadBatch *> *)batchWithEventSelector:
   77|       |                                         (GDTCORStorageEventSelector *)eventSelector
   78|      0|                                            batchExpiration:(NSDate *)expiration {
   79|      0|  return [FBLPromise
   80|      0|      onQueue:self.storageQueue
   81|      0|        async:^(FBLPromiseFulfillBlock _Nonnull fulfill, FBLPromiseRejectBlock _Nonnull reject) {
   82|      0|          [self batchWithEventSelector:eventSelector
   83|      0|                       batchExpiration:expiration
   84|      0|                            onComplete:^(NSNumber *_Nullable newBatchID,
   85|      0|                                         NSSet<GDTCOREvent *> *_Nullable batchEvents) {
   86|      0|                              if (newBatchID == nil || batchEvents == nil) {
   87|      0|                                reject([self genericRejectedPromiseErrorWithReason:
   88|      0|                                                 @"There are no events for the selector."]);
   89|      0|                              } else {
   90|      0|                                fulfill([[GDTCORUploadBatch alloc] initWithBatchID:newBatchID
   91|      0|                                                                            events:batchEvents]);
   92|      0|                              }
   93|      0|                            }];
   94|      0|        }];
   95|      0|}
   96|       |
   97|       |// TODO: Move to a separate class/extension when needed in more places.
   98|      0|- (NSError *)genericRejectedPromiseErrorWithReason:(NSString *)reason {
   99|      0|  return [NSError errorWithDomain:@"GDTCORFlatFileStorage"
  100|      0|                             code:-1
  101|      0|                         userInfo:@{NSLocalizedFailureReasonErrorKey : reason}];
  102|      0|}
  103|       |
  104|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORFlatFileStorage.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORFlatFileStorage.h"
   18|       |
   19|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORAssert.h"
   20|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORLifecycle.h"
   21|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORPlatform.h"
   22|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORStorageEventSelector.h"
   23|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORConsoleLogger.h"
   24|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCOREvent.h"
   25|       |
   26|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCOREvent_Private.h"
   27|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORRegistrar_Private.h"
   28|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORUploadCoordinator.h"
   29|       |
   30|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORDirectorySizeTracker.h"
   31|       |
   32|       |NS_ASSUME_NONNULL_BEGIN
   33|       |
   34|       |/** A library data key this class uses to track batchIDs. */
   35|       |static NSString *const gBatchIDCounterKey = @"GDTCORFlatFileStorageBatchIDCounter";
   36|       |
   37|       |/** The separator used between metadata elements in filenames. */
   38|       |static NSString *const kMetadataSeparator = @"-";
   39|       |
   40|       |NSString *const kGDTCOREventComponentsEventIDKey = @"GDTCOREventComponentsEventIDKey";
   41|       |
   42|       |NSString *const kGDTCOREventComponentsQoSTierKey = @"GDTCOREventComponentsQoSTierKey";
   43|       |
   44|       |NSString *const kGDTCOREventComponentsMappingIDKey = @"GDTCOREventComponentsMappingIDKey";
   45|       |
   46|       |NSString *const kGDTCOREventComponentsExpirationKey = @"GDTCOREventComponentsExpirationKey";
   47|       |
   48|       |NSString *const kGDTCORBatchComponentsTargetKey = @"GDTCORBatchComponentsTargetKey";
   49|       |
   50|       |NSString *const kGDTCORBatchComponentsBatchIDKey = @"GDTCORBatchComponentsBatchIDKey";
   51|       |
   52|       |NSString *const kGDTCORBatchComponentsExpirationKey = @"GDTCORBatchComponentsExpirationKey";
   53|       |
   54|       |NSString *const GDTCORFlatFileStorageErrorDomain = @"GDTCORFlatFileStorage";
   55|       |
   56|       |const uint64_t kGDTCORFlatFileStorageSizeLimit = 20 * 1000 * 1000;  // 20 MB.
   57|       |
   58|       |@interface GDTCORFlatFileStorage ()
   59|       |
   60|       |/** An instance of the size tracker to keep track of the disk space consumed by the storage. */
   61|       |@property(nonatomic, readonly) GDTCORDirectorySizeTracker *sizeTracker;
   62|       |
   63|       |@end
   64|       |
   65|       |@implementation GDTCORFlatFileStorage
   66|       |
   67|       |@synthesize sizeTracker = _sizeTracker;
   68|       |
   69|      1|+ (void)load {
   70|      1|#if !NDEBUG
   71|      1|  [[GDTCORRegistrar sharedInstance] registerStorage:[self sharedInstance] target:kGDTCORTargetTest];
   72|      1|#endif  // !NDEBUG
   73|      1|  [[GDTCORRegistrar sharedInstance] registerStorage:[self sharedInstance] target:kGDTCORTargetCCT];
   74|      1|  [[GDTCORRegistrar sharedInstance] registerStorage:[self sharedInstance] target:kGDTCORTargetFLL];
   75|      1|  [[GDTCORRegistrar sharedInstance] registerStorage:[self sharedInstance] target:kGDTCORTargetCSH];
   76|      1|  [[GDTCORRegistrar sharedInstance] registerStorage:[self sharedInstance] target:kGDTCORTargetINT];
   77|      1|}
   78|       |
   79|      5|+ (instancetype)sharedInstance {
   80|      5|  static GDTCORFlatFileStorage *sharedStorage;
   81|      5|  static dispatch_once_t onceToken;
   82|      1|  dispatch_once(&onceToken, ^{
   83|      1|    sharedStorage = [[GDTCORFlatFileStorage alloc] init];
   84|      1|  });
   85|      5|  return sharedStorage;
   86|      5|}
   87|       |
   88|      1|- (instancetype)init {
   89|      1|  self = [super init];
   90|      1|  if (self) {
   91|      1|    _storageQueue =
   92|      1|        dispatch_queue_create("com.google.GDTCORFlatFileStorage", DISPATCH_QUEUE_SERIAL);
   93|      1|    _uploadCoordinator = [GDTCORUploadCoordinator sharedInstance];
   94|      1|  }
   95|      1|  return self;
   96|      1|}
   97|       |
   98|      1|- (GDTCORDirectorySizeTracker *)sizeTracker {
   99|      1|  if (_sizeTracker == nil) {
  100|      1|    _sizeTracker =
  101|      1|        [[GDTCORDirectorySizeTracker alloc] initWithDirectoryPath:GDTCORRootDirectory().path];
  102|      1|  }
  103|      1|  return _sizeTracker;
  104|      1|}
  105|       |
  106|       |#pragma mark - GDTCORStorageProtocol
  107|       |
  108|       |- (void)storeEvent:(GDTCOREvent *)event
  109|      0|        onComplete:(void (^_Nullable)(BOOL wasWritten, NSError *_Nullable error))completion {
  110|      0|  GDTCORLogDebug(@"Saving event: %@", event);
  111|      0|  if (event == nil || event.serializedDataObjectBytes == nil) {
  112|      0|    GDTCORLogDebug(@"%@", @"The event was nil, so it was not saved.");
  113|      0|    if (completion) {
  114|      0|      completion(NO, [NSError errorWithDomain:NSInternalInconsistencyException
  115|      0|                                         code:-1
  116|      0|                                     userInfo:nil]);
  117|      0|    }
  118|      0|    return;
  119|      0|  }
  120|      0|  if (!completion) {
  121|      0|    completion = ^(BOOL wasWritten, NSError *_Nullable error) {
  122|      0|      GDTCORLogDebug(@"event %@ stored. success:%@ error:%@", event, wasWritten ? @"YES" : @"NO",
  123|      0|                     error);
  124|      0|    };
  125|      0|  }
  126|       |
  127|      0|  __block GDTCORBackgroundIdentifier bgID = GDTCORBackgroundIdentifierInvalid;
  128|      0|  bgID = [[GDTCORApplication sharedApplication]
  129|      0|      beginBackgroundTaskWithName:@"GDTStorage"
  130|      0|                expirationHandler:^{
  131|       |                  // End the background task if it's still valid.
  132|      0|                  [[GDTCORApplication sharedApplication] endBackgroundTask:bgID];
  133|      0|                  bgID = GDTCORBackgroundIdentifierInvalid;
  134|      0|                }];
  135|       |
  136|      0|  dispatch_async(_storageQueue, ^{
  137|       |    // Check that a backend implementation is available for this target.
  138|      0|    GDTCORTarget target = event.target;
  139|      0|    NSString *filePath = [GDTCORFlatFileStorage pathForTarget:target
  140|      0|                                                      eventID:event.eventID
  141|      0|                                                      qosTier:@(event.qosTier)
  142|      0|                                               expirationDate:event.expirationDate
  143|      0|                                                    mappingID:event.mappingID];
  144|      0|    NSError *error;
  145|      0|    NSData *encodedEvent = GDTCOREncodeArchive(event, nil, &error);
  146|      0|    if (error) {
  147|      0|      completion(NO, error);
  148|      0|      return;
  149|      0|    }
  150|       |
  151|       |    // Check storage size limit before storing the event.
  152|      0|    uint64_t resultingStorageSize = self.sizeTracker.directoryContentSize + encodedEvent.length;
  153|      0|    if (resultingStorageSize > kGDTCORFlatFileStorageSizeLimit) {
  154|      0|      NSError *error = [NSError
  155|      0|          errorWithDomain:GDTCORFlatFileStorageErrorDomain
  156|      0|                     code:GDTCORFlatFileStorageErrorSizeLimitReached
  157|      0|                 userInfo:@{
  158|      0|                   NSLocalizedFailureReasonErrorKey : @"Storage size limit has been reached."
  159|      0|                 }];
  160|      0|      completion(NO, error);
  161|      0|      return;
  162|      0|    }
  163|       |
  164|       |    // Write the encoded event to the file.
  165|      0|    BOOL writeResult = GDTCORWriteDataToFile(encodedEvent, filePath, &error);
  166|      0|    if (writeResult == NO || error) {
  167|      0|      GDTCORLogDebug(@"Attempt to write archive failed: path:%@ error:%@", filePath, error);
  168|      0|      completion(NO, error);
  169|      0|      return;
  170|      0|    } else {
  171|      0|      GDTCORLogDebug(@"Writing archive succeeded: %@", filePath);
  172|      0|      completion(YES, nil);
  173|      0|    }
  174|       |
  175|       |    // Notify size tracker.
  176|      0|    [self.sizeTracker fileWasAddedAtPath:filePath withSize:encodedEvent.length];
  177|       |
  178|       |    // Check the QoS, if it's high priority, notify the target that it has a high priority event.
  179|      0|    if (event.qosTier == GDTCOREventQoSFast) {
  180|       |      // TODO: Remove a direct dependency on the upload coordinator.
  181|      0|      [self.uploadCoordinator forceUploadForTarget:target];
  182|      0|    }
  183|       |
  184|       |    // Cancel or end the associated background task if it's still valid.
  185|      0|    [[GDTCORApplication sharedApplication] endBackgroundTask:bgID];
  186|      0|    bgID = GDTCORBackgroundIdentifierInvalid;
  187|      0|  });
  188|      0|}
  189|       |
  190|       |- (void)batchWithEventSelector:(nonnull GDTCORStorageEventSelector *)eventSelector
  191|       |               batchExpiration:(nonnull NSDate *)expiration
  192|       |                    onComplete:
  193|       |                        (nonnull void (^)(NSNumber *_Nullable batchID,
  194|      0|                                          NSSet<GDTCOREvent *> *_Nullable events))onComplete {
  195|      0|  dispatch_queue_t queue = _storageQueue;
  196|      0|  void (^onPathsForTargetComplete)(NSNumber *, NSSet<NSString *> *_Nonnull) = ^(
  197|      0|      NSNumber *batchID, NSSet<NSString *> *_Nonnull paths) {
  198|      0|    dispatch_async(queue, ^{
  199|      0|      NSMutableSet<GDTCOREvent *> *events = [[NSMutableSet alloc] init];
  200|      0|      for (NSString *eventPath in paths) {
  201|      0|        NSError *error;
  202|      0|        GDTCOREvent *event =
  203|      0|            (GDTCOREvent *)GDTCORDecodeArchive([GDTCOREvent class], eventPath, nil, &error);
  204|      0|        if (event == nil || error) {
  205|      0|          GDTCORLogDebug(@"Error deserializing event: %@", error);
  206|      0|          [[NSFileManager defaultManager] removeItemAtPath:eventPath error:nil];
  207|      0|          continue;
  208|      0|        } else {
  209|      0|          NSString *fileName = [eventPath lastPathComponent];
  210|      0|          NSString *batchPath =
  211|      0|              [GDTCORFlatFileStorage batchPathForTarget:eventSelector.selectedTarget
  212|      0|                                                batchID:batchID
  213|      0|                                         expirationDate:expiration];
  214|      0|          [[NSFileManager defaultManager] createDirectoryAtPath:batchPath
  215|      0|                                    withIntermediateDirectories:YES
  216|      0|                                                     attributes:nil
  217|      0|                                                          error:nil];
  218|      0|          NSString *destinationPath = [batchPath stringByAppendingPathComponent:fileName];
  219|      0|          error = nil;
  220|      0|          [[NSFileManager defaultManager] moveItemAtPath:eventPath
  221|      0|                                                  toPath:destinationPath
  222|      0|                                                   error:&error];
  223|      0|          if (error) {
  224|      0|            GDTCORLogDebug(@"An event file wasn't moveable into the batch directory: %@", error);
  225|      0|          }
  226|      0|          [events addObject:event];
  227|      0|        }
  228|      0|      }
  229|      0|      if (onComplete) {
  230|      0|        if (events.count == 0) {
  231|      0|          onComplete(nil, nil);
  232|      0|        } else {
  233|      0|          onComplete(batchID, events);
  234|      0|        }
  235|      0|      }
  236|      0|    });
  237|      0|  };
  238|       |
  239|      0|  void (^onBatchIDFetchComplete)(NSNumber *) = ^(NSNumber *batchID) {
  240|      0|    dispatch_async(queue, ^{
  241|      0|      if (batchID == nil) {
  242|      0|        if (onComplete) {
  243|      0|          onComplete(nil, nil);
  244|      0|          return;
  245|      0|        }
  246|      0|      }
  247|      0|      [self pathsForTarget:eventSelector.selectedTarget
  248|      0|                  eventIDs:eventSelector.selectedEventIDs
  249|      0|                  qosTiers:eventSelector.selectedQosTiers
  250|      0|                mappingIDs:eventSelector.selectedMappingIDs
  251|      0|                onComplete:^(NSSet<NSString *> *_Nonnull paths) {
  252|      0|                  onPathsForTargetComplete(batchID, paths);
  253|      0|                }];
  254|      0|    });
  255|      0|  };
  256|       |
  257|      0|  [self nextBatchID:^(NSNumber *_Nullable batchID) {
  258|      0|    if (batchID == nil) {
  259|      0|      if (onComplete) {
  260|      0|        onComplete(nil, nil);
  261|      0|      }
  262|      0|    } else {
  263|      0|      onBatchIDFetchComplete(batchID);
  264|      0|    }
  265|      0|  }];
  266|      0|}
  267|       |
  268|       |- (void)removeBatchWithID:(nonnull NSNumber *)batchID
  269|       |             deleteEvents:(BOOL)deleteEvents
  270|      0|               onComplete:(void (^_Nullable)(void))onComplete {
  271|      0|  dispatch_async(_storageQueue, ^{
  272|      0|    [self syncThreadUnsafeRemoveBatchWithID:batchID deleteEvents:deleteEvents];
  273|       |
  274|      0|    if (onComplete) {
  275|      0|      onComplete();
  276|      0|    }
  277|      0|  });
  278|      0|}
  279|       |
  280|       |- (void)batchIDsForTarget:(GDTCORTarget)target
  281|      4|               onComplete:(nonnull void (^)(NSSet<NSNumber *> *_Nullable))onComplete {
  282|      4|  dispatch_async(_storageQueue, ^{
  283|      4|    NSFileManager *fileManager = [NSFileManager defaultManager];
  284|      4|    NSError *error;
  285|      4|    NSArray<NSString *> *batchPaths =
  286|      4|        [fileManager contentsOfDirectoryAtPath:[GDTCORFlatFileStorage batchDataStoragePath]
  287|      4|                                         error:&error];
  288|      4|    if (error || batchPaths.count == 0) {
  289|      4|      if (onComplete) {
  290|      4|        onComplete(nil);
  291|      4|      }
  292|      4|      return;
  293|      4|    }
  294|      0|    NSMutableSet<NSNumber *> *batchIDs = [[NSMutableSet alloc] init];
  295|      0|    for (NSString *path in batchPaths) {
  296|      0|      NSDictionary<NSString *, id> *components = [self batchComponentsFromFilename:path];
  297|      0|      NSNumber *targetNumber = components[kGDTCORBatchComponentsTargetKey];
  298|      0|      NSNumber *batchID = components[kGDTCORBatchComponentsBatchIDKey];
  299|      0|      if (batchID != nil && targetNumber.intValue == target) {
  300|      0|        [batchIDs addObject:batchID];
  301|      0|      }
  302|      0|    }
  303|      0|    if (onComplete) {
  304|      0|      onComplete(batchIDs);
  305|      0|    }
  306|      0|  });
  307|      4|}
  308|       |
  309|       |- (void)libraryDataForKey:(nonnull NSString *)key
  310|       |          onFetchComplete:(nonnull void (^)(NSData *_Nullable, NSError *_Nullable))onFetchComplete
  311|      0|              setNewValue:(NSData *_Nullable (^_Nullable)(void))setValueBlock {
  312|      0|  dispatch_async(_storageQueue, ^{
  313|      0|    NSString *dataPath = [[[self class] libraryDataStoragePath] stringByAppendingPathComponent:key];
  314|      0|    NSError *error;
  315|      0|    NSData *data = [NSData dataWithContentsOfFile:dataPath options:0 error:&error];
  316|      0|    if (onFetchComplete) {
  317|      0|      onFetchComplete(data, error);
  318|      0|    }
  319|      0|    if (setValueBlock) {
  320|      0|      NSData *newValue = setValueBlock();
  321|       |      // The -isKindOfClass check is necessary because without an explicit 'return nil' in the block
  322|       |      // the implicit return value will be the block itself. The compiler doesn't detect this.
  323|      0|      if (newValue != nil && [newValue isKindOfClass:[NSData class]] && newValue.length) {
  324|      0|        NSError *newValueError;
  325|      0|        if ([newValue writeToFile:dataPath options:NSDataWritingAtomic error:&newValueError]) {
  326|       |          // Update storage size.
  327|      0|          [self.sizeTracker fileWasRemovedAtPath:dataPath withSize:data.length];
  328|      0|          [self.sizeTracker fileWasAddedAtPath:dataPath withSize:newValue.length];
  329|      0|        } else {
  330|      0|          GDTCORLogDebug(@"Error writing new value in libraryDataForKey: %@", newValueError);
  331|      0|        }
  332|      0|      }
  333|      0|    }
  334|      0|  });
  335|      0|}
  336|       |
  337|       |- (void)storeLibraryData:(NSData *)data
  338|       |                  forKey:(nonnull NSString *)key
  339|      0|              onComplete:(nullable void (^)(NSError *_Nullable error))onComplete {
  340|      0|  if (!data || data.length <= 0) {
  341|      0|    if (onComplete) {
  342|      0|      onComplete([NSError errorWithDomain:NSInternalInconsistencyException code:-1 userInfo:nil]);
  343|      0|    }
  344|      0|    return;
  345|      0|  }
  346|      0|  dispatch_async(_storageQueue, ^{
  347|      0|    NSError *error;
  348|      0|    NSString *dataPath = [[[self class] libraryDataStoragePath] stringByAppendingPathComponent:key];
  349|      0|    if ([data writeToFile:dataPath options:NSDataWritingAtomic error:&error]) {
  350|      0|      [self.sizeTracker fileWasAddedAtPath:dataPath withSize:data.length];
  351|      0|    }
  352|      0|    if (onComplete) {
  353|      0|      onComplete(error);
  354|      0|    }
  355|      0|  });
  356|      0|}
  357|       |
  358|       |- (void)removeLibraryDataForKey:(nonnull NSString *)key
  359|      0|                     onComplete:(nonnull void (^)(NSError *_Nullable error))onComplete {
  360|      0|  dispatch_async(_storageQueue, ^{
  361|      0|    NSError *error;
  362|      0|    NSString *dataPath = [[[self class] libraryDataStoragePath] stringByAppendingPathComponent:key];
  363|      0|    GDTCORStorageSizeBytes fileSize =
  364|      0|        [self.sizeTracker fileSizeAtURL:[NSURL fileURLWithPath:dataPath]];
  365|       |
  366|      0|    if ([[NSFileManager defaultManager] fileExistsAtPath:dataPath]) {
  367|      0|      if ([[NSFileManager defaultManager] removeItemAtPath:dataPath error:&error]) {
  368|      0|        [self.sizeTracker fileWasRemovedAtPath:dataPath withSize:fileSize];
  369|      0|      }
  370|      0|      if (onComplete) {
  371|      0|        onComplete(error);
  372|      0|      }
  373|      0|    }
  374|      0|  });
  375|      0|}
  376|       |
  377|      4|- (void)hasEventsForTarget:(GDTCORTarget)target onComplete:(void (^)(BOOL hasEvents))onComplete {
  378|      4|  dispatch_async(_storageQueue, ^{
  379|      4|    NSFileManager *fileManager = [NSFileManager defaultManager];
  380|      4|    NSString *targetPath = [NSString
  381|      4|        stringWithFormat:@"%@/%ld", [GDTCORFlatFileStorage eventDataStoragePath], (long)target];
  382|      4|    [fileManager createDirectoryAtPath:targetPath
  383|      4|           withIntermediateDirectories:YES
  384|      4|                            attributes:nil
  385|      4|                                 error:nil];
  386|      4|    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:targetPath];
  387|      4|    BOOL hasEventAtLeastOneEvent = [enumerator nextObject] != nil;
  388|      4|    if (onComplete) {
  389|      4|      onComplete(hasEventAtLeastOneEvent);
  390|      4|    }
  391|      4|  });
  392|      4|}
  393|       |
  394|      1|- (void)checkForExpirations {
  395|      1|  dispatch_async(_storageQueue, ^{
  396|      1|    GDTCORLogDebug(@"%@", @"Checking for expired events and batches");
  397|      1|    NSTimeInterval now = [NSDate date].timeIntervalSince1970;
  398|      1|    NSFileManager *fileManager = [NSFileManager defaultManager];
  399|       |
  400|       |    // TODO: Storage may not have enough context to remove batches because a batch may be being
  401|       |    // uploaded but the storage has not context of it.
  402|       |
  403|       |    // Find expired batches and move their events back to the main storage.
  404|       |    // If a batch contains expired events they are expected to be removed further in the method
  405|       |    // together with other expired events in the main storage.
  406|      1|    NSString *batchDataPath = [GDTCORFlatFileStorage batchDataStoragePath];
  407|      1|    NSArray<NSString *> *batchDataPaths = [fileManager contentsOfDirectoryAtPath:batchDataPath
  408|      1|                                                                           error:nil];
  409|      0|    for (NSString *path in batchDataPaths) {
  410|      0|      @autoreleasepool {
  411|      0|        NSString *fileName = [path lastPathComponent];
  412|      0|        NSDictionary<NSString *, id> *batchComponents = [self batchComponentsFromFilename:fileName];
  413|      0|        NSDate *expirationDate = batchComponents[kGDTCORBatchComponentsExpirationKey];
  414|      0|        NSNumber *batchID = batchComponents[kGDTCORBatchComponentsBatchIDKey];
  415|      0|        if (expirationDate != nil && expirationDate.timeIntervalSince1970 < now && batchID != nil) {
  416|      0|          NSNumber *batchID = batchComponents[kGDTCORBatchComponentsBatchIDKey];
  417|       |          // Move all events from the expired batch back to the main storage.
  418|      0|          [self syncThreadUnsafeRemoveBatchWithID:batchID deleteEvents:NO];
  419|      0|        }
  420|      0|      }
  421|      0|    }
  422|       |
  423|       |    // Find expired events and remove them from the storage.
  424|      1|    NSString *eventDataPath = [GDTCORFlatFileStorage eventDataStoragePath];
  425|      1|    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:eventDataPath];
  426|      1|    NSString *path;
  427|       |
  428|      5|    while (YES) {
  429|      5|      @autoreleasepool {
  430|       |        // Call `[enumerator nextObject]` under autorelease pool to make sure all autoreleased
  431|       |        // objects created under the hood are released on each iteration end to avoid unnecessary
  432|       |        // memory growth.
  433|      5|        path = [enumerator nextObject];
  434|      5|        if (path == nil) {
  435|      1|          break;
  436|      1|        }
  437|       |
  438|      4|        NSString *fileName = [path lastPathComponent];
  439|      4|        NSDictionary<NSString *, id> *eventComponents = [self eventComponentsFromFilename:fileName];
  440|      4|        NSDate *expirationDate = eventComponents[kGDTCOREventComponentsExpirationKey];
  441|      4|        if (expirationDate != nil && expirationDate.timeIntervalSince1970 < now) {
  442|      0|          NSString *pathToDelete = [eventDataPath stringByAppendingPathComponent:path];
  443|      0|          NSError *error;
  444|      0|          [fileManager removeItemAtPath:pathToDelete error:&error];
  445|      0|          if (error != nil) {
  446|      0|            GDTCORLogDebug(@"There was an error deleting an expired item: %@", error);
  447|      0|          } else {
  448|      0|            GDTCORLogDebug(@"Item deleted because it expired: %@", pathToDelete);
  449|      0|          }
  450|      0|        }
  451|      4|      }
  452|      4|    }
  453|       |
  454|      1|    [self.sizeTracker resetCachedSize];
  455|      1|  });
  456|      1|}
  457|       |
  458|      0|- (void)storageSizeWithCallback:(void (^)(uint64_t storageSize))onComplete {
  459|      0|  if (!onComplete) {
  460|      0|    return;
  461|      0|  }
  462|       |
  463|      0|  dispatch_async(_storageQueue, ^{
  464|      0|    onComplete([self.sizeTracker directoryContentSize]);
  465|      0|  });
  466|      0|}
  467|       |
  468|       |#pragma mark - Private not thread safe methods
  469|       |/** Looks for directory paths containing events for a batch with the specified ID.
  470|       | * @param batchID A batch ID.
  471|       | * @param outError A pointer to `NSError *` to assign as possible error to.
  472|       | * @return An array of an array of paths to directories for event batches with a specified batch ID
  473|       | * or `nil` in the case of an error. Usually returns a single path but potentially return more in
  474|       | * cases when the app is terminated while uploading a batch.
  475|       | */
  476|       |- (nullable NSArray<NSString *> *)batchDirPathsForBatchID:(NSNumber *)batchID
  477|      0|                                                    error:(NSError **_Nonnull)outError {
  478|      0|  NSFileManager *fileManager = [NSFileManager defaultManager];
  479|      0|  NSError *error;
  480|      0|  NSArray<NSString *> *batches =
  481|      0|      [fileManager contentsOfDirectoryAtPath:[GDTCORFlatFileStorage batchDataStoragePath]
  482|      0|                                       error:&error];
  483|      0|  if (batches == nil) {
  484|      0|    *outError = error;
  485|      0|    GDTCORLogDebug(@"Failed to find event file paths for batchID: %@, error: %@", batchID, error);
  486|      0|    return nil;
  487|      0|  }
  488|       |
  489|      0|  NSMutableArray<NSString *> *batchDirPaths = [NSMutableArray array];
  490|      0|  for (NSString *path in batches) {
  491|      0|    NSDictionary<NSString *, id> *components = [self batchComponentsFromFilename:path];
  492|      0|    NSNumber *pathBatchID = components[kGDTCORBatchComponentsBatchIDKey];
  493|      0|    if ([pathBatchID isEqual:batchID]) {
  494|      0|      NSString *batchDirPath =
  495|      0|          [[GDTCORFlatFileStorage batchDataStoragePath] stringByAppendingPathComponent:path];
  496|      0|      [batchDirPaths addObject:batchDirPath];
  497|      0|    }
  498|      0|  }
  499|       |
  500|      0|  return [batchDirPaths copy];
  501|      0|}
  502|       |
  503|       |/** Makes a copy of the contents of a directory to a directory at the specified path.*/
  504|       |- (BOOL)moveContentsOfDirectoryAtPath:(NSString *)sourcePath
  505|       |                                   to:(NSString *)destinationPath
  506|      0|                                error:(NSError **_Nonnull)outError {
  507|      0|  NSFileManager *fileManager = [NSFileManager defaultManager];
  508|       |
  509|      0|  NSError *error;
  510|      0|  NSArray<NSString *> *contentsPaths = [fileManager contentsOfDirectoryAtPath:sourcePath
  511|      0|                                                                        error:&error];
  512|      0|  if (contentsPaths == nil) {
  513|      0|    *outError = error;
  514|      0|    return NO;
  515|      0|  }
  516|       |
  517|      0|  NSMutableArray<NSError *> *errors = [NSMutableArray array];
  518|      0|  for (NSString *path in contentsPaths) {
  519|      0|    NSString *contentDestinationPath = [destinationPath stringByAppendingPathComponent:path];
  520|      0|    NSString *contentSourcePath = [sourcePath stringByAppendingPathComponent:path];
  521|       |
  522|      0|    NSError *moveError;
  523|      0|    if (![fileManager moveItemAtPath:contentSourcePath
  524|      0|                              toPath:contentDestinationPath
  525|      0|                               error:&moveError] &&
  526|      0|        moveError) {
  527|      0|      [errors addObject:moveError];
  528|      0|    }
  529|      0|  }
  530|       |
  531|      0|  if (errors.count == 0) {
  532|      0|    return YES;
  533|      0|  } else {
  534|      0|    NSError *combinedError = [NSError errorWithDomain:@"GDTCORFlatFileStorage"
  535|      0|                                                 code:-1
  536|      0|                                             userInfo:@{NSUnderlyingErrorKey : errors}];
  537|      0|    *outError = combinedError;
  538|      0|    return NO;
  539|      0|  }
  540|      0|}
  541|       |
  542|       |- (void)syncThreadUnsafeRemoveBatchWithID:(nonnull NSNumber *)batchID
  543|      0|                             deleteEvents:(BOOL)deleteEvents {
  544|      0|  NSError *error;
  545|      0|  NSArray<NSString *> *batchDirPaths = [self batchDirPathsForBatchID:batchID error:&error];
  546|       |
  547|      0|  if (batchDirPaths == nil) {
  548|      0|    return;
  549|      0|  }
  550|       |
  551|      0|  NSFileManager *fileManager = [NSFileManager defaultManager];
  552|       |
  553|      0|  void (^removeBatchDir)(NSString *batchDirPath) = ^(NSString *batchDirPath) {
  554|      0|    NSError *error;
  555|      0|    if ([fileManager removeItemAtPath:batchDirPath error:&error]) {
  556|      0|      GDTCORLogDebug(@"Batch removed at path: %@", batchDirPath);
  557|      0|    } else {
  558|      0|      GDTCORLogDebug(@"Failed to remove batch at path: %@", batchDirPath);
  559|      0|    }
  560|      0|  };
  561|       |
  562|      0|  for (NSString *batchDirPath in batchDirPaths) {
  563|      0|    @autoreleasepool {
  564|      0|      if (deleteEvents) {
  565|      0|        removeBatchDir(batchDirPath);
  566|      0|      } else {
  567|      0|        NSString *batchDirName = [batchDirPath lastPathComponent];
  568|      0|        NSDictionary<NSString *, id> *components = [self batchComponentsFromFilename:batchDirName];
  569|      0|        NSString *targetValue = [components[kGDTCORBatchComponentsTargetKey] stringValue];
  570|      0|        NSString *destinationPath;
  571|      0|        if (targetValue) {
  572|      0|          destinationPath = [[GDTCORFlatFileStorage eventDataStoragePath]
  573|      0|              stringByAppendingPathComponent:targetValue];
  574|      0|        }
  575|       |
  576|       |        // `- [NSFileManager moveItemAtPath:toPath:error:]` method fails if an item by the
  577|       |        // destination path already exists (which usually is the case for the current method). Move
  578|       |        // the events one by one instead.
  579|      0|        if (destinationPath && [self moveContentsOfDirectoryAtPath:batchDirPath
  580|      0|                                                                to:destinationPath
  581|      0|                                                             error:&error]) {
  582|      0|          GDTCORLogDebug(@"Batched events at path: %@ moved back to the storage: %@", batchDirPath,
  583|      0|                         destinationPath);
  584|      0|        } else {
  585|      0|          GDTCORLogDebug(@"Error encountered whilst moving events back: %@", error);
  586|      0|        }
  587|       |
  588|       |        // Even if not all events where moved back to the storage, there is not much can be done at
  589|       |        // this point, so cleanup batch directory now to avoid cluttering.
  590|      0|        removeBatchDir(batchDirPath);
  591|      0|      }
  592|      0|    }
  593|      0|  }
  594|       |
  595|      0|  [self.sizeTracker resetCachedSize];
  596|      0|}
  597|       |
  598|       |#pragma mark - Private helper methods
  599|       |
  600|      5|+ (NSString *)eventDataStoragePath {
  601|      5|  static NSString *eventDataPath;
  602|      5|  static dispatch_once_t onceToken;
  603|      1|  dispatch_once(&onceToken, ^{
  604|      1|    eventDataPath = [NSString stringWithFormat:@"%@/%@/gdt_event_data", GDTCORRootDirectory().path,
  605|      1|                                               NSStringFromClass([self class])];
  606|      1|  });
  607|      5|  NSError *error;
  608|      5|  [[NSFileManager defaultManager] createDirectoryAtPath:eventDataPath
  609|      5|                            withIntermediateDirectories:YES
  610|      5|                                             attributes:0
  611|      5|                                                  error:&error];
  612|      5|  GDTCORAssert(error == nil, @"Creating the library data path failed: %@", error);
  613|      5|  return eventDataPath;
  614|      5|}
  615|       |
  616|      5|+ (NSString *)batchDataStoragePath {
  617|      5|  static NSString *batchDataPath;
  618|      5|  static dispatch_once_t onceToken;
  619|      1|  dispatch_once(&onceToken, ^{
  620|      1|    batchDataPath = [NSString stringWithFormat:@"%@/%@/gdt_batch_data", GDTCORRootDirectory().path,
  621|      1|                                               NSStringFromClass([self class])];
  622|      1|  });
  623|      5|  NSError *error;
  624|      5|  [[NSFileManager defaultManager] createDirectoryAtPath:batchDataPath
  625|      5|                            withIntermediateDirectories:YES
  626|      5|                                             attributes:0
  627|      5|                                                  error:&error];
  628|      5|  GDTCORAssert(error == nil, @"Creating the batch data path failed: %@", error);
  629|      5|  return batchDataPath;
  630|      5|}
  631|       |
  632|      0|+ (NSString *)libraryDataStoragePath {
  633|      0|  static NSString *libraryDataPath;
  634|      0|  static dispatch_once_t onceToken;
  635|      0|  dispatch_once(&onceToken, ^{
  636|      0|    libraryDataPath =
  637|      0|        [NSString stringWithFormat:@"%@/%@/gdt_library_data", GDTCORRootDirectory().path,
  638|      0|                                   NSStringFromClass([self class])];
  639|      0|  });
  640|      0|  NSError *error;
  641|      0|  [[NSFileManager defaultManager] createDirectoryAtPath:libraryDataPath
  642|      0|                            withIntermediateDirectories:YES
  643|      0|                                             attributes:0
  644|      0|                                                  error:&error];
  645|      0|  GDTCORAssert(error == nil, @"Creating the library data path failed: %@", error);
  646|      0|  return libraryDataPath;
  647|      0|}
  648|       |
  649|       |+ (NSString *)batchPathForTarget:(GDTCORTarget)target
  650|       |                         batchID:(NSNumber *)batchID
  651|      0|                  expirationDate:(NSDate *)expirationDate {
  652|      0|  return
  653|      0|      [NSString stringWithFormat:@"%@/%ld%@%@%@%llu", [GDTCORFlatFileStorage batchDataStoragePath],
  654|      0|                                 (long)target, kMetadataSeparator, batchID, kMetadataSeparator,
  655|      0|                                 ((uint64_t)expirationDate.timeIntervalSince1970)];
  656|      0|}
  657|       |
  658|       |+ (NSString *)pathForTarget:(GDTCORTarget)target
  659|       |                    eventID:(NSString *)eventID
  660|       |                    qosTier:(NSNumber *)qosTier
  661|       |             expirationDate:(NSDate *)expirationDate
  662|      0|                  mappingID:(NSString *)mappingID {
  663|      0|  NSMutableCharacterSet *allowedChars = [[NSCharacterSet alphanumericCharacterSet] mutableCopy];
  664|      0|  [allowedChars addCharactersInString:kMetadataSeparator];
  665|      0|  mappingID = [mappingID stringByAddingPercentEncodingWithAllowedCharacters:allowedChars];
  666|      0|  return [NSString stringWithFormat:@"%@/%ld/%@%@%@%@%llu%@%@",
  667|      0|                                    [GDTCORFlatFileStorage eventDataStoragePath], (long)target,
  668|      0|                                    eventID, kMetadataSeparator, qosTier, kMetadataSeparator,
  669|      0|                                    ((uint64_t)expirationDate.timeIntervalSince1970),
  670|      0|                                    kMetadataSeparator, mappingID];
  671|      0|}
  672|       |
  673|       |- (void)pathsForTarget:(GDTCORTarget)target
  674|       |              eventIDs:(nullable NSSet<NSString *> *)eventIDs
  675|       |              qosTiers:(nullable NSSet<NSNumber *> *)qosTiers
  676|       |            mappingIDs:(nullable NSSet<NSString *> *)mappingIDs
  677|      0|            onComplete:(void (^)(NSSet<NSString *> *paths))onComplete {
  678|      0|  void (^completion)(NSSet<NSString *> *) = onComplete == nil ? ^(NSSet<NSString *> *paths){} : onComplete;
  679|      0|  dispatch_async(_storageQueue, ^{
  680|      0|    NSMutableSet<NSString *> *paths = [[NSMutableSet alloc] init];
  681|      0|    NSFileManager *fileManager = [NSFileManager defaultManager];
  682|      0|    NSString *targetPath = [NSString
  683|      0|        stringWithFormat:@"%@/%ld", [GDTCORFlatFileStorage eventDataStoragePath], (long)target];
  684|      0|    [fileManager createDirectoryAtPath:targetPath
  685|      0|           withIntermediateDirectories:YES
  686|      0|                            attributes:nil
  687|      0|                                 error:nil];
  688|      0|    NSError *error;
  689|      0|    NSArray<NSString *> *dirPaths = [fileManager contentsOfDirectoryAtPath:targetPath error:&error];
  690|      0|    if (error) {
  691|      0|      GDTCORLogDebug(@"There was an error reading the contents of the target path: %@", error);
  692|      0|      completion(paths);
  693|      0|      return;
  694|      0|    }
  695|      0|    BOOL checkingIDs = eventIDs.count > 0;
  696|      0|    BOOL checkingQosTiers = qosTiers.count > 0;
  697|      0|    BOOL checkingMappingIDs = mappingIDs.count > 0;
  698|      0|    BOOL checkingAnything = checkingIDs == NO && checkingQosTiers == NO && checkingMappingIDs == NO;
  699|      0|    for (NSString *path in dirPaths) {
  700|       |      // Skip hidden files that are created as part of atomic file creation.
  701|      0|      if ([path hasPrefix:@"."]) {
  702|      0|        continue;
  703|      0|      }
  704|      0|      NSString *filePath = [targetPath stringByAppendingPathComponent:path];
  705|      0|      if (checkingAnything) {
  706|      0|        [paths addObject:filePath];
  707|      0|        continue;
  708|      0|      }
  709|      0|      NSString *filename = [path lastPathComponent];
  710|      0|      NSDictionary<NSString *, id> *eventComponents = [self eventComponentsFromFilename:filename];
  711|      0|      if (!eventComponents) {
  712|      0|        GDTCORLogDebug(@"There was an error reading the filename components: %@", eventComponents);
  713|      0|        continue;
  714|      0|      }
  715|      0|      NSString *eventID = eventComponents[kGDTCOREventComponentsEventIDKey];
  716|      0|      NSNumber *qosTier = eventComponents[kGDTCOREventComponentsQoSTierKey];
  717|      0|      NSString *mappingID = eventComponents[kGDTCOREventComponentsMappingIDKey];
  718|       |
  719|      0|      NSNumber *eventIDMatch = checkingIDs ? @([eventIDs containsObject:eventID]) : nil;
  720|      0|      NSNumber *qosTierMatch = checkingQosTiers ? @([qosTiers containsObject:qosTier]) : nil;
  721|      0|      NSNumber *mappingIDMatch =
  722|      0|          checkingMappingIDs
  723|      0|              ? @([mappingIDs containsObject:[mappingID stringByRemovingPercentEncoding]])
  724|      0|              : nil;
  725|      0|      if ((eventIDMatch == nil || eventIDMatch.boolValue) &&
  726|      0|          (qosTierMatch == nil || qosTierMatch.boolValue) &&
  727|      0|          (mappingIDMatch == nil || mappingIDMatch.boolValue)) {
  728|      0|        [paths addObject:filePath];
  729|      0|      }
  730|      0|    }
  731|      0|    completion(paths);
  732|      0|  });
  733|      0|}
  734|       |
  735|      0|- (void)nextBatchID:(void (^)(NSNumber *_Nullable batchID))nextBatchID {
  736|      0|  __block int32_t lastBatchID = -1;
  737|      0|  [self libraryDataForKey:gBatchIDCounterKey
  738|      0|      onFetchComplete:^(NSData *_Nullable data, NSError *_Nullable getValueError) {
  739|      0|        if (!getValueError) {
  740|      0|          [data getBytes:(void *)&lastBatchID length:sizeof(int32_t)];
  741|      0|        }
  742|      0|        if (data == nil) {
  743|      0|          lastBatchID = 0;
  744|      0|        }
  745|      0|        if (nextBatchID) {
  746|      0|          nextBatchID(@(lastBatchID));
  747|      0|        }
  748|      0|      }
  749|      0|      setNewValue:^NSData *_Nullable(void) {
  750|      0|        if (lastBatchID != -1) {
  751|      0|          int32_t incrementedValue = lastBatchID + 1;
  752|      0|          return [NSData dataWithBytes:&incrementedValue length:sizeof(int32_t)];
  753|      0|        }
  754|      0|        return nil;
  755|      0|      }];
  756|      0|}
  757|       |
  758|      4|- (nullable NSDictionary<NSString *, id> *)eventComponentsFromFilename:(NSString *)fileName {
  759|      4|  NSArray<NSString *> *components = [fileName componentsSeparatedByString:kMetadataSeparator];
  760|      4|  if (components.count >= 4) {
  761|      0|    NSString *eventID = components[0];
  762|      0|    NSNumber *qosTier = @(components[1].integerValue);
  763|      0|    NSDate *expirationDate = [NSDate dateWithTimeIntervalSince1970:components[2].longLongValue];
  764|      0|    NSString *mappingID = [[components subarrayWithRange:NSMakeRange(3, components.count - 3)]
  765|      0|        componentsJoinedByString:kMetadataSeparator];
  766|      0|    if (eventID == nil || qosTier == nil || mappingID == nil || expirationDate == nil) {
  767|      0|      GDTCORLogDebug(@"There was an error parsing the event filename components: %@", components);
  768|      0|      return nil;
  769|      0|    }
  770|      0|    return @{
  771|      0|      kGDTCOREventComponentsEventIDKey : eventID,
  772|      0|      kGDTCOREventComponentsQoSTierKey : qosTier,
  773|      0|      kGDTCOREventComponentsExpirationKey : expirationDate,
  774|      0|      kGDTCOREventComponentsMappingIDKey : mappingID
  775|      0|    };
  776|      0|  }
  777|      4|  GDTCORLogDebug(@"The event filename could not be split: %@", fileName);
  778|      4|  return nil;
  779|      4|}
  780|       |
  781|      0|- (nullable NSDictionary<NSString *, id> *)batchComponentsFromFilename:(NSString *)fileName {
  782|      0|  NSArray<NSString *> *components = [fileName componentsSeparatedByString:kMetadataSeparator];
  783|      0|  if (components.count == 3) {
  784|      0|    NSNumber *target = @(components[0].integerValue);
  785|      0|    NSNumber *batchID = @(components[1].integerValue);
  786|      0|    NSDate *expirationDate = [NSDate dateWithTimeIntervalSince1970:components[2].doubleValue];
  787|      0|    if (target == nil || batchID == nil || expirationDate == nil) {
  788|      0|      GDTCORLogDebug(@"There was an error parsing the batch filename components: %@", components);
  789|      0|      return nil;
  790|      0|    }
  791|      0|    return @{
  792|      0|      kGDTCORBatchComponentsTargetKey : target,
  793|      0|      kGDTCORBatchComponentsBatchIDKey : batchID,
  794|      0|      kGDTCORBatchComponentsExpirationKey : expirationDate
  795|      0|    };
  796|      0|  }
  797|      0|  GDTCORLogDebug(@"The batch filename could not be split: %@", fileName);
  798|      0|  return nil;
  799|      0|}
  800|       |
  801|       |#pragma mark - GDTCORLifecycleProtocol
  802|       |
  803|      0|- (void)appWillBackground:(GDTCORApplication *)app {
  804|      0|  dispatch_async(_storageQueue, ^{
  805|       |    // Immediately request a background task to run until the end of the current queue of work,
  806|       |    // and cancel it once the work is done.
  807|      0|    __block GDTCORBackgroundIdentifier bgID =
  808|      0|        [app beginBackgroundTaskWithName:@"GDTStorage"
  809|      0|                       expirationHandler:^{
  810|      0|                         [app endBackgroundTask:bgID];
  811|      0|                         bgID = GDTCORBackgroundIdentifierInvalid;
  812|      0|                       }];
  813|       |    // End the background task if it's still valid.
  814|      0|    [app endBackgroundTask:bgID];
  815|      0|    bgID = GDTCORBackgroundIdentifierInvalid;
  816|      0|  });
  817|      0|}
  818|       |
  819|      0|- (void)appWillTerminate:(GDTCORApplication *)application {
  820|      0|  dispatch_sync(_storageQueue, ^{
  821|      0|                });
  822|      0|}
  823|       |
  824|       |@end
  825|       |
  826|       |NS_ASSUME_NONNULL_END

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORLifecycle.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORLifecycle.h"
   18|       |
   19|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORConsoleLogger.h"
   20|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCOREvent.h"
   21|       |
   22|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORRegistrar_Private.h"
   23|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORTransformer_Private.h"
   24|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORUploadCoordinator.h"
   25|       |
   26|       |@implementation GDTCORLifecycle
   27|       |
   28|      1|+ (void)load {
   29|      1|  [self sharedInstance];
   30|      1|}
   31|       |
   32|       |/** Creates/returns the singleton instance of this class.
   33|       | *
   34|       | * @return The singleton instance of this class.
   35|       | */
   36|      1|+ (instancetype)sharedInstance {
   37|      1|  static GDTCORLifecycle *sharedInstance;
   38|      1|  static dispatch_once_t onceToken;
   39|      1|  dispatch_once(&onceToken, ^{
   40|      1|    sharedInstance = [[GDTCORLifecycle alloc] init];
   41|      1|  });
   42|      1|  return sharedInstance;
   43|      1|}
   44|       |
   45|      1|- (instancetype)init {
   46|      1|  self = [super init];
   47|      1|  if (self) {
   48|      1|    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
   49|      1|    [notificationCenter addObserver:self
   50|      1|                           selector:@selector(applicationDidEnterBackground:)
   51|      1|                               name:kGDTCORApplicationDidEnterBackgroundNotification
   52|      1|                             object:nil];
   53|      1|    [notificationCenter addObserver:self
   54|      1|                           selector:@selector(applicationWillEnterForeground:)
   55|      1|                               name:kGDTCORApplicationWillEnterForegroundNotification
   56|      1|                             object:nil];
   57|       |
   58|      1|    NSString *name = kGDTCORApplicationWillTerminateNotification;
   59|      1|    [notificationCenter addObserver:self
   60|      1|                           selector:@selector(applicationWillTerminate:)
   61|      1|                               name:name
   62|      1|                             object:nil];
   63|      1|  }
   64|      1|  return self;
   65|      1|}
   66|       |
   67|      0|- (void)dealloc {
   68|      0|  [[NSNotificationCenter defaultCenter] removeObserver:self];
   69|      0|}
   70|       |
   71|      0|- (void)applicationDidEnterBackground:(NSNotification *)notification {
   72|      0|  GDTCORApplication *application = [GDTCORApplication sharedApplication];
   73|      0|  if ([[GDTCORTransformer sharedInstance] respondsToSelector:@selector(appWillBackground:)]) {
   74|      0|    GDTCORLogDebug(@"%@", @"Signaling GDTCORTransformer that the app is backgrounding.");
   75|      0|    [[GDTCORTransformer sharedInstance] appWillBackground:application];
   76|      0|  }
   77|      0|  if ([[GDTCORUploadCoordinator sharedInstance] respondsToSelector:@selector(appWillBackground:)]) {
   78|      0|    GDTCORLogDebug(@"%@", @"Signaling GDTCORUploadCoordinator that the app is backgrounding.");
   79|      0|    [[GDTCORUploadCoordinator sharedInstance] appWillBackground:application];
   80|      0|  }
   81|      0|  if ([[GDTCORRegistrar sharedInstance] respondsToSelector:@selector(appWillBackground:)]) {
   82|      0|    GDTCORLogDebug(@"%@", @"Signaling GDTCORRegistrar that the app is backgrounding.");
   83|      0|    [[GDTCORRegistrar sharedInstance] appWillBackground:application];
   84|      0|  }
   85|      0|}
   86|       |
   87|      1|- (void)applicationWillEnterForeground:(NSNotification *)notification {
   88|      1|  GDTCORApplication *application = [GDTCORApplication sharedApplication];
   89|      1|  if ([[GDTCORTransformer sharedInstance] respondsToSelector:@selector(appWillForeground:)]) {
   90|      0|    GDTCORLogDebug(@"%@", @"Signaling GDTCORTransformer that the app is foregrounding.");
   91|      0|    [[GDTCORTransformer sharedInstance] appWillForeground:application];
   92|      0|  }
   93|      1|  if ([[GDTCORUploadCoordinator sharedInstance] respondsToSelector:@selector(appWillForeground:)]) {
   94|      1|    GDTCORLogDebug(@"%@", @"Signaling GDTCORUploadCoordinator that the app is foregrounding.");
   95|      1|    [[GDTCORUploadCoordinator sharedInstance] appWillForeground:application];
   96|      1|  }
   97|      1|  if ([[GDTCORRegistrar sharedInstance] respondsToSelector:@selector(appWillForeground:)]) {
   98|      1|    GDTCORLogDebug(@"%@", @"Signaling GDTCORRegistrar that the app is foregrounding.");
   99|      1|    [[GDTCORRegistrar sharedInstance] appWillForeground:application];
  100|      1|  }
  101|      1|}
  102|       |
  103|      0|- (void)applicationWillTerminate:(NSNotification *)notification {
  104|      0|  GDTCORApplication *application = [GDTCORApplication sharedApplication];
  105|      0|  if ([[GDTCORTransformer sharedInstance] respondsToSelector:@selector(appWillTerminate:)]) {
  106|      0|    GDTCORLogDebug(@"%@", @"Signaling GDTCORTransformer that the app is terminating.");
  107|      0|    [[GDTCORTransformer sharedInstance] appWillTerminate:application];
  108|      0|  }
  109|      0|  if ([[GDTCORUploadCoordinator sharedInstance] respondsToSelector:@selector(appWillTerminate:)]) {
  110|      0|    GDTCORLogDebug(@"%@", @"Signaling GDTCORUploadCoordinator that the app is terminating.");
  111|      0|    [[GDTCORUploadCoordinator sharedInstance] appWillTerminate:application];
  112|      0|  }
  113|      0|  if ([[GDTCORRegistrar sharedInstance] respondsToSelector:@selector(appWillTerminate:)]) {
  114|      0|    GDTCORLogDebug(@"%@", @"Signaling GDTCORRegistrar that the app is terminating.");
  115|      0|    [[GDTCORRegistrar sharedInstance] appWillTerminate:application];
  116|      0|  }
  117|      0|}
  118|       |
  119|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORPlatform.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORPlatform.h"
   18|       |
   19|       |#import <sys/sysctl.h>
   20|       |
   21|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORAssert.h"
   22|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORReachability.h"
   23|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORConsoleLogger.h"
   24|       |
   25|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORRegistrar_Private.h"
   26|       |
   27|       |#ifdef GDTCOR_VERSION
   28|       |#define STR(x) STR_EXPAND(x)
   29|       |#define STR_EXPAND(x) #x
   30|       |NSString *const kGDTCORVersion = @STR(GDTCOR_VERSION);
   31|       |#else
   32|       |NSString *const kGDTCORVersion = @"Unknown";
   33|       |#endif  // GDTCOR_VERSION
   34|       |
   35|       |const GDTCORBackgroundIdentifier GDTCORBackgroundIdentifierInvalid = 0;
   36|       |
   37|       |NSString *const kGDTCORApplicationDidEnterBackgroundNotification =
   38|       |    @"GDTCORApplicationDidEnterBackgroundNotification";
   39|       |
   40|       |NSString *const kGDTCORApplicationWillEnterForegroundNotification =
   41|       |    @"GDTCORApplicationWillEnterForegroundNotification";
   42|       |
   43|       |NSString *const kGDTCORApplicationWillTerminateNotification =
   44|       |    @"GDTCORApplicationWillTerminateNotification";
   45|       |
   46|      3|NSURL *GDTCORRootDirectory(void) {
   47|      3|  static NSURL *GDTPath;
   48|      3|  static dispatch_once_t onceToken;
   49|      1|  dispatch_once(&onceToken, ^{
   50|      1|    NSString *cachePath =
   51|      1|        NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];
   52|      1|    GDTPath =
   53|      1|        [NSURL fileURLWithPath:[NSString stringWithFormat:@"%@/google-sdks-events", cachePath]];
   54|      1|    GDTCORLogDebug(@"GDT's state will be saved to: %@", GDTPath);
   55|      1|  });
   56|      3|  NSError *error;
   57|      3|  [[NSFileManager defaultManager] createDirectoryAtPath:GDTPath.path
   58|      3|                            withIntermediateDirectories:YES
   59|      3|                                             attributes:nil
   60|      3|                                                  error:&error];
   61|      3|  GDTCORAssert(error == nil, @"There was an error creating GDT's path");
   62|      3|  return GDTPath;
   63|      3|}
   64|       |
   65|      1|BOOL GDTCORReachabilityFlagsReachable(GDTCORNetworkReachabilityFlags flags) {
   66|      1|#if !TARGET_OS_WATCH
   67|      1|  BOOL reachable =
   68|      1|      (flags & kSCNetworkReachabilityFlagsReachable) == kSCNetworkReachabilityFlagsReachable;
   69|      1|  BOOL connectionRequired = (flags & kSCNetworkReachabilityFlagsConnectionRequired) ==
   70|      1|                            kSCNetworkReachabilityFlagsConnectionRequired;
   71|      1|  return reachable && !connectionRequired;
   72|       |#else
   73|       |  return (flags & kGDTCORNetworkReachabilityFlagsReachable) ==
   74|       |         kGDTCORNetworkReachabilityFlagsReachable;
   75|       |#endif
   76|      1|}
   77|       |
   78|      1|BOOL GDTCORReachabilityFlagsContainWWAN(GDTCORNetworkReachabilityFlags flags) {
   79|      1|#if TARGET_OS_IOS
   80|      1|  return (flags & kSCNetworkReachabilityFlagsIsWWAN) == kSCNetworkReachabilityFlagsIsWWAN;
   81|       |#else
   82|       |  // Assume network connection not WWAN on macOS, tvOS, watchOS.
   83|       |  return NO;
   84|       |#endif  // TARGET_OS_IOS
   85|      1|}
   86|       |
   87|      0|GDTCORNetworkType GDTCORNetworkTypeMessage() {
   88|      0|#if !TARGET_OS_WATCH
   89|      0|  SCNetworkReachabilityFlags reachabilityFlags = [GDTCORReachability currentFlags];
   90|      0|  if ((reachabilityFlags & kSCNetworkReachabilityFlagsReachable) ==
   91|      0|      kSCNetworkReachabilityFlagsReachable) {
   92|      0|    if (GDTCORReachabilityFlagsContainWWAN(reachabilityFlags)) {
   93|      0|      return GDTCORNetworkTypeMobile;
   94|      0|    } else {
   95|      0|      return GDTCORNetworkTypeWIFI;
   96|      0|    }
   97|      0|  }
   98|      0|#endif
   99|      0|  return GDTCORNetworkTypeUNKNOWN;
  100|      0|}
  101|       |
  102|      0|GDTCORNetworkMobileSubtype GDTCORNetworkMobileSubTypeMessage() {
  103|      0|#if TARGET_OS_IOS
  104|      0|  static NSDictionary<NSString *, NSNumber *> *CTRadioAccessTechnologyToNetworkSubTypeMessage;
  105|      0|  static CTTelephonyNetworkInfo *networkInfo;
  106|      0|  static dispatch_once_t onceToken;
  107|      0|  dispatch_once(&onceToken, ^{
  108|      0|    CTRadioAccessTechnologyToNetworkSubTypeMessage = @{
  109|      0|      CTRadioAccessTechnologyGPRS : @(GDTCORNetworkMobileSubtypeGPRS),
  110|      0|      CTRadioAccessTechnologyEdge : @(GDTCORNetworkMobileSubtypeEdge),
  111|      0|      CTRadioAccessTechnologyWCDMA : @(GDTCORNetworkMobileSubtypeWCDMA),
  112|      0|      CTRadioAccessTechnologyHSDPA : @(GDTCORNetworkMobileSubtypeHSDPA),
  113|      0|      CTRadioAccessTechnologyHSUPA : @(GDTCORNetworkMobileSubtypeHSUPA),
  114|      0|      CTRadioAccessTechnologyCDMA1x : @(GDTCORNetworkMobileSubtypeCDMA1x),
  115|      0|      CTRadioAccessTechnologyCDMAEVDORev0 : @(GDTCORNetworkMobileSubtypeCDMAEVDORev0),
  116|      0|      CTRadioAccessTechnologyCDMAEVDORevA : @(GDTCORNetworkMobileSubtypeCDMAEVDORevA),
  117|      0|      CTRadioAccessTechnologyCDMAEVDORevB : @(GDTCORNetworkMobileSubtypeCDMAEVDORevB),
  118|      0|      CTRadioAccessTechnologyeHRPD : @(GDTCORNetworkMobileSubtypeHRPD),
  119|      0|      CTRadioAccessTechnologyLTE : @(GDTCORNetworkMobileSubtypeLTE),
  120|      0|    };
  121|      0|    networkInfo = [[CTTelephonyNetworkInfo alloc] init];
  122|      0|  });
  123|      0|  NSString *networkCurrentRadioAccessTechnology;
  124|       |#if TARGET_OS_MACCATALYST
  125|       |  NSDictionary<NSString *, NSString *> *networkCurrentRadioAccessTechnologyDict =
  126|       |      networkInfo.serviceCurrentRadioAccessTechnology;
  127|       |  if (networkCurrentRadioAccessTechnologyDict.count) {
  128|       |    networkCurrentRadioAccessTechnology = networkCurrentRadioAccessTechnologyDict.allValues[0];
  129|       |  }
  130|       |#else  // TARGET_OS_MACCATALYST
  131|      0|  if (@available(iOS 12.0, *)) {
  132|      0|    NSDictionary<NSString *, NSString *> *networkCurrentRadioAccessTechnologyDict =
  133|      0|        networkInfo.serviceCurrentRadioAccessTechnology;
  134|      0|    if (networkCurrentRadioAccessTechnologyDict.count) {
  135|       |      // In iOS 12, multiple radio technologies can be captured. We prefer not particular radio
  136|       |      // tech to another, so we'll just return the first value in the dictionary.
  137|      0|      networkCurrentRadioAccessTechnology = networkCurrentRadioAccessTechnologyDict.allValues[0];
  138|      0|    }
  139|      0|  } else {
  140|      0|#if TARGET_OS_IOS && __IPHONE_OS_VERSION_MIN_REQUIRED < 120000
  141|      0|    networkCurrentRadioAccessTechnology = networkInfo.currentRadioAccessTechnology;
  142|      0|#endif  // TARGET_OS_IOS && __IPHONE_OS_VERSION_MIN_REQUIRED < 120000
  143|      0|  }
  144|      0|#endif  // TARGET_OS_MACCATALYST
  145|      0|  if (networkCurrentRadioAccessTechnology) {
  146|      0|    NSNumber *networkMobileSubtype =
  147|      0|        CTRadioAccessTechnologyToNetworkSubTypeMessage[networkCurrentRadioAccessTechnology];
  148|      0|    return networkMobileSubtype.intValue;
  149|      0|  } else {
  150|      0|    return GDTCORNetworkMobileSubtypeUNKNOWN;
  151|      0|  }
  152|       |#else   // TARGET_OS_IOS
  153|       |  return GDTCORNetworkMobileSubtypeUNKNOWN;
  154|       |#endif  // TARGET_OS_IOS
  155|      0|}
  156|       |
  157|      0|NSString *_Nonnull GDTCORDeviceModel() {
  158|      0|  static NSString *deviceModel = @"Unknown";
  159|       |
  160|      0|#if TARGET_OS_IOS || TARGET_OS_TV
  161|      0|  static dispatch_once_t onceToken;
  162|      0|  dispatch_once(&onceToken, ^{
  163|      0|    size_t size;
  164|      0|    char *keyToExtract = "hw.machine";
  165|      0|    sysctlbyname(keyToExtract, NULL, &size, NULL, 0);
  166|      0|    if (size > 0) {
  167|      0|      char *machine = calloc(1, size);
  168|      0|      sysctlbyname(keyToExtract, machine, &size, NULL, 0);
  169|      0|      deviceModel = [NSString stringWithCString:machine encoding:NSUTF8StringEncoding];
  170|      0|      free(machine);
  171|      0|    } else {
  172|      0|      deviceModel = [UIDevice currentDevice].model;
  173|      0|    }
  174|      0|  });
  175|      0|#endif
  176|       |
  177|      0|  return deviceModel;
  178|      0|}
  179|       |
  180|       |NSData *_Nullable GDTCOREncodeArchive(id<NSSecureCoding> obj,
  181|       |                                      NSString *filePath,
  182|      0|                                      NSError *_Nullable *error) {
  183|      0|  BOOL result = NO;
  184|      0|  if (filePath.length > 0) {
  185|      0|    result = [[NSFileManager defaultManager]
  186|      0|              createDirectoryAtPath:[filePath stringByDeletingLastPathComponent]
  187|      0|        withIntermediateDirectories:YES
  188|      0|                         attributes:nil
  189|      0|                              error:error];
  190|      0|    if (result == NO || *error) {
  191|      0|      GDTCORLogDebug(@"Attempt to create directory failed: path:%@ error:%@", filePath, *error);
  192|      0|      return nil;
  193|      0|    }
  194|      0|  }
  195|      0|  NSData *resultData;
  196|      0|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4, *)) {
  197|      0|    resultData = [NSKeyedArchiver archivedDataWithRootObject:obj
  198|      0|                                       requiringSecureCoding:YES
  199|      0|                                                       error:error];
  200|      0|    if (resultData == nil || (error != NULL && *error != nil)) {
  201|      0|      GDTCORLogDebug(@"Encoding an object failed: %@", *error);
  202|      0|      return nil;
  203|      0|    }
  204|      0|    if (filePath.length > 0) {
  205|      0|      result = [resultData writeToFile:filePath options:NSDataWritingAtomic error:error];
  206|      0|      if (result == NO || *error) {
  207|      0|        GDTCORLogDebug(@"Attempt to write archive failed: path:%@ error:%@", filePath, *error);
  208|      0|      } else {
  209|      0|        GDTCORLogDebug(@"Writing archive succeeded: %@", filePath);
  210|      0|      }
  211|      0|    }
  212|      0|  } else {
  213|      0|    @try {
  214|      0|#pragma clang diagnostic push
  215|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  216|      0|      resultData = [NSKeyedArchiver archivedDataWithRootObject:obj];
  217|      0|#pragma clang diagnostic pop
  218|      0|      if (filePath.length > 0) {
  219|      0|        result = [resultData writeToFile:filePath options:NSDataWritingAtomic error:error];
  220|      0|        if (result == NO || *error) {
  221|      0|          GDTCORLogDebug(@"Attempt to write archive failed: URL:%@ error:%@", filePath, *error);
  222|      0|        } else {
  223|      0|          GDTCORLogDebug(@"Writing archive succeeded: %@", filePath);
  224|      0|        }
  225|      0|      }
  226|      0|    } @catch (NSException *exception) {
  227|      0|      NSString *errorString =
  228|      0|          [NSString stringWithFormat:@"An exception was thrown during encoding: %@", exception];
  229|      0|      *error = [NSError errorWithDomain:NSCocoaErrorDomain
  230|      0|                                   code:-1
  231|      0|                               userInfo:@{NSLocalizedFailureReasonErrorKey : errorString}];
  232|      0|    }
  233|      0|    if (filePath.length > 0) {
  234|      0|      GDTCORLogDebug(@"Attempt to write archive. successful:%@ URL:%@ error:%@",
  235|      0|                     result ? @"YES" : @"NO", filePath, *error);
  236|      0|    }
  237|      0|  }
  238|      0|  return resultData;
  239|      0|}
  240|       |
  241|       |id<NSSecureCoding> _Nullable GDTCORDecodeArchive(Class archiveClass,
  242|       |                                                 NSString *_Nullable archivePath,
  243|       |                                                 NSData *_Nullable archiveData,
  244|      0|                                                 NSError *_Nullable *error) {
  245|      0|  id<NSSecureCoding> unarchivedObject = nil;
  246|      0|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4, *)) {
  247|      0|    NSData *data = archiveData ? archiveData : [NSData dataWithContentsOfFile:archivePath];
  248|      0|    if (data) {
  249|      0|      unarchivedObject = [NSKeyedUnarchiver unarchivedObjectOfClass:archiveClass
  250|      0|                                                           fromData:data
  251|      0|                                                              error:error];
  252|      0|    }
  253|      0|  } else {
  254|      0|    @try {
  255|      0|      NSData *archivedData =
  256|      0|          archiveData ? archiveData : [NSData dataWithContentsOfFile:archivePath];
  257|      0|#pragma clang diagnostic push
  258|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  259|      0|      unarchivedObject = [NSKeyedUnarchiver unarchiveObjectWithData:archivedData];
  260|      0|#pragma clang diagnostic pop
  261|      0|    } @catch (NSException *exception) {
  262|      0|      NSString *errorString =
  263|      0|          [NSString stringWithFormat:@"An exception was thrown during encoding: %@", exception];
  264|      0|      *error = [NSError errorWithDomain:NSCocoaErrorDomain
  265|      0|                                   code:-1
  266|      0|                               userInfo:@{NSLocalizedFailureReasonErrorKey : errorString}];
  267|      0|    }
  268|      0|  }
  269|      0|  return unarchivedObject;
  270|      0|}
  271|       |
  272|      0|BOOL GDTCORWriteDataToFile(NSData *data, NSString *filePath, NSError *_Nullable *outError) {
  273|      0|  BOOL result = NO;
  274|      0|  if (filePath.length > 0) {
  275|      0|    result = [[NSFileManager defaultManager]
  276|      0|              createDirectoryAtPath:[filePath stringByDeletingLastPathComponent]
  277|      0|        withIntermediateDirectories:YES
  278|      0|                         attributes:nil
  279|      0|                              error:outError];
  280|      0|    if (result == NO || *outError) {
  281|      0|      GDTCORLogDebug(@"Attempt to create directory failed: path:%@ error:%@", filePath, *outError);
  282|      0|      return result;
  283|      0|    }
  284|      0|  }
  285|       |
  286|      0|  if (filePath.length > 0) {
  287|      0|    result = [data writeToFile:filePath options:NSDataWritingAtomic error:outError];
  288|      0|    if (result == NO || *outError) {
  289|      0|      GDTCORLogDebug(@"Attempt to write archive failed: path:%@ error:%@", filePath, *outError);
  290|      0|    } else {
  291|      0|      GDTCORLogDebug(@"Writing archive succeeded: %@", filePath);
  292|      0|    }
  293|      0|  }
  294|       |
  295|      0|  return result;
  296|      0|}
  297|       |
  298|       |@interface GDTCORApplication ()
  299|       |/**
  300|       | Private flag to match the existing `readonly` public flag. This will be accurate for all platforms,
  301|       | since we handle each platform's lifecycle notifications separately.
  302|       | */
  303|       |@property(atomic, readwrite) BOOL isRunningInBackground;
  304|       |
  305|       |@end
  306|       |
  307|       |@implementation GDTCORApplication
  308|       |
  309|       |#if TARGET_OS_WATCH
  310|       |/** A dispatch queue on which all task semaphores will populate and remove from
  311|       | * gBackgroundIdentifierToSemaphoreMap.
  312|       | */
  313|       |static dispatch_queue_t gSemaphoreQueue;
  314|       |
  315|       |/** For mapping backgroundIdentifier to task semaphore. */
  316|       |static NSMutableDictionary<NSNumber *, dispatch_semaphore_t> *gBackgroundIdentifierToSemaphoreMap;
  317|       |#endif
  318|       |
  319|      1|+ (void)load {
  320|      1|  GDTCORLogDebug(
  321|      1|      @"%@", @"GDT is initializing. Please note that if you quit the app via the "
  322|      1|              "debugger and not through a lifecycle event, event data will remain on disk but "
  323|      1|              "storage won't have a reference to them since the singleton wasn't saved to disk.");
  324|      1|#if TARGET_OS_IOS || TARGET_OS_TV
  325|       |  // If this asserts, please file a bug at https://github.com/firebase/firebase-ios-sdk/issues.
  326|      1|  GDTCORFatalAssert(
  327|      1|      GDTCORBackgroundIdentifierInvalid == UIBackgroundTaskInvalid,
  328|      1|      @"GDTCORBackgroundIdentifierInvalid and UIBackgroundTaskInvalid should be the same.");
  329|      1|#endif
  330|      1|  [self sharedApplication];
  331|      1|}
  332|       |
  333|      1|+ (void)initialize {
  334|       |#if TARGET_OS_WATCH
  335|       |  static dispatch_once_t onceToken;
  336|       |  dispatch_once(&onceToken, ^{
  337|       |    gSemaphoreQueue = dispatch_queue_create("com.google.GDTCORApplication", DISPATCH_QUEUE_SERIAL);
  338|       |    GDTCORLogDebug(
  339|       |        @"%@",
  340|       |        @"GDTCORApplication is initializing on watchOS, gSemaphoreQueue has been initialized.");
  341|       |    gBackgroundIdentifierToSemaphoreMap = [[NSMutableDictionary alloc] init];
  342|       |    GDTCORLogDebug(@"%@", @"GDTCORApplication is initializing on watchOS, "
  343|       |                          @"gBackgroundIdentifierToSemaphoreMap has been initialized.");
  344|       |  });
  345|       |#endif
  346|      1|}
  347|       |
  348|     12|+ (nullable GDTCORApplication *)sharedApplication {
  349|     12|  static GDTCORApplication *application;
  350|     12|  static dispatch_once_t onceToken;
  351|      1|  dispatch_once(&onceToken, ^{
  352|      1|    application = [[GDTCORApplication alloc] init];
  353|      1|  });
  354|     12|  return application;
  355|     12|}
  356|       |
  357|      1|- (instancetype)init {
  358|      1|  self = [super init];
  359|      1|  if (self) {
  360|       |    // This class will be instantiated in the foreground.
  361|      1|    _isRunningInBackground = NO;
  362|       |
  363|      1|#if TARGET_OS_IOS || TARGET_OS_TV
  364|      1|    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
  365|      1|    [notificationCenter addObserver:self
  366|      1|                           selector:@selector(iOSApplicationDidEnterBackground:)
  367|      1|                               name:UIApplicationDidEnterBackgroundNotification
  368|      1|                             object:nil];
  369|      1|    [notificationCenter addObserver:self
  370|      1|                           selector:@selector(iOSApplicationWillEnterForeground:)
  371|      1|                               name:UIApplicationWillEnterForegroundNotification
  372|      1|                             object:nil];
  373|       |
  374|      1|    NSString *name = UIApplicationWillTerminateNotification;
  375|      1|    [notificationCenter addObserver:self
  376|      1|                           selector:@selector(iOSApplicationWillTerminate:)
  377|      1|                               name:name
  378|      1|                             object:nil];
  379|       |
  380|      1|#if defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 130000
  381|      1|    if (@available(iOS 13, tvOS 13.0, *)) {
  382|      1|      [notificationCenter addObserver:self
  383|      1|                             selector:@selector(iOSApplicationWillEnterForeground:)
  384|      1|                                 name:UISceneWillEnterForegroundNotification
  385|      1|                               object:nil];
  386|      1|      [notificationCenter addObserver:self
  387|      1|                             selector:@selector(iOSApplicationDidEnterBackground:)
  388|      1|                                 name:UISceneWillDeactivateNotification
  389|      1|                               object:nil];
  390|      1|    }
  391|      1|#endif  // defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 130000
  392|       |
  393|       |#elif TARGET_OS_OSX
  394|       |    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
  395|       |    [notificationCenter addObserver:self
  396|       |                           selector:@selector(macOSApplicationWillTerminate:)
  397|       |                               name:NSApplicationWillTerminateNotification
  398|       |                             object:nil];
  399|       |
  400|       |#elif TARGET_OS_WATCH
  401|       |    // TODO: Notification on watchOS platform is currently posted by strings which are frangible.
  402|       |    // TODO: Needs improvements here.
  403|       |    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
  404|       |    [notificationCenter addObserver:self
  405|       |                           selector:@selector(iOSApplicationDidEnterBackground:)
  406|       |                               name:@"UIApplicationDidEnterBackgroundNotification"
  407|       |                             object:nil];
  408|       |    [notificationCenter addObserver:self
  409|       |                           selector:@selector(iOSApplicationWillEnterForeground:)
  410|       |                               name:@"UIApplicationWillEnterForegroundNotification"
  411|       |                             object:nil];
  412|       |
  413|       |    // Adds observers for app extension on watchOS platform
  414|       |    [notificationCenter addObserver:self
  415|       |                           selector:@selector(iOSApplicationDidEnterBackground:)
  416|       |                               name:NSExtensionHostDidEnterBackgroundNotification
  417|       |                             object:nil];
  418|       |    [notificationCenter addObserver:self
  419|       |                           selector:@selector(iOSApplicationWillEnterForeground:)
  420|       |                               name:NSExtensionHostWillEnterForegroundNotification
  421|       |                             object:nil];
  422|       |#endif
  423|      1|  }
  424|      1|  return self;
  425|      1|}
  426|       |
  427|       |#if TARGET_OS_WATCH
  428|       |/** Generates and maps a unique background identifier to the given semaphore.
  429|       | *
  430|       | * @param semaphore The semaphore to map.
  431|       | * @return A unique GDTCORBackgroundIdentifier mapped to the given semaphore.
  432|       | */
  433|       |+ (GDTCORBackgroundIdentifier)createAndMapBackgroundIdentifierToSemaphore:
  434|       |    (dispatch_semaphore_t)semaphore {
  435|       |  __block GDTCORBackgroundIdentifier bgID = GDTCORBackgroundIdentifierInvalid;
  436|       |  dispatch_queue_t queue = gSemaphoreQueue;
  437|       |  NSMutableDictionary<NSNumber *, dispatch_semaphore_t> *map = gBackgroundIdentifierToSemaphoreMap;
  438|       |  if (queue && map) {
  439|       |    dispatch_sync(queue, ^{
  440|       |      bgID = arc4random();
  441|       |      NSNumber *bgIDNumber = @(bgID);
  442|       |      while (bgID == GDTCORBackgroundIdentifierInvalid || map[bgIDNumber]) {
  443|       |        bgID = arc4random();
  444|       |        bgIDNumber = @(bgID);
  445|       |      }
  446|       |      map[bgIDNumber] = semaphore;
  447|       |    });
  448|       |  }
  449|       |  return bgID;
  450|       |}
  451|       |
  452|       |/** Returns the semaphore mapped to given bgID and removes the value from the map.
  453|       | *
  454|       | * @param bgID The unique NSUInteger as GDTCORBackgroundIdentifier.
  455|       | * @return The semaphore mapped by given bgID.
  456|       | */
  457|       |+ (dispatch_semaphore_t)semaphoreForBackgroundIdentifier:(GDTCORBackgroundIdentifier)bgID {
  458|       |  __block dispatch_semaphore_t semaphore;
  459|       |  dispatch_queue_t queue = gSemaphoreQueue;
  460|       |  NSMutableDictionary<NSNumber *, dispatch_semaphore_t> *map = gBackgroundIdentifierToSemaphoreMap;
  461|       |  NSNumber *bgIDNumber = @(bgID);
  462|       |  if (queue && map) {
  463|       |    dispatch_sync(queue, ^{
  464|       |      semaphore = map[bgIDNumber];
  465|       |      [map removeObjectForKey:bgIDNumber];
  466|       |    });
  467|       |  }
  468|       |  return semaphore;
  469|       |}
  470|       |#endif
  471|       |
  472|       |- (GDTCORBackgroundIdentifier)beginBackgroundTaskWithName:(NSString *)name
  473|      4|                                        expirationHandler:(void (^)(void))handler {
  474|      4|  __block GDTCORBackgroundIdentifier bgID = GDTCORBackgroundIdentifierInvalid;
  475|      4|#if !TARGET_OS_WATCH
  476|      4|  bgID = [[self sharedApplicationForBackgroundTask] beginBackgroundTaskWithName:name
  477|      4|                                                              expirationHandler:handler];
  478|      4|#if !NDEBUG
  479|      4|  if (bgID != GDTCORBackgroundIdentifierInvalid) {
  480|      4|    GDTCORLogDebug(@"Creating background task with name:%@ bgID:%ld", name, (long)bgID);
  481|      4|  }
  482|      4|#endif  // !NDEBUG
  483|       |#elif TARGET_OS_WATCH
  484|       |  dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
  485|       |  bgID = [GDTCORApplication createAndMapBackgroundIdentifierToSemaphore:semaphore];
  486|       |  if (bgID != GDTCORBackgroundIdentifierInvalid) {
  487|       |    GDTCORLogDebug(@"Creating activity with name:%@ bgID:%ld on watchOS.", name, (long)bgID);
  488|       |  }
  489|       |  [[self sharedNSProcessInfoForBackgroundTask]
  490|       |      performExpiringActivityWithReason:name
  491|       |                             usingBlock:^(BOOL expired) {
  492|       |                               if (expired) {
  493|       |                                 if (handler) {
  494|       |                                   handler();
  495|       |                                 }
  496|       |                                 dispatch_semaphore_signal(semaphore);
  497|       |                                 GDTCORLogDebug(
  498|       |                                     @"Activity with name:%@ bgID:%ld on watchOS is expiring.",
  499|       |                                     name, (long)bgID);
  500|       |                               } else {
  501|       |                                 dispatch_semaphore_wait(
  502|       |                                     semaphore,
  503|       |                                     dispatch_time(DISPATCH_TIME_NOW, 30 * NSEC_PER_SEC));
  504|       |                               }
  505|       |                             }];
  506|       |#endif
  507|      4|  return bgID;
  508|      4|}
  509|       |
  510|      4|- (void)endBackgroundTask:(GDTCORBackgroundIdentifier)bgID {
  511|      4|#if !TARGET_OS_WATCH
  512|      4|  if (bgID != GDTCORBackgroundIdentifierInvalid) {
  513|      4|    GDTCORLogDebug(@"Ending background task with ID:%ld was successful", (long)bgID);
  514|      4|    [[self sharedApplicationForBackgroundTask] endBackgroundTask:bgID];
  515|      4|    return;
  516|      4|  }
  517|       |#elif TARGET_OS_WATCH
  518|       |  if (bgID != GDTCORBackgroundIdentifierInvalid) {
  519|       |    dispatch_semaphore_t semaphore = [GDTCORApplication semaphoreForBackgroundIdentifier:bgID];
  520|       |    GDTCORLogDebug(@"Ending activity with bgID:%ld on watchOS.", (long)bgID);
  521|       |    if (semaphore) {
  522|       |      dispatch_semaphore_signal(semaphore);
  523|       |      GDTCORLogDebug(@"Signaling semaphore with bgID:%ld on watchOS.", (long)bgID);
  524|       |    } else {
  525|       |      GDTCORLogDebug(@"Semaphore with bgID:%ld is nil on watchOS.", (long)bgID);
  526|       |    }
  527|       |  }
  528|       |#endif  // !TARGET_OS_WATCH
  529|      4|}
  530|       |
  531|       |#pragma mark - App environment helpers
  532|       |
  533|      8|- (BOOL)isAppExtension {
  534|      8|  BOOL appExtension = [[[NSBundle mainBundle] bundlePath] hasSuffix:@".appex"];
  535|      8|  return appExtension;
  536|      8|}
  537|       |
  538|       |/** Returns a UIApplication or NSProcessInfo instance if on the appropriate platform.
  539|       | *
  540|       | * @return The shared UIApplication or NSProcessInfo if on the appropriate platform.
  541|       | */
  542|       |#if TARGET_OS_IOS || TARGET_OS_TV
  543|      8|- (nullable UIApplication *)sharedApplicationForBackgroundTask {
  544|       |#elif TARGET_OS_WATCH
  545|       |- (nullable NSProcessInfo *)sharedNSProcessInfoForBackgroundTask {
  546|       |#else
  547|       |- (nullable id)sharedApplicationForBackgroundTask {
  548|       |#endif
  549|      8|  id sharedInstance = nil;
  550|      8|#if TARGET_OS_IOS || TARGET_OS_TV
  551|      8|  if (![self isAppExtension]) {
  552|      8|    Class uiApplicationClass = NSClassFromString(@"UIApplication");
  553|      8|    if (uiApplicationClass &&
  554|      8|        [uiApplicationClass respondsToSelector:(NSSelectorFromString(@"sharedApplication"))]) {
  555|      8|      sharedInstance = [uiApplicationClass sharedApplication];
  556|      8|    }
  557|      8|  }
  558|       |#elif TARGET_OS_WATCH
  559|       |  sharedInstance = [NSProcessInfo processInfo];
  560|       |#endif
  561|      8|  return sharedInstance;
  562|      8|}
  563|       |
  564|       |#pragma mark - UIApplicationDelegate and WKExtensionDelegate
  565|       |
  566|       |#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH
  567|      0|- (void)iOSApplicationDidEnterBackground:(NSNotification *)notif {
  568|      0|  _isRunningInBackground = YES;
  569|       |
  570|      0|  NSNotificationCenter *notifCenter = [NSNotificationCenter defaultCenter];
  571|      0|  GDTCORLogDebug(@"%@", @"GDTCORPlatform is sending a notif that the app is backgrounding.");
  572|      0|  [notifCenter postNotificationName:kGDTCORApplicationDidEnterBackgroundNotification object:nil];
  573|      0|}
  574|       |
  575|      1|- (void)iOSApplicationWillEnterForeground:(NSNotification *)notif {
  576|      1|  _isRunningInBackground = NO;
  577|       |
  578|      1|  NSNotificationCenter *notifCenter = [NSNotificationCenter defaultCenter];
  579|      1|  GDTCORLogDebug(@"%@", @"GDTCORPlatform is sending a notif that the app is foregrounding.");
  580|      1|  [notifCenter postNotificationName:kGDTCORApplicationWillEnterForegroundNotification object:nil];
  581|      1|}
  582|       |#endif  // TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH
  583|       |
  584|       |#pragma mark - UIApplicationDelegate
  585|       |
  586|       |#if TARGET_OS_IOS || TARGET_OS_TV
  587|      0|- (void)iOSApplicationWillTerminate:(NSNotification *)notif {
  588|      0|  NSNotificationCenter *notifCenter = [NSNotificationCenter defaultCenter];
  589|      0|  GDTCORLogDebug(@"%@", @"GDTCORPlatform is sending a notif that the app is terminating.");
  590|      0|  [notifCenter postNotificationName:kGDTCORApplicationWillTerminateNotification object:nil];
  591|      0|}
  592|       |#endif  // TARGET_OS_IOS || TARGET_OS_TV
  593|       |
  594|       |#pragma mark - NSApplicationDelegate
  595|       |
  596|       |#if TARGET_OS_OSX
  597|       |- (void)macOSApplicationWillTerminate:(NSNotification *)notif {
  598|       |  NSNotificationCenter *notifCenter = [NSNotificationCenter defaultCenter];
  599|       |  GDTCORLogDebug(@"%@", @"GDTCORPlatform is sending a notif that the app is terminating.");
  600|       |  [notifCenter postNotificationName:kGDTCORApplicationWillTerminateNotification object:nil];
  601|       |}
  602|       |#endif  // TARGET_OS_OSX
  603|       |
  604|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORReachability.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORReachability.h"
   18|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORReachability_Private.h"
   19|       |
   20|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORConsoleLogger.h"
   21|       |
   22|       |#import <netinet/in.h>
   23|       |
   24|       |/** Sets the _callbackFlag ivar whenever the network changes.
   25|       | *
   26|       | * @param reachability The reachability object calling back.
   27|       | * @param flags The new flag values.
   28|       | * @param info Any data that might be passed in by the callback.
   29|       | */
   30|       |static void GDTCORReachabilityCallback(GDTCORNetworkReachabilityRef reachability,
   31|       |                                       GDTCORNetworkReachabilityFlags flags,
   32|       |                                       void *info);
   33|       |
   34|       |@implementation GDTCORReachability {
   35|       |  /** The reachability object. */
   36|       |  GDTCORNetworkReachabilityRef _reachabilityRef;
   37|       |
   38|       |  /** The queue on which callbacks and all work will occur. */
   39|       |  dispatch_queue_t _reachabilityQueue;
   40|       |
   41|       |  /** Flags specified by reachability callbacks. */
   42|       |  GDTCORNetworkReachabilityFlags _callbackFlags;
   43|       |}
   44|       |
   45|      1|+ (void)initialize {
   46|      1|  [self sharedInstance];
   47|      1|}
   48|       |
   49|      3|+ (instancetype)sharedInstance {
   50|      3|  static GDTCORReachability *sharedInstance;
   51|      3|  static dispatch_once_t onceToken;
   52|      1|  dispatch_once(&onceToken, ^{
   53|      1|    sharedInstance = [[GDTCORReachability alloc] init];
   54|      1|  });
   55|      3|  return sharedInstance;
   56|      3|}
   57|       |
   58|      1|+ (GDTCORNetworkReachabilityFlags)currentFlags {
   59|      1|  __block GDTCORNetworkReachabilityFlags currentFlags;
   60|      1|#if !TARGET_OS_WATCH
   61|      1|  dispatch_sync([GDTCORReachability sharedInstance] -> _reachabilityQueue, ^{
   62|      1|    GDTCORReachability *reachability = [GDTCORReachability sharedInstance];
   63|      1|    currentFlags =
   64|      1|        reachability->_callbackFlags ? reachability->_callbackFlags : reachability->_flags;
   65|      1|    GDTCORLogDebug(@"Initial reachability flags determined: %d", currentFlags);
   66|      1|  });
   67|       |#else
   68|       |  currentFlags = kGDTCORNetworkReachabilityFlagsReachable;
   69|       |#endif
   70|      1|  return currentFlags;
   71|      1|}
   72|       |
   73|      1|- (instancetype)init {
   74|      1|  self = [super init];
   75|      1|#if !TARGET_OS_WATCH
   76|      1|  if (self) {
   77|      1|    struct sockaddr_in zeroAddress;
   78|      1|    bzero(&zeroAddress, sizeof(zeroAddress));
   79|      1|    zeroAddress.sin_len = sizeof(zeroAddress);
   80|      1|    zeroAddress.sin_family = AF_INET;
   81|       |
   82|      1|    _reachabilityQueue =
   83|      1|        dispatch_queue_create("com.google.GDTCORReachability", DISPATCH_QUEUE_SERIAL);
   84|      1|    _reachabilityRef = SCNetworkReachabilityCreateWithAddress(
   85|      1|        kCFAllocatorDefault, (const struct sockaddr *)&zeroAddress);
   86|      1|    Boolean success = SCNetworkReachabilitySetDispatchQueue(_reachabilityRef, _reachabilityQueue);
   87|      1|    if (!success) {
   88|      0|      GDTCORLogWarning(GDTCORMCWReachabilityFailed, @"%@", @"The reachability queue wasn't set.");
   89|      0|    }
   90|      1|    success = SCNetworkReachabilitySetCallback(_reachabilityRef, GDTCORReachabilityCallback, NULL);
   91|      1|    if (!success) {
   92|      0|      GDTCORLogWarning(GDTCORMCWReachabilityFailed, @"%@",
   93|      0|                       @"The reachability callback wasn't set.");
   94|      0|    }
   95|       |
   96|       |    // Get the initial set of flags.
   97|      1|    dispatch_async(_reachabilityQueue, ^{
   98|      1|      Boolean valid = SCNetworkReachabilityGetFlags(self->_reachabilityRef, &self->_flags);
   99|      1|      if (!valid) {
  100|      0|        GDTCORLogDebug(@"%@", @"Determining reachability failed.");
  101|      0|        self->_flags = 0;
  102|      0|      }
  103|      1|    });
  104|      1|  }
  105|      1|#endif
  106|      1|  return self;
  107|      1|}
  108|       |
  109|      0|- (void)setCallbackFlags:(GDTCORNetworkReachabilityFlags)flags {
  110|      0|  if (_callbackFlags != flags) {
  111|      0|    self->_callbackFlags = flags;
  112|      0|  }
  113|      0|}
  114|       |
  115|       |@end
  116|       |
  117|       |#pragma clang diagnostic push
  118|       |#pragma clang diagnostic ignored "-Wunused-function"
  119|       |static void GDTCORReachabilityCallback(GDTCORNetworkReachabilityRef reachability,
  120|       |                                       GDTCORNetworkReachabilityFlags flags,
  121|      0|                                       void *info) {
  122|      0|#pragma clang diagnostic pop
  123|      0|  GDTCORLogDebug(@"Reachability changed, new flags: %d", flags);
  124|      0|  [[GDTCORReachability sharedInstance] setCallbackFlags:flags];
  125|      0|}

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORRegistrar.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORRegistrar.h"
   18|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORRegistrar_Private.h"
   19|       |
   20|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORConsoleLogger.h"
   21|       |
   22|      0|id<GDTCORStorageProtocol> _Nullable GDTCORStorageInstanceForTarget(GDTCORTarget target) {
   23|      0|  return [GDTCORRegistrar sharedInstance].targetToStorage[@(target)];
   24|      0|}
   25|       |
   26|       |FOUNDATION_EXPORT
   27|       |id<GDTCORStoragePromiseProtocol> _Nullable GDTCORStoragePromiseInstanceForTarget(
   28|      4|    GDTCORTarget target) {
   29|      4|  id storage = [GDTCORRegistrar sharedInstance].targetToStorage[@(target)];
   30|      4|  if ([storage conformsToProtocol:@protocol(GDTCORStoragePromiseProtocol)]) {
   31|      4|    return storage;
   32|      0|  } else {
   33|      0|    return nil;
   34|      0|  }
   35|      4|}
   36|       |
   37|       |@implementation GDTCORRegistrar {
   38|       |  /** Backing ivar for targetToUploader property. */
   39|       |  NSMutableDictionary<NSNumber *, id<GDTCORUploader>> *_targetToUploader;
   40|       |
   41|       |  /** Backing ivar for targetToStorage property. */
   42|       |  NSMutableDictionary<NSNumber *, id<GDTCORStorageProtocol>> *_targetToStorage;
   43|       |}
   44|       |
   45|     16|+ (instancetype)sharedInstance {
   46|     16|  static GDTCORRegistrar *sharedInstance;
   47|     16|  static dispatch_once_t onceToken;
   48|      1|  dispatch_once(&onceToken, ^{
   49|      1|    sharedInstance = [[GDTCORRegistrar alloc] init];
   50|      1|  });
   51|     16|  return sharedInstance;
   52|     16|}
   53|       |
   54|      1|- (instancetype)init {
   55|      1|  self = [super init];
   56|      1|  if (self) {
   57|      1|    _registrarQueue = dispatch_queue_create("com.google.GDTCORRegistrar", DISPATCH_QUEUE_SERIAL);
   58|      1|    _targetToUploader = [[NSMutableDictionary alloc] init];
   59|      1|    _targetToStorage = [[NSMutableDictionary alloc] init];
   60|      1|  }
   61|      1|  return self;
   62|      1|}
   63|       |
   64|      4|- (void)registerUploader:(id<GDTCORUploader>)backend target:(GDTCORTarget)target {
   65|      4|  __weak GDTCORRegistrar *weakSelf = self;
   66|      4|  dispatch_async(_registrarQueue, ^{
   67|      4|    GDTCORRegistrar *strongSelf = weakSelf;
   68|      4|    if (strongSelf) {
   69|      4|      GDTCORLogDebug(@"Registered an uploader: %@ for target:%ld", backend, (long)target);
   70|      4|      strongSelf->_targetToUploader[@(target)] = backend;
   71|      4|    }
   72|      4|  });
   73|      4|}
   74|       |
   75|      5|- (void)registerStorage:(id<GDTCORStorageProtocol>)storage target:(GDTCORTarget)target {
   76|      5|  __weak GDTCORRegistrar *weakSelf = self;
   77|      5|  dispatch_async(_registrarQueue, ^{
   78|      5|    GDTCORRegistrar *strongSelf = weakSelf;
   79|      5|    if (strongSelf) {
   80|      5|      GDTCORLogDebug(@"Registered storage: %@ for target:%ld", storage, (long)target);
   81|      5|      strongSelf->_targetToStorage[@(target)] = storage;
   82|      5|    }
   83|      5|  });
   84|      5|}
   85|       |
   86|      6|- (NSMutableDictionary<NSNumber *, id<GDTCORUploader>> *)targetToUploader {
   87|      6|  __block NSMutableDictionary<NSNumber *, id<GDTCORUploader>> *targetToUploader;
   88|      6|  __weak GDTCORRegistrar *weakSelf = self;
   89|      6|  dispatch_sync(_registrarQueue, ^{
   90|      6|    GDTCORRegistrar *strongSelf = weakSelf;
   91|      6|    if (strongSelf) {
   92|      6|      targetToUploader = strongSelf->_targetToUploader;
   93|      6|    }
   94|      6|  });
   95|      6|  return targetToUploader;
   96|      6|}
   97|       |
   98|      6|- (NSMutableDictionary<NSNumber *, id<GDTCORStorageProtocol>> *)targetToStorage {
   99|      6|  __block NSMutableDictionary<NSNumber *, id<GDTCORStorageProtocol>> *targetToStorage;
  100|      6|  __weak GDTCORRegistrar *weakSelf = self;
  101|      6|  dispatch_sync(_registrarQueue, ^{
  102|      6|    GDTCORRegistrar *strongSelf = weakSelf;
  103|      6|    if (strongSelf) {
  104|      6|      targetToStorage = strongSelf->_targetToStorage;
  105|      6|    }
  106|      6|  });
  107|      6|  return targetToStorage;
  108|      6|}
  109|       |
  110|       |#pragma mark - GDTCORLifecycleProtocol
  111|       |
  112|      0|- (void)appWillBackground:(nonnull GDTCORApplication *)app {
  113|      0|  NSArray<id<GDTCORUploader>> *uploaders = [self.targetToUploader allValues];
  114|      0|  for (id<GDTCORUploader> uploader in uploaders) {
  115|      0|    if ([uploader respondsToSelector:@selector(appWillBackground:)]) {
  116|      0|      [uploader appWillBackground:app];
  117|      0|    }
  118|      0|  }
  119|      0|  NSArray<id<GDTCORStorageProtocol>> *storages = [self.targetToStorage allValues];
  120|      0|  for (id<GDTCORStorageProtocol> storage in storages) {
  121|      0|    if ([storage respondsToSelector:@selector(appWillBackground:)]) {
  122|      0|      [storage appWillBackground:app];
  123|      0|    }
  124|      0|  }
  125|      0|}
  126|       |
  127|      1|- (void)appWillForeground:(nonnull GDTCORApplication *)app {
  128|      1|  NSArray<id<GDTCORUploader>> *uploaders = [self.targetToUploader allValues];
  129|      4|  for (id<GDTCORUploader> uploader in uploaders) {
  130|      4|    if ([uploader respondsToSelector:@selector(appWillForeground:)]) {
  131|      0|      [uploader appWillForeground:app];
  132|      0|    }
  133|      4|  }
  134|      1|  NSArray<id<GDTCORStorageProtocol>> *storages = [self.targetToStorage allValues];
  135|      5|  for (id<GDTCORStorageProtocol> storage in storages) {
  136|      5|    if ([storage respondsToSelector:@selector(appWillForeground:)]) {
  137|      0|      [storage appWillForeground:app];
  138|      0|    }
  139|      5|  }
  140|      1|}
  141|       |
  142|      0|- (void)appWillTerminate:(nonnull GDTCORApplication *)app {
  143|      0|  NSArray<id<GDTCORUploader>> *uploaders = [self.targetToUploader allValues];
  144|      0|  for (id<GDTCORUploader> uploader in uploaders) {
  145|      0|    if ([uploader respondsToSelector:@selector(appWillTerminate:)]) {
  146|      0|      [uploader appWillTerminate:app];
  147|      0|    }
  148|      0|  }
  149|      0|  NSArray<id<GDTCORStorageProtocol>> *storages = [self.targetToStorage allValues];
  150|      0|  for (id<GDTCORStorageProtocol> storage in storages) {
  151|      0|    if ([storage respondsToSelector:@selector(appWillTerminate:)]) {
  152|      0|      [storage appWillTerminate:app];
  153|      0|    }
  154|      0|  }
  155|      0|}
  156|       |
  157|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORStorageEventSelector.m:
    1|       |/*
    2|       | * Copyright 2020 Google LLC
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORStorageEventSelector.h"
   18|       |
   19|       |@implementation GDTCORStorageEventSelector
   20|       |
   21|      0|+ (instancetype)eventSelectorForTarget:(GDTCORTarget)target {
   22|      0|  return [[self alloc] initWithTarget:target eventIDs:nil mappingIDs:nil qosTiers:nil];
   23|      0|}
   24|       |
   25|       |- (instancetype)initWithTarget:(GDTCORTarget)target
   26|       |                      eventIDs:(nullable NSSet<NSString *> *)eventIDs
   27|       |                    mappingIDs:(nullable NSSet<NSString *> *)mappingIDs
   28|      0|                      qosTiers:(nullable NSSet<NSNumber *> *)qosTiers {
   29|      0|  self = [super init];
   30|      0|  if (self) {
   31|      0|    _selectedTarget = target;
   32|      0|    _selectedEventIDs = eventIDs;
   33|      0|    _selectedMappingIDs = mappingIDs;
   34|      0|    _selectedQosTiers = qosTiers;
   35|      0|  }
   36|      0|  return self;
   37|      0|}
   38|       |
   39|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORTransformer.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORTransformer.h"
   18|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORTransformer_Private.h"
   19|       |
   20|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORAssert.h"
   21|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORLifecycle.h"
   22|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORStorageProtocol.h"
   23|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORConsoleLogger.h"
   24|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCOREvent.h"
   25|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCOREventTransformer.h"
   26|       |
   27|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCOREvent_Private.h"
   28|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORRegistrar_Private.h"
   29|       |
   30|       |@implementation GDTCORTransformer
   31|       |
   32|      1|+ (instancetype)sharedInstance {
   33|      1|  static GDTCORTransformer *eventTransformer;
   34|      1|  static dispatch_once_t onceToken;
   35|      1|  dispatch_once(&onceToken, ^{
   36|      1|    eventTransformer = [[self alloc] init];
   37|      1|  });
   38|      1|  return eventTransformer;
   39|      1|}
   40|       |
   41|      1|- (instancetype)init {
   42|      1|  return [self initWithApplication:[GDTCORApplication sharedApplication]];
   43|      1|}
   44|       |
   45|      1|- (instancetype)initWithApplication:(id<GDTCORApplicationProtocol>)application {
   46|      1|  self = [super init];
   47|      1|  if (self) {
   48|      1|    _eventWritingQueue =
   49|      1|        dispatch_queue_create("com.google.GDTCORTransformer", DISPATCH_QUEUE_SERIAL);
   50|      1|    _application = application;
   51|      1|  }
   52|      1|  return self;
   53|      1|}
   54|       |
   55|       |- (void)transformEvent:(GDTCOREvent *)event
   56|       |      withTransformers:(NSArray<id<GDTCOREventTransformer>> *)transformers
   57|      0|            onComplete:(void (^_Nullable)(BOOL wasWritten, NSError *_Nullable error))completion {
   58|      0|  GDTCORAssert(event, @"You can't write a nil event");
   59|       |
   60|      0|  __block GDTCORBackgroundIdentifier bgID = GDTCORBackgroundIdentifierInvalid;
   61|      0|  __auto_type __weak weakApplication = self.application;
   62|      0|  bgID = [self.application beginBackgroundTaskWithName:@"GDTTransformer"
   63|      0|                                     expirationHandler:^{
   64|      0|                                       [weakApplication endBackgroundTask:bgID];
   65|      0|                                       bgID = GDTCORBackgroundIdentifierInvalid;
   66|      0|                                     }];
   67|       |
   68|      0|  __auto_type completionWrapper = ^(BOOL wasWritten, NSError *_Nullable error) {
   69|      0|    if (completion) {
   70|      0|      completion(wasWritten, error);
   71|      0|    }
   72|       |
   73|       |    // The work is done, cancel the background task if it's valid.
   74|      0|    [weakApplication endBackgroundTask:bgID];
   75|      0|    bgID = GDTCORBackgroundIdentifierInvalid;
   76|      0|  };
   77|       |
   78|      0|  dispatch_async(_eventWritingQueue, ^{
   79|      0|    GDTCOREvent *transformedEvent = event;
   80|      0|    for (id<GDTCOREventTransformer> transformer in transformers) {
   81|      0|      if ([transformer respondsToSelector:@selector(transformGDTEvent:)]) {
   82|      0|        GDTCORLogDebug(@"Applying a transformer to event %@", event);
   83|      0|        transformedEvent = [transformer transformGDTEvent:event];
   84|      0|        if (!transformedEvent) {
   85|      0|          completionWrapper(NO, nil);
   86|      0|          return;
   87|      0|        }
   88|      0|      } else {
   89|      0|        GDTCORLogError(GDTCORMCETransformerDoesntImplementTransform,
   90|      0|                       @"Transformer doesn't implement transformGDTEvent: %@", transformer);
   91|      0|        completionWrapper(NO, nil);
   92|      0|        return;
   93|      0|      }
   94|      0|    }
   95|       |
   96|      0|    id<GDTCORStorageProtocol> storage =
   97|      0|        [GDTCORRegistrar sharedInstance].targetToStorage[@(event.target)];
   98|       |
   99|      0|    [storage storeEvent:transformedEvent onComplete:completionWrapper];
  100|      0|  });
  101|      0|}
  102|       |
  103|       |#pragma mark - GDTCORLifecycleProtocol
  104|       |
  105|      0|- (void)appWillTerminate:(GDTCORApplication *)application {
  106|       |  // Flush the queue immediately.
  107|      0|  dispatch_sync(_eventWritingQueue, ^{
  108|      0|                });
  109|      0|}
  110|       |
  111|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORTransport.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORTransport.h"
   18|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORTransport_Private.h"
   19|       |
   20|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORAssert.h"
   21|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORClock.h"
   22|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCOREvent.h"
   23|       |
   24|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORTransformer.h"
   25|       |
   26|       |@implementation GDTCORTransport
   27|       |
   28|       |- (nullable instancetype)initWithMappingID:(NSString *)mappingID
   29|       |                              transformers:
   30|       |                                  (nullable NSArray<id<GDTCOREventTransformer>> *)transformers
   31|      0|                                    target:(GDTCORTarget)target {
   32|      0|  GDTCORAssert(mappingID.length > 0, @"A mapping ID cannot be nil or empty");
   33|      0|  GDTCORAssert(target > 0, @"A target cannot be negative or 0");
   34|      0|  if (mappingID == nil || mappingID.length == 0 || target <= 0) {
   35|      0|    return nil;
   36|      0|  }
   37|      0|  self = [super init];
   38|      0|  if (self) {
   39|      0|    _mappingID = mappingID;
   40|      0|    _transformers = transformers;
   41|      0|    _target = target;
   42|      0|    _transformerInstance = [GDTCORTransformer sharedInstance];
   43|      0|  }
   44|      0|  GDTCORLogDebug(@"Transport object created. mappingID:%@ transformers:%@ target:%ld", mappingID,
   45|      0|                 transformers, (long)target);
   46|      0|  return self;
   47|      0|}
   48|       |
   49|       |- (void)sendTelemetryEvent:(GDTCOREvent *)event
   50|       |                onComplete:
   51|      0|                    (void (^_Nullable)(BOOL wasWritten, NSError *_Nullable error))completion {
   52|      0|  event.qosTier = GDTCOREventQoSTelemetry;
   53|      0|  [self sendEvent:event onComplete:completion];
   54|      0|}
   55|       |
   56|       |- (void)sendDataEvent:(GDTCOREvent *)event
   57|      0|           onComplete:(void (^_Nullable)(BOOL wasWritten, NSError *_Nullable error))completion {
   58|      0|  GDTCORAssert(event.qosTier != GDTCOREventQoSTelemetry, @"Use -sendTelemetryEvent, please.");
   59|      0|  [self sendEvent:event onComplete:completion];
   60|      0|}
   61|       |
   62|      0|- (void)sendTelemetryEvent:(GDTCOREvent *)event {
   63|      0|  [self sendTelemetryEvent:event onComplete:nil];
   64|      0|}
   65|       |
   66|      0|- (void)sendDataEvent:(GDTCOREvent *)event {
   67|      0|  [self sendDataEvent:event onComplete:nil];
   68|      0|}
   69|       |
   70|      0|- (GDTCOREvent *)eventForTransport {
   71|      0|  return [[GDTCOREvent alloc] initWithMappingID:_mappingID target:_target];
   72|      0|}
   73|       |
   74|       |#pragma mark - Private helper methods
   75|       |
   76|       |/** Sends the given event through the transport pipeline.
   77|       | *
   78|       | * @param event The event to send.
   79|       | * @param completion A block that will be called when the event has been written or dropped.
   80|       | */
   81|       |- (void)sendEvent:(GDTCOREvent *)event
   82|      0|       onComplete:(void (^_Nullable)(BOOL wasWritten, NSError *_Nullable error))completion {
   83|       |  // TODO: Determine if sending an event before registration is allowed.
   84|      0|  GDTCORAssert(event, @"You can't send a nil event");
   85|      0|  GDTCOREvent *copiedEvent = [event copy];
   86|      0|  copiedEvent.clockSnapshot = [GDTCORClock snapshot];
   87|      0|  [self.transformerInstance transformEvent:copiedEvent
   88|      0|                          withTransformers:_transformers
   89|      0|                                onComplete:completion];
   90|      0|}
   91|       |
   92|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORUploadBatch.m:
    1|       |/*
    2|       | * Copyright 2020 Google LLC
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORUploadBatch.h"
   18|       |
   19|       |@implementation GDTCORUploadBatch
   20|       |
   21|      0|- (instancetype)initWithBatchID:(NSNumber *)batchID events:(NSSet<GDTCOREvent *> *)events {
   22|      0|  self = [super init];
   23|      0|  if (self) {
   24|      0|    _batchID = batchID;
   25|      0|    _events = events;
   26|      0|  }
   27|      0|  return self;
   28|      0|}
   29|       |
   30|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORUploadCoordinator.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORUploadCoordinator.h"
   18|       |
   19|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORAssert.h"
   20|       |#import "GoogleDataTransport/GDTCORLibrary/Internal/GDTCORReachability.h"
   21|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORClock.h"
   22|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORConsoleLogger.h"
   23|       |
   24|       |#import "GoogleDataTransport/GDTCORLibrary/Private/GDTCORRegistrar_Private.h"
   25|       |
   26|       |@implementation GDTCORUploadCoordinator
   27|       |
   28|      3|+ (instancetype)sharedInstance {
   29|      3|  static GDTCORUploadCoordinator *sharedUploader;
   30|      3|  static dispatch_once_t onceToken;
   31|      1|  dispatch_once(&onceToken, ^{
   32|      1|    sharedUploader = [[GDTCORUploadCoordinator alloc] init];
   33|      1|    [sharedUploader startTimer];
   34|      1|  });
   35|      3|  return sharedUploader;
   36|      3|}
   37|       |
   38|      1|- (instancetype)init {
   39|      1|  self = [super init];
   40|      1|  if (self) {
   41|      1|    _coordinationQueue =
   42|      1|        dispatch_queue_create("com.google.GDTCORUploadCoordinator", DISPATCH_QUEUE_SERIAL);
   43|      1|    _registrar = [GDTCORRegistrar sharedInstance];
   44|      1|    _timerInterval = 30 * NSEC_PER_SEC;
   45|      1|    _timerLeeway = 5 * NSEC_PER_SEC;
   46|      1|  }
   47|      1|  return self;
   48|      1|}
   49|       |
   50|      0|- (void)forceUploadForTarget:(GDTCORTarget)target {
   51|      0|  dispatch_async(_coordinationQueue, ^{
   52|      0|    GDTCORLogDebug(@"Forcing an upload of target %ld", (long)target);
   53|      0|    GDTCORUploadConditions conditions = [self uploadConditions];
   54|      0|    conditions |= GDTCORUploadConditionHighPriority;
   55|      0|    [self uploadTargets:@[ @(target) ] conditions:conditions];
   56|      0|  });
   57|      0|}
   58|       |
   59|       |#pragma mark - Private helper methods
   60|       |
   61|       |/** Starts a timer that checks whether or not events can be uploaded at regular intervals. It will
   62|       | * check the next-upload clocks of all targets to determine if an upload attempt can be made.
   63|       | */
   64|      2|- (void)startTimer {
   65|      2|  dispatch_async(_coordinationQueue, ^{
   66|      2|    if (self->_timer) {
   67|       |      // The timer has been already started.
   68|      1|      return;
   69|      1|    }
   70|       |
   71|       |    // Delay the timer slightly so it doesn't run while +load calls are still running.
   72|      1|    dispatch_time_t deadline = dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC / 2);
   73|       |
   74|      1|    self->_timer =
   75|      1|        dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, self->_coordinationQueue);
   76|      1|    dispatch_source_set_timer(self->_timer, deadline, self->_timerInterval, self->_timerLeeway);
   77|       |
   78|      1|    dispatch_source_set_event_handler(self->_timer, ^{
   79|      1|      if (![[GDTCORApplication sharedApplication] isRunningInBackground]) {
   80|      1|        GDTCORUploadConditions conditions = [self uploadConditions];
   81|      1|        GDTCORLogDebug(@"%@", @"Upload timer fired");
   82|      1|        [self uploadTargets:[self.registrar.targetToUploader allKeys] conditions:conditions];
   83|      1|      }
   84|      1|    });
   85|      1|    GDTCORLogDebug(@"%@", @"Upload timer started");
   86|      1|    dispatch_resume(self->_timer);
   87|      1|  });
   88|      2|}
   89|       |
   90|       |/** Stops the currently running timer. */
   91|      0|- (void)stopTimer {
   92|      0|  if (_timer) {
   93|      0|    dispatch_source_cancel(_timer);
   94|      0|    _timer = nil;
   95|      0|  }
   96|      0|}
   97|       |
   98|       |/** Triggers the uploader implementations for the given targets to upload.
   99|       | *
  100|       | * @param targets An array of targets to trigger.
  101|       | * @param conditions The set of upload conditions.
  102|       | */
  103|      1|- (void)uploadTargets:(NSArray<NSNumber *> *)targets conditions:(GDTCORUploadConditions)conditions {
  104|      1|  dispatch_async(_coordinationQueue, ^{
  105|       |    // TODO: The reachability signal may be not reliable enough to prevent an upload attempt.
  106|       |    // See https://developer.apple.com/videos/play/wwdc2019/712/ (49:40) for more details.
  107|      1|    if ((conditions & GDTCORUploadConditionNoNetwork) == GDTCORUploadConditionNoNetwork) {
  108|      0|      return;
  109|      0|    }
  110|      4|    for (NSNumber *target in targets) {
  111|      4|      id<GDTCORUploader> uploader = self->_registrar.targetToUploader[target];
  112|      4|      [uploader uploadTarget:target.intValue withConditions:conditions];
  113|      4|    }
  114|      1|  });
  115|      1|}
  116|       |
  117|      1|- (void)signalToStoragesToCheckExpirations {
  118|       |  // The same storage may be associated with several targets. Make sure to check for expirations
  119|       |  // only once per storage.
  120|      1|  NSSet<id<GDTCORStorageProtocol>> *storages =
  121|      1|      [NSSet setWithArray:[_registrar.targetToStorage allValues]];
  122|      1|  for (id<GDTCORStorageProtocol> storage in storages) {
  123|      1|    [storage checkForExpirations];
  124|      1|  }
  125|      1|}
  126|       |
  127|       |/** Returns the registered storage for the given NSNumber wrapped GDTCORTarget.
  128|       | *
  129|       | * @param target The NSNumber wrapping of a GDTCORTarget to find the storage instance of.
  130|       | * @return The storage instance for the given target.
  131|       | */
  132|      0|- (nullable id<GDTCORStorageProtocol>)storageForTarget:(NSNumber *)target {
  133|      0|  id<GDTCORStorageProtocol> storage = [GDTCORRegistrar sharedInstance].targetToStorage[target];
  134|      0|  GDTCORAssert(storage, @"A storage must be registered for target %@", target);
  135|      0|  return storage;
  136|      0|}
  137|       |
  138|       |/** Returns the current upload conditions after making determinations about the network connection.
  139|       | *
  140|       | * @return The current upload conditions.
  141|       | */
  142|      1|- (GDTCORUploadConditions)uploadConditions {
  143|      1|  GDTCORNetworkReachabilityFlags currentFlags = [GDTCORReachability currentFlags];
  144|      1|  BOOL networkConnected = GDTCORReachabilityFlagsReachable(currentFlags);
  145|      1|  if (!networkConnected) {
  146|      0|    return GDTCORUploadConditionNoNetwork;
  147|      0|  }
  148|      1|  BOOL isWWAN = GDTCORReachabilityFlagsContainWWAN(currentFlags);
  149|      1|  if (isWWAN) {
  150|      0|    return GDTCORUploadConditionMobileData;
  151|      1|  } else {
  152|      1|    return GDTCORUploadConditionWifiData;
  153|      1|  }
  154|      1|}
  155|       |
  156|       |#pragma mark - GDTCORLifecycleProtocol
  157|       |
  158|      1|- (void)appWillForeground:(GDTCORApplication *)app {
  159|       |  // -startTimer is thread-safe.
  160|      1|  [self startTimer];
  161|      1|  [self signalToStoragesToCheckExpirations];
  162|      1|}
  163|       |
  164|      0|- (void)appWillBackground:(GDTCORApplication *)app {
  165|      0|  dispatch_async(_coordinationQueue, ^{
  166|      0|    [self stopTimer];
  167|      0|  });
  168|      0|}
  169|       |
  170|      0|- (void)appWillTerminate:(GDTCORApplication *)application {
  171|      0|  dispatch_sync(_coordinationQueue, ^{
  172|      0|    [self stopTimer];
  173|      0|  });
  174|      0|}
  175|       |
  176|       |@end

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/Internal/GDTCORAssert.h:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |
   19|       |#import "GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORConsoleLogger.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |/** A block type that could be run instead of normal assertion logging. No return type, no params.
   24|       | */
   25|       |typedef void (^GDTCORAssertionBlock)(void);
   26|       |
   27|       |/** Returns the result of executing a soft-linked method present in unit tests that allows a block
   28|       | * to be run instead of normal assertion logging. This helps ameliorate issues with catching
   29|       | * exceptions that occur on a dispatch_queue.
   30|       | *
   31|       | * @return A block that can be run instead of normal assert printing.
   32|       | */
   33|       |FOUNDATION_EXPORT GDTCORAssertionBlock _Nullable GDTCORAssertionBlockToRunInstead(void);
   34|       |
   35|       |#if defined(NS_BLOCK_ASSERTIONS)
   36|       |
   37|       |#define GDTCORAssert(condition, ...) \
   38|       |  do {                               \
   39|       |  } while (0);
   40|       |
   41|       |#define GDTCORFatalAssert(condition, ...) \
   42|       |  do {                                    \
   43|       |  } while (0);
   44|       |
   45|       |#else  // defined(NS_BLOCK_ASSERTIONS)
   46|       |
   47|       |/** Asserts using a console log, unless a block was specified to be run instead.
   48|       | *
   49|       | * @param condition The condition you'd expect to be YES.
   50|       | */
   51|       |#define GDTCORAssert(condition, format, ...)                                     \
   52|     13|  do {                                                                           \
   53|     13|    __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS                                          \
   54|     13|    if (__builtin_expect(!(condition), 0)) {                                     \
   55|      0|      GDTCORAssertionBlock assertionBlock = GDTCORAssertionBlockToRunInstead();  \
   56|      0|      if (assertionBlock) {                                                      \
   57|      0|        assertionBlock();                                                        \
   58|      0|      } else {                                                                   \
   59|      0|        NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__];    \
   60|      0|        __assert_file__ = __assert_file__ ? __assert_file__ : @"<Unknown File>"; \
   61|      0|        GDTCORLogAssert(NO, __assert_file__, __LINE__, format, ##__VA_ARGS__);   \
   62|      0|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS                                       \
   63|      0|      }                                                                          \
   64|      0|    }                                                                            \
   65|     13|  } while (0);
   66|       |
   67|       |/** Asserts by logging to the console and throwing an exception if NS_BLOCK_ASSERTIONS is not
   68|       | * defined.
   69|       | *
   70|       | * @param condition The condition you'd expect to be YES.
   71|       | */
   72|       |#define GDTCORFatalAssert(condition, format, ...)                                          \
   73|      1|  do {                                                                                     \
   74|      1|    __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS                                                    \
   75|      1|    if (__builtin_expect(!(condition), 0)) {                                               \
   76|      0|      GDTCORAssertionBlock assertionBlock = GDTCORAssertionBlockToRunInstead();            \
   77|      0|      if (assertionBlock) {                                                                \
   78|      0|        assertionBlock();                                                                  \
   79|      0|      } else {                                                                             \
   80|      0|        NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__];              \
   81|      0|        __assert_file__ = __assert_file__ ? __assert_file__ : @"<Unknown File>";           \
   82|      0|        GDTCORLogAssert(YES, __assert_file__, __LINE__, format, ##__VA_ARGS__);            \
   83|      0|        [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd                    \
   84|      0|                                                            object:self                    \
   85|      0|                                                              file:__assert_file__         \
   86|      0|                                                        lineNumber:__LINE__                \
   87|      0|                                                       description:format, ##__VA_ARGS__]; \
   88|      0|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS                                                 \
   89|      0|      }                                                                                    \
   90|      0|    }                                                                                      \
   91|      1|  } while (0);
   92|       |
   93|       |#endif  // defined(NS_BLOCK_ASSERTIONS)
   94|       |
   95|       |NS_ASSUME_NONNULL_END

/Users/lenar/Desktop/LHypothesis/Example/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/Public/GoogleDataTransport/GDTCORConsoleLogger.h:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |
   19|       |/** The current logging level. This value and higher will be printed. Declared as volatile to make
   20|       | * getting and setting atomic.
   21|       | */
   22|       |FOUNDATION_EXPORT volatile NSInteger GDTCORConsoleLoggerLoggingLevel;
   23|       |
   24|       |/** A  list of logging levels that GDT supports. */
   25|       |typedef NS_ENUM(NSInteger, GDTCORLoggingLevel) {
   26|       |
   27|       |  /** Causes all logs to be printed. */
   28|       |  GDTCORLoggingLevelDebug = 1,
   29|       |
   30|       |  /** Causes all non-debug logs to be printed. */
   31|       |  GDTCORLoggingLevelVerbose = 2,
   32|       |
   33|       |  /** Causes warnings and errors to be printed. */
   34|       |  GDTCORLoggingLevelWarnings = 3,
   35|       |
   36|       |  /** Causes errors to be printed. This is the default value. */
   37|       |  GDTCORLoggingLevelErrors = 4
   38|       |};
   39|       |
   40|       |/** A list of message codes to print in the logger that help to correspond printed messages with
   41|       | * code locations.
   42|       | *
   43|       | * Prefixes:
   44|       | * - MCD => MessageCodeDebug
   45|       | * - MCW => MessageCodeWarning
   46|       | * - MCE => MessageCodeError
   47|       | */
   48|       |typedef NS_ENUM(NSInteger, GDTCORMessageCode) {
   49|       |
   50|       |  /** For debug logs. */
   51|       |  GDTCORMCDDebugLog = 0,
   52|       |
   53|       |  /** For warning messages concerning transportBytes: not being implemented by a data object. */
   54|       |  GDTCORMCWDataObjectMissingBytesImpl = 1,
   55|       |
   56|       |  /** For warning messages concerning a failed event upload. */
   57|       |  GDTCORMCWUploadFailed = 2,
   58|       |
   59|       |  /** For warning messages concerning a forced event upload. */
   60|       |  GDTCORMCWForcedUpload = 3,
   61|       |
   62|       |  /** For warning messages concerning a failed reachability call. */
   63|       |  GDTCORMCWReachabilityFailed = 4,
   64|       |
   65|       |  /** For warning messages concerning a database warning. */
   66|       |  GDTCORMCWDatabaseWarning = 5,
   67|       |
   68|       |  /** For warning messages concerning the reading of a event file. */
   69|       |  GDTCORMCWFileReadError = 6,
   70|       |
   71|       |  /** For error messages concerning transformGDTEvent: not being implemented by an event
   72|       |     transformer. */
   73|       |  GDTCORMCETransformerDoesntImplementTransform = 1000,
   74|       |
   75|       |  /** For error messages concerning the creation of a directory failing. */
   76|       |  GDTCORMCEDirectoryCreationError = 1001,
   77|       |
   78|       |  /** For error messages concerning the writing of a event file. */
   79|       |  GDTCORMCEFileWriteError = 1002,
   80|       |
   81|       |  /** For error messages concerning the lack of a prioritizer for a given backend. */
   82|       |  GDTCORMCEPrioritizerError = 1003,
   83|       |
   84|       |  /** For error messages concerning a package delivery API violation. */
   85|       |  GDTCORMCEDeliverTwice = 1004,
   86|       |
   87|       |  /** For error messages concerning an error in an implementation of -transportBytes. */
   88|       |  GDTCORMCETransportBytesError = 1005,
   89|       |
   90|       |  /** For general purpose error messages in a dependency. */
   91|       |  GDTCORMCEGeneralError = 1006,
   92|       |
   93|       |  /** For fatal errors. Please go to https://github.com/firebase/firebase-ios-sdk/issues and open
   94|       |   * an issue if you encounter an error with this code.
   95|       |   */
   96|       |  GDTCORMCEFatalAssertion = 1007,
   97|       |
   98|       |  /** For error messages concerning the reading of a event file. */
   99|       |  GDTCORMCEFileReadError = 1008,
  100|       |
  101|       |  /** For errors related to running sqlite. */
  102|       |  GDTCORMCEDatabaseError = 1009,
  103|       |};
  104|       |
  105|       |/** Prints the given code and format string to the console.
  106|       | *
  107|       | * @param code The message code describing the nature of the log.
  108|       | * @param logLevel The log level of this log.
  109|       | * @param format The format string.
  110|       | */
  111|       |FOUNDATION_EXPORT
  112|       |void GDTCORLog(GDTCORMessageCode code, GDTCORLoggingLevel logLevel, NSString *_Nonnull format, ...)
  113|       |    NS_FORMAT_FUNCTION(3, 4);
  114|       |
  115|       |/** Prints an assert log to the console.
  116|       | *
  117|       | * @param wasFatal Send YES if the assertion should be fatal, NO otherwise.
  118|       | * @param file The file in which the failure occurred.
  119|       | * @param line The line number of the failure.
  120|       | * @param format The format string.
  121|       | */
  122|       |FOUNDATION_EXPORT void GDTCORLogAssert(BOOL wasFatal,
  123|       |                                       NSString *_Nonnull file,
  124|       |                                       NSInteger line,
  125|       |                                       NSString *_Nullable format,
  126|       |                                       ...) NS_FORMAT_FUNCTION(4, 5);
  127|       |
  128|       |/** Returns the string that represents some message code.
  129|       | *
  130|       | * @param code The code to convert to a string.
  131|       | * @return The string representing the message code.
  132|       | */
  133|       |FOUNDATION_EXPORT NSString *_Nonnull GDTCORMessageCodeEnumToString(GDTCORMessageCode code);
  134|       |
  135|       |#define GDTCORLogDebug(MESSAGE_FORMAT, ...) \
  136|     58|  GDTCORLog(GDTCORMCDDebugLog, GDTCORLoggingLevelDebug, MESSAGE_FORMAT, __VA_ARGS__);
  137|       |
  138|       |// A define to wrap GULLogWarning with slightly more convenient usage.
  139|       |#define GDTCORLogWarning(MESSAGE_CODE, MESSAGE_FORMAT, ...) \
  140|      0|  GDTCORLog(MESSAGE_CODE, GDTCORLoggingLevelWarnings, MESSAGE_FORMAT, __VA_ARGS__);
  141|       |
  142|       |// A define to wrap GULLogError with slightly more convenient usage and a failing assert.
  143|       |#define GDTCORLogError(MESSAGE_CODE, MESSAGE_FORMAT, ...) \
  144|      0|  GDTCORLog(MESSAGE_CODE, GDTCORLoggingLevelErrors, MESSAGE_FORMAT, __VA_ARGS__);

/Users/lenar/Desktop/LHypothesis/Example/Pods/nanopb/pb.h:
    1|       |/* Common parts of the nanopb library. Most of these are quite low-level
    2|       | * stuff. For the high-level interface, see pb_encode.h and pb_decode.h.
    3|       | */
    4|       |
    5|       |#ifndef PB_H_INCLUDED
    6|       |#define PB_H_INCLUDED
    7|       |
    8|       |/*****************************************************************
    9|       | * Nanopb compilation time options. You can change these here by *
   10|       | * uncommenting the lines, or on the compiler command line.      *
   11|       | *****************************************************************/
   12|       |
   13|       |/* Enable support for dynamically allocated fields */
   14|       |/* #define PB_ENABLE_MALLOC 1 */
   15|       |
   16|       |/* Define this if your CPU / compiler combination does not support
   17|       | * unaligned memory access to packed structures. */
   18|       |/* #define PB_NO_PACKED_STRUCTS 1 */
   19|       |
   20|       |/* Increase the number of required fields that are tracked.
   21|       | * A compiler warning will tell if you need this. */
   22|       |/* #define PB_MAX_REQUIRED_FIELDS 256 */
   23|       |
   24|       |/* Add support for tag numbers > 255 and fields larger than 255 bytes. */
   25|       |/* #define PB_FIELD_16BIT 1 */
   26|       |
   27|       |/* Add support for tag numbers > 65536 and fields larger than 65536 bytes. */
   28|       |/* #define PB_FIELD_32BIT 1 */
   29|       |
   30|       |/* Disable support for error messages in order to save some code space. */
   31|       |/* #define PB_NO_ERRMSG 1 */
   32|       |
   33|       |/* Disable support for custom streams (support only memory buffers). */
   34|       |/* #define PB_BUFFER_ONLY 1 */
   35|       |
   36|       |/* Switch back to the old-style callback function signature.
   37|       | * This was the default until nanopb-0.2.1. */
   38|       |/* #define PB_OLD_CALLBACK_STYLE */
   39|       |
   40|       |
   41|       |/* Don't encode scalar arrays as packed. This is only to be used when
   42|       | * the decoder on the receiving side cannot process packed scalar arrays.
   43|       | * Such example is older protobuf.js. */
   44|       |/* #define PB_ENCODE_ARRAYS_UNPACKED 1 */
   45|       |
   46|       |/******************************************************************
   47|       | * You usually don't need to change anything below this line.     *
   48|       | * Feel free to look around and use the defined macros, though.   *
   49|       | ******************************************************************/
   50|       |
   51|       |
   52|       |/* Version of the nanopb library. Just in case you want to check it in
   53|       | * your own program. */
   54|       |#define NANOPB_VERSION nanopb-0.3.9.8
   55|       |
   56|       |/* Include all the system headers needed by nanopb. You will need the
   57|       | * definitions of the following:
   58|       | * - strlen, memcpy, memset functions
   59|       | * - [u]int_least8_t, uint_fast8_t, [u]int_least16_t, [u]int32_t, [u]int64_t
   60|       | * - size_t
   61|       | * - bool
   62|       | *
   63|       | * If you don't have the standard header files, you can instead provide
   64|       | * a custom header that defines or includes all this. In that case,
   65|       | * define PB_SYSTEM_HEADER to the path of this file.
   66|       | */
   67|       |#ifdef PB_SYSTEM_HEADER
   68|       |#include PB_SYSTEM_HEADER
   69|       |#else
   70|       |#include <stdint.h>
   71|       |#include <stddef.h>
   72|       |#include <stdbool.h>
   73|       |#include <string.h>
   74|       |
   75|       |#ifdef PB_ENABLE_MALLOC
   76|       |#include <stdlib.h>
   77|       |#endif
   78|       |#endif
   79|       |
   80|       |/* Macro for defining packed structures (compiler dependent).
   81|       | * This just reduces memory requirements, but is not required.
   82|       | */
   83|       |#if defined(PB_NO_PACKED_STRUCTS)
   84|       |    /* Disable struct packing */
   85|       |#   define PB_PACKED_STRUCT_START
   86|       |#   define PB_PACKED_STRUCT_END
   87|       |#   define pb_packed
   88|       |#elif defined(__GNUC__) || defined(__clang__)
   89|       |    /* For GCC and clang */
   90|       |#   define PB_PACKED_STRUCT_START
   91|       |#   define PB_PACKED_STRUCT_END
   92|       |#   define pb_packed __attribute__((packed))
   93|       |#elif defined(__ICCARM__) || defined(__CC_ARM)
   94|       |    /* For IAR ARM and Keil MDK-ARM compilers */
   95|       |#   define PB_PACKED_STRUCT_START _Pragma("pack(push, 1)")
   96|       |#   define PB_PACKED_STRUCT_END _Pragma("pack(pop)")
   97|       |#   define pb_packed
   98|       |#elif defined(_MSC_VER) && (_MSC_VER >= 1500)
   99|       |    /* For Microsoft Visual C++ */
  100|       |#   define PB_PACKED_STRUCT_START __pragma(pack(push, 1))
  101|       |#   define PB_PACKED_STRUCT_END __pragma(pack(pop))
  102|       |#   define pb_packed
  103|       |#else
  104|       |    /* Unknown compiler */
  105|       |#   define PB_PACKED_STRUCT_START
  106|       |#   define PB_PACKED_STRUCT_END
  107|       |#   define pb_packed
  108|       |#endif
  109|       |
  110|       |/* Handly macro for suppressing unreferenced-parameter compiler warnings. */
  111|       |#ifndef PB_UNUSED
  112|       |#define PB_UNUSED(x) (void)(x)
  113|       |#endif
  114|       |
  115|       |/* Compile-time assertion, used for checking compatible compilation options.
  116|       | * If this does not work properly on your compiler, use
  117|       | * #define PB_NO_STATIC_ASSERT to disable it.
  118|       | *
  119|       | * But before doing that, check carefully the error message / place where it
  120|       | * comes from to see if the error has a real cause. Unfortunately the error
  121|       | * message is not always very clear to read, but you can see the reason better
  122|       | * in the place where the PB_STATIC_ASSERT macro was called.
  123|       | */
  124|       |#ifndef PB_NO_STATIC_ASSERT
  125|       |#ifndef PB_STATIC_ASSERT
  126|       |#define PB_STATIC_ASSERT(COND,MSG) typedef char PB_STATIC_ASSERT_MSG(MSG, __LINE__, __COUNTER__)[(COND)?1:-1];
  127|       |#define PB_STATIC_ASSERT_MSG(MSG, LINE, COUNTER) PB_STATIC_ASSERT_MSG_(MSG, LINE, COUNTER)
  128|       |#define PB_STATIC_ASSERT_MSG_(MSG, LINE, COUNTER) pb_static_assertion_##MSG##LINE##COUNTER
  129|       |#endif
  130|       |#else
  131|       |#define PB_STATIC_ASSERT(COND,MSG)
  132|       |#endif
  133|       |
  134|       |/* Number of required fields to keep track of. */
  135|       |#ifndef PB_MAX_REQUIRED_FIELDS
  136|       |#define PB_MAX_REQUIRED_FIELDS 64
  137|       |#endif
  138|       |
  139|       |#if PB_MAX_REQUIRED_FIELDS < 64
  140|       |#error You should not lower PB_MAX_REQUIRED_FIELDS from the default value (64).
  141|       |#endif
  142|       |
  143|       |/* List of possible field types. These are used in the autogenerated code.
  144|       | * Least-significant 4 bits tell the scalar type
  145|       | * Most-significant 4 bits specify repeated/required/packed etc.
  146|       | */
  147|       |
  148|       |typedef uint_least8_t pb_type_t;
  149|       |
  150|       |/**** Field data types ****/
  151|       |
  152|       |/* Numeric types */
  153|       |#define PB_LTYPE_BOOL    0x00 /* bool */
  154|       |#define PB_LTYPE_VARINT  0x01 /* int32, int64, enum, bool */
  155|       |#define PB_LTYPE_UVARINT 0x02 /* uint32, uint64 */
  156|       |#define PB_LTYPE_SVARINT 0x03 /* sint32, sint64 */
  157|       |#define PB_LTYPE_FIXED32 0x04 /* fixed32, sfixed32, float */
  158|       |#define PB_LTYPE_FIXED64 0x05 /* fixed64, sfixed64, double */
  159|       |
  160|       |/* Marker for last packable field type. */
  161|       |#define PB_LTYPE_LAST_PACKABLE 0x05
  162|       |
  163|       |/* Byte array with pre-allocated buffer.
  164|       | * data_size is the length of the allocated PB_BYTES_ARRAY structure. */
  165|       |#define PB_LTYPE_BYTES 0x06
  166|       |
  167|       |/* String with pre-allocated buffer.
  168|       | * data_size is the maximum length. */
  169|       |#define PB_LTYPE_STRING 0x07
  170|       |
  171|       |/* Submessage
  172|       | * submsg_fields is pointer to field descriptions */
  173|       |#define PB_LTYPE_SUBMESSAGE 0x08
  174|       |
  175|       |/* Extension pseudo-field
  176|       | * The field contains a pointer to pb_extension_t */
  177|       |#define PB_LTYPE_EXTENSION 0x09
  178|       |
  179|       |/* Byte array with inline, pre-allocated byffer.
  180|       | * data_size is the length of the inline, allocated buffer.
  181|       | * This differs from PB_LTYPE_BYTES by defining the element as
  182|       | * pb_byte_t[data_size] rather than pb_bytes_array_t. */
  183|       |#define PB_LTYPE_FIXED_LENGTH_BYTES 0x0A
  184|       |
  185|       |/* Number of declared LTYPES */
  186|       |#define PB_LTYPES_COUNT 0x0B
  187|       |#define PB_LTYPE_MASK 0x0F
  188|       |
  189|       |/**** Field repetition rules ****/
  190|       |
  191|       |#define PB_HTYPE_REQUIRED 0x00
  192|       |#define PB_HTYPE_OPTIONAL 0x10
  193|       |#define PB_HTYPE_REPEATED 0x20
  194|       |#define PB_HTYPE_ONEOF    0x30
  195|       |#define PB_HTYPE_MASK     0x30
  196|       |
  197|       |/**** Field allocation types ****/
  198|       | 
  199|       |#define PB_ATYPE_STATIC   0x00
  200|       |#define PB_ATYPE_POINTER  0x80
  201|       |#define PB_ATYPE_CALLBACK 0x40
  202|       |#define PB_ATYPE_MASK     0xC0
  203|       |
  204|       |#define PB_ATYPE(x) ((x) & PB_ATYPE_MASK)
  205|       |#define PB_HTYPE(x) ((x) & PB_HTYPE_MASK)
  206|       |#define PB_LTYPE(x) ((x) & PB_LTYPE_MASK)
  207|       |
  208|       |/* Data type used for storing sizes of struct fields
  209|       | * and array counts.
  210|       | */
  211|       |#if defined(PB_FIELD_32BIT)
  212|       |    typedef uint32_t pb_size_t;
  213|       |    typedef int32_t pb_ssize_t;
  214|       |#elif defined(PB_FIELD_16BIT)
  215|       |    typedef uint_least16_t pb_size_t;
  216|       |    typedef int_least16_t pb_ssize_t;
  217|       |#else
  218|       |    typedef uint_least8_t pb_size_t;
  219|       |    typedef int_least8_t pb_ssize_t;
  220|       |#endif
  221|       |#define PB_SIZE_MAX ((pb_size_t)-1)
  222|       |
  223|       |/* Data type for storing encoded data and other byte streams.
  224|       | * This typedef exists to support platforms where uint8_t does not exist.
  225|       | * You can regard it as equivalent on uint8_t on other platforms.
  226|       | */
  227|       |typedef uint_least8_t pb_byte_t;
  228|       |
  229|       |/* This structure is used in auto-generated constants
  230|       | * to specify struct fields.
  231|       | * You can change field sizes if you need structures
  232|       | * larger than 256 bytes or field tags larger than 256.
  233|       | * The compiler should complain if your .proto has such
  234|       | * structures. Fix that by defining PB_FIELD_16BIT or
  235|       | * PB_FIELD_32BIT.
  236|       | */
  237|       |PB_PACKED_STRUCT_START
  238|       |typedef struct pb_field_s pb_field_t;
  239|       |struct pb_field_s {
  240|       |    pb_size_t tag;
  241|       |    pb_type_t type;
  242|       |    pb_size_t data_offset; /* Offset of field data, relative to previous field. */
  243|       |    pb_ssize_t size_offset; /* Offset of array size or has-boolean, relative to data */
  244|       |    pb_size_t data_size; /* Data size in bytes for a single item */
  245|       |    pb_size_t array_size; /* Maximum number of entries in array */
  246|       |    
  247|       |    /* Field definitions for submessage
  248|       |     * OR default value for all other non-array, non-callback types
  249|       |     * If null, then field will zeroed. */
  250|       |    const void *ptr;
  251|       |} pb_packed;
  252|       |PB_PACKED_STRUCT_END
  253|       |
  254|       |/* Make sure that the standard integer types are of the expected sizes.
  255|       | * Otherwise fixed32/fixed64 fields can break.
  256|       | *
  257|       | * If you get errors here, it probably means that your stdint.h is not
  258|       | * correct for your platform.
  259|       | */
  260|       |#ifndef PB_WITHOUT_64BIT
  261|       |PB_STATIC_ASSERT(sizeof(int64_t) == 2 * sizeof(int32_t), INT64_T_WRONG_SIZE)
  262|       |PB_STATIC_ASSERT(sizeof(uint64_t) == 2 * sizeof(uint32_t), UINT64_T_WRONG_SIZE)
  263|       |#endif
  264|       |
  265|       |/* This structure is used for 'bytes' arrays.
  266|       | * It has the number of bytes in the beginning, and after that an array.
  267|       | * Note that actual structs used will have a different length of bytes array.
  268|       | */
  269|       |#define PB_BYTES_ARRAY_T(n) struct { pb_size_t size; pb_byte_t bytes[n]; }
  270|      0|#define PB_BYTES_ARRAY_T_ALLOCSIZE(n) ((size_t)n + offsetof(pb_bytes_array_t, bytes))
  271|       |
  272|       |struct pb_bytes_array_s {
  273|       |    pb_size_t size;
  274|       |    pb_byte_t bytes[1];
  275|       |};
  276|       |typedef struct pb_bytes_array_s pb_bytes_array_t;
  277|       |
  278|       |/* This structure is used for giving the callback function.
  279|       | * It is stored in the message structure and filled in by the method that
  280|       | * calls pb_decode.
  281|       | *
  282|       | * The decoding callback will be given a limited-length stream
  283|       | * If the wire type was string, the length is the length of the string.
  284|       | * If the wire type was a varint/fixed32/fixed64, the length is the length
  285|       | * of the actual value.
  286|       | * The function may be called multiple times (especially for repeated types,
  287|       | * but also otherwise if the message happens to contain the field multiple
  288|       | * times.)
  289|       | *
  290|       | * The encoding callback will receive the actual output stream.
  291|       | * It should write all the data in one call, including the field tag and
  292|       | * wire type. It can write multiple fields.
  293|       | *
  294|       | * The callback can be null if you want to skip a field.
  295|       | */
  296|       |typedef struct pb_istream_s pb_istream_t;
  297|       |typedef struct pb_ostream_s pb_ostream_t;
  298|       |typedef struct pb_callback_s pb_callback_t;
  299|       |struct pb_callback_s {
  300|       |#ifdef PB_OLD_CALLBACK_STYLE
  301|       |    /* Deprecated since nanopb-0.2.1 */
  302|       |    union {
  303|       |        bool (*decode)(pb_istream_t *stream, const pb_field_t *field, void *arg);
  304|       |        bool (*encode)(pb_ostream_t *stream, const pb_field_t *field, const void *arg);
  305|       |    } funcs;
  306|       |#else
  307|       |    /* New function signature, which allows modifying arg contents in callback. */
  308|       |    union {
  309|       |        bool (*decode)(pb_istream_t *stream, const pb_field_t *field, void **arg);
  310|       |        bool (*encode)(pb_ostream_t *stream, const pb_field_t *field, void * const *arg);
  311|       |    } funcs;
  312|       |#endif    
  313|       |    
  314|       |    /* Free arg for use by callback */
  315|       |    void *arg;
  316|       |};
  317|       |
  318|       |/* Wire types. Library user needs these only in encoder callbacks. */
  319|       |typedef enum {
  320|       |    PB_WT_VARINT = 0,
  321|       |    PB_WT_64BIT  = 1,
  322|       |    PB_WT_STRING = 2,
  323|       |    PB_WT_32BIT  = 5
  324|       |} pb_wire_type_t;
  325|       |
  326|       |/* Structure for defining the handling of unknown/extension fields.
  327|       | * Usually the pb_extension_type_t structure is automatically generated,
  328|       | * while the pb_extension_t structure is created by the user. However,
  329|       | * if you want to catch all unknown fields, you can also create a custom
  330|       | * pb_extension_type_t with your own callback.
  331|       | */
  332|       |typedef struct pb_extension_type_s pb_extension_type_t;
  333|       |typedef struct pb_extension_s pb_extension_t;
  334|       |struct pb_extension_type_s {
  335|       |    /* Called for each unknown field in the message.
  336|       |     * If you handle the field, read off all of its data and return true.
  337|       |     * If you do not handle the field, do not read anything and return true.
  338|       |     * If you run into an error, return false.
  339|       |     * Set to NULL for default handler.
  340|       |     */
  341|       |    bool (*decode)(pb_istream_t *stream, pb_extension_t *extension,
  342|       |                   uint32_t tag, pb_wire_type_t wire_type);
  343|       |    
  344|       |    /* Called once after all regular fields have been encoded.
  345|       |     * If you have something to write, do so and return true.
  346|       |     * If you do not have anything to write, just return true.
  347|       |     * If you run into an error, return false.
  348|       |     * Set to NULL for default handler.
  349|       |     */
  350|       |    bool (*encode)(pb_ostream_t *stream, const pb_extension_t *extension);
  351|       |    
  352|       |    /* Free field for use by the callback. */
  353|       |    const void *arg;
  354|       |};
  355|       |
  356|       |struct pb_extension_s {
  357|       |    /* Type describing the extension field. Usually you'll initialize
  358|       |     * this to a pointer to the automatically generated structure. */
  359|       |    const pb_extension_type_t *type;
  360|       |    
  361|       |    /* Destination for the decoded data. This must match the datatype
  362|       |     * of the extension field. */
  363|       |    void *dest;
  364|       |    
  365|       |    /* Pointer to the next extension handler, or NULL.
  366|       |     * If this extension does not match a field, the next handler is
  367|       |     * automatically called. */
  368|       |    pb_extension_t *next;
  369|       |
  370|       |    /* The decoder sets this to true if the extension was found.
  371|       |     * Ignored for encoding. */
  372|       |    bool found;
  373|       |};
  374|       |
  375|       |/* Memory allocation functions to use. You can define pb_realloc and
  376|       | * pb_free to custom functions if you want. */
  377|       |#ifdef PB_ENABLE_MALLOC
  378|       |#   ifndef pb_realloc
  379|       |#       define pb_realloc(ptr, size) realloc(ptr, size)
  380|       |#   endif
  381|       |#   ifndef pb_free
  382|       |#       define pb_free(ptr) free(ptr)
  383|       |#   endif
  384|       |#endif
  385|       |
  386|       |/* This is used to inform about need to regenerate .pb.h/.pb.c files. */
  387|       |#define PB_PROTO_HEADER_VERSION 30
  388|       |
  389|       |/* These macros are used to declare pb_field_t's in the constant array. */
  390|       |/* Size of a structure member, in bytes. */
  391|       |#define pb_membersize(st, m) (sizeof ((st*)0)->m)
  392|       |/* Number of entries in an array. */
  393|       |#define pb_arraysize(st, m) (pb_membersize(st, m) / pb_membersize(st, m[0]))
  394|       |/* Delta from start of one member to the start of another member. */
  395|       |#define pb_delta(st, m1, m2) ((int)offsetof(st, m1) - (int)offsetof(st, m2))
  396|       |/* Marks the end of the field list */
  397|       |#define PB_LAST_FIELD {0,(pb_type_t) 0,0,0,0,0,0}
  398|       |
  399|       |/* Macros for filling in the data_offset field */
  400|       |/* data_offset for first field in a message */
  401|       |#define PB_DATAOFFSET_FIRST(st, m1, m2) (offsetof(st, m1))
  402|       |/* data_offset for subsequent fields */
  403|       |#define PB_DATAOFFSET_OTHER(st, m1, m2) (offsetof(st, m1) - offsetof(st, m2) - pb_membersize(st, m2))
  404|       |/* data offset for subsequent fields inside an union (oneof) */
  405|       |#define PB_DATAOFFSET_UNION(st, m1, m2) (PB_SIZE_MAX)
  406|       |/* Choose first/other based on m1 == m2 (deprecated, remains for backwards compatibility) */
  407|       |#define PB_DATAOFFSET_CHOOSE(st, m1, m2) (int)(offsetof(st, m1) == offsetof(st, m2) \
  408|       |                                  ? PB_DATAOFFSET_FIRST(st, m1, m2) \
  409|       |                                  : PB_DATAOFFSET_OTHER(st, m1, m2))
  410|       |
  411|       |/* Required fields are the simplest. They just have delta (padding) from
  412|       | * previous field end, and the size of the field. Pointer is used for
  413|       | * submessages and default values.
  414|       | */
  415|       |#define PB_REQUIRED_STATIC(tag, st, m, fd, ltype, ptr) \
  416|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_REQUIRED | ltype, \
  417|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  418|       |
  419|       |/* Optional fields add the delta to the has_ variable. */
  420|       |#define PB_OPTIONAL_STATIC(tag, st, m, fd, ltype, ptr) \
  421|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_OPTIONAL | ltype, \
  422|       |    fd, \
  423|       |    pb_delta(st, has_ ## m, m), \
  424|       |    pb_membersize(st, m), 0, ptr}
  425|       |
  426|       |#define PB_SINGULAR_STATIC(tag, st, m, fd, ltype, ptr) \
  427|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_OPTIONAL | ltype, \
  428|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  429|       |
  430|       |/* Repeated fields have a _count field and also the maximum number of entries. */
  431|       |#define PB_REPEATED_STATIC(tag, st, m, fd, ltype, ptr) \
  432|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_REPEATED | ltype, \
  433|       |    fd, \
  434|       |    pb_delta(st, m ## _count, m), \
  435|       |    pb_membersize(st, m[0]), \
  436|       |    pb_arraysize(st, m), ptr}
  437|       |
  438|       |/* Allocated fields carry the size of the actual data, not the pointer */
  439|       |#define PB_REQUIRED_POINTER(tag, st, m, fd, ltype, ptr) \
  440|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_REQUIRED | ltype, \
  441|       |    fd, 0, pb_membersize(st, m[0]), 0, ptr}
  442|       |
  443|       |/* Optional fields don't need a has_ variable, as information would be redundant */
  444|       |#define PB_OPTIONAL_POINTER(tag, st, m, fd, ltype, ptr) \
  445|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_OPTIONAL | ltype, \
  446|       |    fd, 0, pb_membersize(st, m[0]), 0, ptr}
  447|       |
  448|       |/* Same as optional fields*/
  449|       |#define PB_SINGULAR_POINTER(tag, st, m, fd, ltype, ptr) \
  450|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_OPTIONAL | ltype, \
  451|       |    fd, 0, pb_membersize(st, m[0]), 0, ptr}
  452|       |
  453|       |/* Repeated fields have a _count field and a pointer to array of pointers */
  454|       |#define PB_REPEATED_POINTER(tag, st, m, fd, ltype, ptr) \
  455|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_REPEATED | ltype, \
  456|       |    fd, pb_delta(st, m ## _count, m), \
  457|       |    pb_membersize(st, m[0]), 0, ptr}
  458|       |
  459|       |/* Callbacks are much like required fields except with special datatype. */
  460|       |#define PB_REQUIRED_CALLBACK(tag, st, m, fd, ltype, ptr) \
  461|       |    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_REQUIRED | ltype, \
  462|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  463|       |
  464|       |#define PB_OPTIONAL_CALLBACK(tag, st, m, fd, ltype, ptr) \
  465|       |    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_OPTIONAL | ltype, \
  466|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  467|       |
  468|       |#define PB_SINGULAR_CALLBACK(tag, st, m, fd, ltype, ptr) \
  469|       |    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_OPTIONAL | ltype, \
  470|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  471|       |    
  472|       |#define PB_REPEATED_CALLBACK(tag, st, m, fd, ltype, ptr) \
  473|       |    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_REPEATED | ltype, \
  474|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  475|       |
  476|       |/* Optional extensions don't have the has_ field, as that would be redundant.
  477|       | * Furthermore, the combination of OPTIONAL without has_ field is used
  478|       | * for indicating proto3 style fields. Extensions exist in proto2 mode only,
  479|       | * so they should be encoded according to proto2 rules. To avoid the conflict,
  480|       | * extensions are marked as REQUIRED instead.
  481|       | */
  482|       |#define PB_OPTEXT_STATIC(tag, st, m, fd, ltype, ptr) \
  483|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_REQUIRED | ltype, \
  484|       |    0, \
  485|       |    0, \
  486|       |    pb_membersize(st, m), 0, ptr}
  487|       |
  488|       |#define PB_OPTEXT_POINTER(tag, st, m, fd, ltype, ptr) \
  489|       |    PB_OPTIONAL_POINTER(tag, st, m, fd, ltype, ptr)
  490|       |
  491|       |#define PB_OPTEXT_CALLBACK(tag, st, m, fd, ltype, ptr) \
  492|       |    PB_OPTIONAL_CALLBACK(tag, st, m, fd, ltype, ptr)
  493|       |
  494|       |/* The mapping from protobuf types to LTYPEs is done using these macros. */
  495|       |#define PB_LTYPE_MAP_BOOL               PB_LTYPE_BOOL
  496|       |#define PB_LTYPE_MAP_BYTES              PB_LTYPE_BYTES
  497|       |#define PB_LTYPE_MAP_DOUBLE             PB_LTYPE_FIXED64
  498|       |#define PB_LTYPE_MAP_ENUM               PB_LTYPE_VARINT
  499|       |#define PB_LTYPE_MAP_UENUM              PB_LTYPE_UVARINT
  500|       |#define PB_LTYPE_MAP_FIXED32            PB_LTYPE_FIXED32
  501|       |#define PB_LTYPE_MAP_FIXED64            PB_LTYPE_FIXED64
  502|       |#define PB_LTYPE_MAP_FLOAT              PB_LTYPE_FIXED32
  503|       |#define PB_LTYPE_MAP_INT32              PB_LTYPE_VARINT
  504|       |#define PB_LTYPE_MAP_INT64              PB_LTYPE_VARINT
  505|       |#define PB_LTYPE_MAP_MESSAGE            PB_LTYPE_SUBMESSAGE
  506|       |#define PB_LTYPE_MAP_SFIXED32           PB_LTYPE_FIXED32
  507|       |#define PB_LTYPE_MAP_SFIXED64           PB_LTYPE_FIXED64
  508|       |#define PB_LTYPE_MAP_SINT32             PB_LTYPE_SVARINT
  509|       |#define PB_LTYPE_MAP_SINT64             PB_LTYPE_SVARINT
  510|       |#define PB_LTYPE_MAP_STRING             PB_LTYPE_STRING
  511|       |#define PB_LTYPE_MAP_UINT32             PB_LTYPE_UVARINT
  512|       |#define PB_LTYPE_MAP_UINT64             PB_LTYPE_UVARINT
  513|       |#define PB_LTYPE_MAP_EXTENSION          PB_LTYPE_EXTENSION
  514|       |#define PB_LTYPE_MAP_FIXED_LENGTH_BYTES PB_LTYPE_FIXED_LENGTH_BYTES
  515|       |
  516|       |/* This is the actual macro used in field descriptions.
  517|       | * It takes these arguments:
  518|       | * - Field tag number
  519|       | * - Field type:   BOOL, BYTES, DOUBLE, ENUM, UENUM, FIXED32, FIXED64,
  520|       | *                 FLOAT, INT32, INT64, MESSAGE, SFIXED32, SFIXED64
  521|       | *                 SINT32, SINT64, STRING, UINT32, UINT64 or EXTENSION
  522|       | * - Field rules:  REQUIRED, OPTIONAL or REPEATED
  523|       | * - Allocation:   STATIC, CALLBACK or POINTER
  524|       | * - Placement: FIRST or OTHER, depending on if this is the first field in structure.
  525|       | * - Message name
  526|       | * - Field name
  527|       | * - Previous field name (or field name again for first field)
  528|       | * - Pointer to default value or submsg fields.
  529|       | */
  530|       |
  531|       |#define PB_FIELD(tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
  532|       |        PB_ ## rules ## _ ## allocation(tag, message, field, \
  533|       |        PB_DATAOFFSET_ ## placement(message, field, prevfield), \
  534|       |        PB_LTYPE_MAP_ ## type, ptr)
  535|       |
  536|       |/* Field description for repeated static fixed count fields.*/
  537|       |#define PB_REPEATED_FIXED_COUNT(tag, type, placement, message, field, prevfield, ptr) \
  538|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_REPEATED | PB_LTYPE_MAP_ ## type, \
  539|       |    PB_DATAOFFSET_ ## placement(message, field, prevfield), \
  540|       |    0, \
  541|       |    pb_membersize(message, field[0]), \
  542|       |    pb_arraysize(message, field), ptr}
  543|       |
  544|       |/* Field description for oneof fields. This requires taking into account the
  545|       | * union name also, that's why a separate set of macros is needed.
  546|       | */
  547|       |#define PB_ONEOF_STATIC(u, tag, st, m, fd, ltype, ptr) \
  548|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_ONEOF | ltype, \
  549|       |    fd, pb_delta(st, which_ ## u, u.m), \
  550|       |    pb_membersize(st, u.m), 0, ptr}
  551|       |
  552|       |#define PB_ONEOF_POINTER(u, tag, st, m, fd, ltype, ptr) \
  553|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_ONEOF | ltype, \
  554|       |    fd, pb_delta(st, which_ ## u, u.m), \
  555|       |    pb_membersize(st, u.m[0]), 0, ptr}
  556|       |
  557|       |#define PB_ONEOF_FIELD(union_name, tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
  558|       |        PB_ONEOF_ ## allocation(union_name, tag, message, field, \
  559|       |        PB_DATAOFFSET_ ## placement(message, union_name.field, prevfield), \
  560|       |        PB_LTYPE_MAP_ ## type, ptr)
  561|       |
  562|       |#define PB_ANONYMOUS_ONEOF_STATIC(u, tag, st, m, fd, ltype, ptr) \
  563|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_ONEOF | ltype, \
  564|       |    fd, pb_delta(st, which_ ## u, m), \
  565|       |    pb_membersize(st, m), 0, ptr}
  566|       |
  567|       |#define PB_ANONYMOUS_ONEOF_POINTER(u, tag, st, m, fd, ltype, ptr) \
  568|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_ONEOF | ltype, \
  569|       |    fd, pb_delta(st, which_ ## u, m), \
  570|       |    pb_membersize(st, m[0]), 0, ptr}
  571|       |
  572|       |#define PB_ANONYMOUS_ONEOF_FIELD(union_name, tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
  573|       |        PB_ANONYMOUS_ONEOF_ ## allocation(union_name, tag, message, field, \
  574|       |        PB_DATAOFFSET_ ## placement(message, field, prevfield), \
  575|       |        PB_LTYPE_MAP_ ## type, ptr)
  576|       |
  577|       |/* These macros are used for giving out error messages.
  578|       | * They are mostly a debugging aid; the main error information
  579|       | * is the true/false return value from functions.
  580|       | * Some code space can be saved by disabling the error
  581|       | * messages if not used.
  582|       | *
  583|       | * PB_SET_ERROR() sets the error message if none has been set yet.
  584|       | *                msg must be a constant string literal.
  585|       | * PB_GET_ERROR() always returns a pointer to a string.
  586|       | * PB_RETURN_ERROR() sets the error and returns false from current
  587|       | *                   function.
  588|       | */
  589|       |#ifdef PB_NO_ERRMSG
  590|       |#define PB_SET_ERROR(stream, msg) PB_UNUSED(stream)
  591|       |#define PB_GET_ERROR(stream) "(errmsg disabled)"
  592|       |#else
  593|       |#define PB_SET_ERROR(stream, msg) (stream->errmsg = (stream)->errmsg ? (stream)->errmsg : (msg))
  594|      0|#define PB_GET_ERROR(stream) ((stream)->errmsg ? (stream)->errmsg : "(none)")
  595|       |#endif
  596|       |
  597|       |#define PB_RETURN_ERROR(stream, msg) return PB_SET_ERROR(stream, msg), false
  598|       |
  599|       |#endif

/Users/lenar/Desktop/LHypothesis/Example/Pods/nanopb/pb_encode.h:
    1|       |/* pb_encode.h: Functions to encode protocol buffers. Depends on pb_encode.c.
    2|       | * The main function is pb_encode. You also need an output stream, and the
    3|       | * field descriptions created by nanopb_generator.py.
    4|       | */
    5|       |
    6|       |#ifndef PB_ENCODE_H_INCLUDED
    7|       |#define PB_ENCODE_H_INCLUDED
    8|       |
    9|       |#include "pb.h"
   10|       |
   11|       |#ifdef __cplusplus
   12|       |extern "C" {
   13|       |#endif
   14|       |
   15|       |/* Structure for defining custom output streams. You will need to provide
   16|       | * a callback function to write the bytes to your storage, which can be
   17|       | * for example a file or a network socket.
   18|       | *
   19|       | * The callback must conform to these rules:
   20|       | *
   21|       | * 1) Return false on IO errors. This will cause encoding to abort.
   22|       | * 2) You can use state to store your own data (e.g. buffer pointer).
   23|       | * 3) pb_write will update bytes_written after your callback runs.
   24|       | * 4) Substreams will modify max_size and bytes_written. Don't use them
   25|       | *    to calculate any pointers.
   26|       | */
   27|       |struct pb_ostream_s
   28|       |{
   29|       |#ifdef PB_BUFFER_ONLY
   30|       |    /* Callback pointer is not used in buffer-only configuration.
   31|       |     * Having an int pointer here allows binary compatibility but
   32|       |     * gives an error if someone tries to assign callback function.
   33|       |     * Also, NULL pointer marks a 'sizing stream' that does not
   34|       |     * write anything.
   35|       |     */
   36|       |    int *callback;
   37|       |#else
   38|       |    bool (*callback)(pb_ostream_t *stream, const pb_byte_t *buf, size_t count);
   39|       |#endif
   40|       |    void *state;          /* Free field for use by callback implementation. */
   41|       |    size_t max_size;      /* Limit number of output bytes written (or use SIZE_MAX). */
   42|       |    size_t bytes_written; /* Number of bytes written so far. */
   43|       |    
   44|       |#ifndef PB_NO_ERRMSG
   45|       |    const char *errmsg;
   46|       |#endif
   47|       |};
   48|       |
   49|       |/***************************
   50|       | * Main encoding functions *
   51|       | ***************************/
   52|       |
   53|       |/* Encode a single protocol buffers message from C structure into a stream.
   54|       | * Returns true on success, false on any failure.
   55|       | * The actual struct pointed to by src_struct must match the description in fields.
   56|       | * All required fields in the struct are assumed to have been filled in.
   57|       | *
   58|       | * Example usage:
   59|       | *    MyMessage msg = {};
   60|       | *    uint8_t buffer[64];
   61|       | *    pb_ostream_t stream;
   62|       | *
   63|       | *    msg.field1 = 42;
   64|       | *    stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
   65|       | *    pb_encode(&stream, MyMessage_fields, &msg);
   66|       | */
   67|       |bool pb_encode(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
   68|       |
   69|       |/* Same as pb_encode, but prepends the length of the message as a varint.
   70|       | * Corresponds to writeDelimitedTo() in Google's protobuf API.
   71|       | */
   72|       |bool pb_encode_delimited(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
   73|       |
   74|       |/* Same as pb_encode, but appends a null byte to the message for termination.
   75|       | * NOTE: This behaviour is not supported in most other protobuf implementations, so pb_encode_delimited()
   76|       | * is a better option for compatibility.
   77|       | */
   78|       |bool pb_encode_nullterminated(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
   79|       |
   80|       |/* Encode the message to get the size of the encoded data, but do not store
   81|       | * the data. */
   82|       |bool pb_get_encoded_size(size_t *size, const pb_field_t fields[], const void *src_struct);
   83|       |
   84|       |/**************************************
   85|       | * Functions for manipulating streams *
   86|       | **************************************/
   87|       |
   88|       |/* Create an output stream for writing into a memory buffer.
   89|       | * The number of bytes written can be found in stream.bytes_written after
   90|       | * encoding the message.
   91|       | *
   92|       | * Alternatively, you can use a custom stream that writes directly to e.g.
   93|       | * a file or a network socket.
   94|       | */
   95|       |pb_ostream_t pb_ostream_from_buffer(pb_byte_t *buf, size_t bufsize);
   96|       |
   97|       |/* Pseudo-stream for measuring the size of a message without actually storing
   98|       | * the encoded data.
   99|       | * 
  100|       | * Example usage:
  101|       | *    MyMessage msg = {};
  102|       | *    pb_ostream_t stream = PB_OSTREAM_SIZING;
  103|       | *    pb_encode(&stream, MyMessage_fields, &msg);
  104|       | *    printf("Message size is %d\n", stream.bytes_written);
  105|       | */
  106|       |#ifndef PB_NO_ERRMSG
  107|      0|#define PB_OSTREAM_SIZING {0,0,0,0,0}
  108|       |#else
  109|       |#define PB_OSTREAM_SIZING {0,0,0,0}
  110|       |#endif
  111|       |
  112|       |/* Function to write into a pb_ostream_t stream. You can use this if you need
  113|       | * to append or prepend some custom headers to the message.
  114|       | */
  115|       |bool pb_write(pb_ostream_t *stream, const pb_byte_t *buf, size_t count);
  116|       |
  117|       |
  118|       |/************************************************
  119|       | * Helper functions for writing field callbacks *
  120|       | ************************************************/
  121|       |
  122|       |/* Encode field header based on type and field number defined in the field
  123|       | * structure. Call this from the callback before writing out field contents. */
  124|       |bool pb_encode_tag_for_field(pb_ostream_t *stream, const pb_field_t *field);
  125|       |
  126|       |/* Encode field header by manually specifying wire type. You need to use this
  127|       | * if you want to write out packed arrays from a callback field. */
  128|       |bool pb_encode_tag(pb_ostream_t *stream, pb_wire_type_t wiretype, uint32_t field_number);
  129|       |
  130|       |/* Encode an integer in the varint format.
  131|       | * This works for bool, enum, int32, int64, uint32 and uint64 field types. */
  132|       |#ifndef PB_WITHOUT_64BIT
  133|       |bool pb_encode_varint(pb_ostream_t *stream, uint64_t value);
  134|       |#else
  135|       |bool pb_encode_varint(pb_ostream_t *stream, uint32_t value);
  136|       |#endif
  137|       |
  138|       |/* Encode an integer in the zig-zagged svarint format.
  139|       | * This works for sint32 and sint64. */
  140|       |#ifndef PB_WITHOUT_64BIT
  141|       |bool pb_encode_svarint(pb_ostream_t *stream, int64_t value);
  142|       |#else
  143|       |bool pb_encode_svarint(pb_ostream_t *stream, int32_t value);
  144|       |#endif
  145|       |
  146|       |/* Encode a string or bytes type field. For strings, pass strlen(s) as size. */
  147|       |bool pb_encode_string(pb_ostream_t *stream, const pb_byte_t *buffer, size_t size);
  148|       |
  149|       |/* Encode a fixed32, sfixed32 or float value.
  150|       | * You need to pass a pointer to a 4-byte wide C variable. */
  151|       |bool pb_encode_fixed32(pb_ostream_t *stream, const void *value);
  152|       |
  153|       |#ifndef PB_WITHOUT_64BIT
  154|       |/* Encode a fixed64, sfixed64 or double value.
  155|       | * You need to pass a pointer to a 8-byte wide C variable. */
  156|       |bool pb_encode_fixed64(pb_ostream_t *stream, const void *value);
  157|       |#endif
  158|       |
  159|       |/* Encode a submessage field.
  160|       | * You need to pass the pb_field_t array and pointer to struct, just like
  161|       | * with pb_encode(). This internally encodes the submessage twice, first to
  162|       | * calculate message size and then to actually write it out.
  163|       | */
  164|       |bool pb_encode_submessage(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
  165|       |
  166|       |#ifdef __cplusplus
  167|       |} /* extern "C" */
  168|       |#endif
  169|       |
  170|       |#endif

